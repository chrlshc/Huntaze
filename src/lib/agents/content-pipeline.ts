import { eventEmitter } from '@/lib/services/eventEmitter';
import { EventBus, buildExternalPublisher } from '@/src/lib/agents/event-bus';
import { makeCorrelation, type Correlation } from '@/src/lib/agents/events';
import { sseRegistry } from '@/src/lib/sse/registry';
import { FileOutbox } from '@/src/lib/agents/outbox';
import { withConsoleLog, withOutbox, withSseFanout } from '@/src/lib/agents/middlewares';

// Event types (align with Python example naming)
export const EVENT_PLAN_REQUEST = 'PLAN_REQUEST';
export const EVENT_PLAN_READY = 'PLAN_READY';
export const EVENT_CONTENT_READY = 'CONTENT_READY';
export const EVENT_POST_SCHEDULED = 'POST_SCHEDULED';
export const EVENT_ANALYTICS_UPDATE = 'ANALYTICS_UPDATE';
export const EVENT_TRENDS_UPDATE = 'TRENDS_UPDATE';
export const EVENT_PPV_CAMPAIGN_REQUEST = 'PPV_CAMPAIGN_REQUEST';
export const EVENT_PPV_CAMPAIGNS_READY = 'PPV_CAMPAIGNS_READY';
export const EVENT_PPV_CAMPAIGNS_SENT = 'PPV_CAMPAIGNS_SENT';

export type ContentPlanItem = { day: string; idea: string };
export type GeneratedContent = { idea: string; text: string; image?: string };
export type EngagementMetric = { idea: string; likes: number; comments: number; new_subscribers: number };

export interface PlanRequestInfo {
  period?: string;
  modelId?: string;
  timezone?: string;
  platforms?: string[];
  // OnlyFans targets (conversations) to send to
  userId?: string;
  ofTargets?: Array<{ conversationId: string }>;
  preferences?: Record<string, unknown>;
}

// Base class to help emit SSE task updates
class Notifier {
  protected notify(event: string, payload: any) {
    try {
      eventEmitter.emit({ type: 'task_update', event, payload });
      const modelId = payload?.correlation?.modelId ?? payload?.modelId;
      if (modelId) sseRegistry.emit(modelId, { event, ...payload });
    } catch {
      // ignore SSE failures
    }
  }
}

export class ContentPlannerAgent extends Notifier {
  constructor(private bus: EventBus) {
    super();
    bus.subscribe(EVENT_PLAN_REQUEST, this.handle_plan_request.bind(this));
  }

  private async handle_plan_request(request_info?: any) {
    const correlation: Correlation | undefined = request_info?.correlation;
    const platforms: string[] | undefined = request_info?.platforms;
    const finalPlan: ContentPlanItem[] = [
      { day: 'Monday', idea: 'Post about new content release' },
      { day: 'Wednesday', idea: 'Share behind-the-scenes photo' },
      { day: 'Friday', idea: 'Weekly Q&A session' },
    ];
    // eslint-disable-next-line no-console
    console.log('[Planner] Generated plan:', finalPlan, 'for', request_info);
    this.notify(EVENT_PLAN_READY, { correlation, plan: finalPlan, platforms, ofTargets: request_info?.ofTargets, userId: request_info?.userId });
    await this.bus.publish(EVENT_PLAN_READY, { correlation, plan: finalPlan, platforms, ofTargets: request_info?.ofTargets, userId: request_info?.userId });
  }
}

export class ContentGeneratorAgent extends Notifier {
  constructor(private bus: EventBus) {
    super();
    bus.subscribe(EVENT_PLAN_READY, this.handle_plan_ready.bind(this));
  }

  private async handle_plan_ready(evt?: any) {
    const plan: ContentPlanItem[] = evt?.plan ?? [];
    const correlation: Correlation | undefined = evt?.correlation;
    const platforms: string[] | undefined = evt?.platforms;
    const contents: GeneratedContent[] = [];
    (plan ?? []).forEach((item) => {
      const idea = item.idea;
      const content: GeneratedContent = {
        idea,
        text: `${idea} - caption generated by AI`,
        image: `image_for_${idea.replace(/\s+/g, '_')}.png`,
      };
      contents.push(content);
      // eslint-disable-next-line no-console
      console.log(`[Generator] Created content for idea: '${idea}'`);
    });
    this.notify(EVENT_CONTENT_READY, { correlation, contents, platforms, ofTargets: evt?.ofTargets, userId: evt?.userId });
    await this.bus.publish(EVENT_CONTENT_READY, { correlation, contents, platforms, ofTargets: evt?.ofTargets, userId: evt?.userId });
  }
}

export class PostSchedulerAgent extends Notifier {
  constructor(private bus: EventBus) {
    super();
    bus.subscribe(EVENT_CONTENT_READY, this.handle_content_ready.bind(this));
    bus.subscribe(EVENT_PPV_CAMPAIGNS_READY, this.handle_ppv_campaigns_ready.bind(this));
  }

  private async handle_content_ready(evt?: any) {
    const contents: GeneratedContent[] = evt?.contents ?? [];
    const correlation: Correlation | undefined = evt?.correlation;
    const platforms: string[] = evt?.platforms ?? [];
    const ofTargets: Array<{ conversationId: string }> = evt?.ofTargets ?? [];
    const userId: string | undefined = evt?.userId;

    const scheduled: Array<{ platform: string; externalId?: string; at: string; conversationId?: string }> = [];

    for (const content of contents) {
      // Simple policy: if onlyfans requested and targets provided, enqueue DMs via AWS SQS (if configured)
      if (platforms.includes('onlyfans') && ofTargets.length > 0 && userId) {
        try {
          const { enqueueSend } = await import('@/src/lib/queue/of-sqs');
          for (const t of ofTargets) {
            const idempotencyKey = `${correlation?.runId || 'run'}:${content.idea}:${t.conversationId}`;
            await enqueueSend({ id: idempotencyKey, userId, conversationId: t.conversationId, content: { text: content.text } });
            scheduled.push({ platform: 'onlyfans', externalId: idempotencyKey, at: new Date().toISOString(), conversationId: t.conversationId });
          }
        } catch (e) {
          // Fallback to local queue in dev
          try {
            const { queueDmMessage } = await import('@/src/lib/queue/of-queue');
            for (const t of ofTargets) {
              const mid = await queueDmMessage(userId, t.conversationId, { text: content.text });
              scheduled.push({ platform: 'onlyfans', externalId: mid, at: new Date().toISOString(), conversationId: t.conversationId });
            }
          } catch (err) {
            // eslint-disable-next-line no-console
            console.error('[Scheduler] onlyfans enqueue failed:', err);
          }
        }
      } else {
        // Default placeholder scheduling
        // eslint-disable-next-line no-console
        console.log(`[Scheduler] Scheduling post (placeholder): '${content.text}'`);
        scheduled.push({ platform: 'instagram', at: new Date().toISOString() });
      }
    }

    this.notify(EVENT_POST_SCHEDULED, { correlation, scheduled });
    await this.bus.publish(EVENT_POST_SCHEDULED, { correlation, scheduled });
  }

  private async handle_ppv_campaigns_ready(evt?: any) {
    const correlation: Correlation | undefined = evt?.correlation;
    const userId: string | undefined = evt?.userId;
    const campaigns: Array<{ conversationId: string; price: number; variant?: 'A'|'B'|'C'; content: { media: string; caption: string } }>
      = evt?.campaigns ?? [];
    const results: Array<{ conversationId: string; externalId: string; price: number; variant?: string }> = [];

    if (!userId || campaigns.length === 0) {
      this.notify(EVENT_PPV_CAMPAIGNS_SENT, { correlation, results });
      await this.bus.publish(EVENT_PPV_CAMPAIGNS_SENT, { correlation, results });
      return;
    }

    try {
      const { enqueueSend } = await import('@/src/lib/queue/of-sqs');
      for (const c of campaigns) {
        const idempotencyKey = `${correlation?.runId || 'run'}:ppv:${c.conversationId}:${c.variant || 'A'}`;
        await enqueueSend({
          id: idempotencyKey,
          userId,
          conversationId: c.conversationId,
          content: { text: c.content.caption },
          ppv: { priceCents: Math.round(c.price * 100), caption: c.content.caption, mediaUrl: c.content.media, variant: (c.variant as any) },
        });
        results.push({ conversationId: c.conversationId, externalId: idempotencyKey, price: c.price, variant: c.variant });
      }
    } catch (e) {
      // fallback: enqueue local (text only)
      try {
        const { queueDmMessage } = await import('@/src/lib/queue/of-queue');
        for (const c of campaigns) {
          const mid = await queueDmMessage(userId, c.conversationId, { text: c.content.caption });
          results.push({ conversationId: c.conversationId, externalId: mid, price: c.price, variant: c.variant });
        }
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error('[Scheduler] ppv enqueue failed:', err);
      }
    }

    this.notify(EVENT_PPV_CAMPAIGNS_SENT, { correlation, results });
    await this.bus.publish(EVENT_PPV_CAMPAIGNS_SENT, { correlation, results });
  }
}

export class EngagementTrackerAgent extends Notifier {
  constructor(private bus: EventBus) {
    super();
    bus.subscribe(EVENT_POST_SCHEDULED, this.handle_post_scheduled.bind(this));
  }

  private async handle_post_scheduled(evt?: any) {
    const correlation: Correlation | undefined = evt?.correlation;
    const metrics: EngagementMetric[] = (evt?.scheduled ?? []).map((s: any, i: number) => ({
      idea: `idea_${i + 1}`,
      likes: 100,
      comments: 5,
      new_subscribers: 2,
    }));
    // eslint-disable-next-line no-console
    console.log('[Tracker] Collected engagement metrics:', metrics);
    this.notify(EVENT_ANALYTICS_UPDATE, { correlation, metrics: metrics.map(m => ({ idea: m.idea, likes: m.likes, comments: m.comments, newSubscribers: m.new_subscribers })) });
    await this.bus.publish(EVENT_ANALYTICS_UPDATE, { correlation, metrics: metrics.map(m => ({ idea: m.idea, likes: m.likes, comments: m.comments, newSubscribers: m.new_subscribers })) });
  }
}

export class TrendSpotterAgent extends Notifier {
  constructor(private bus: EventBus) {
    super();
    // Could be triggered by cron/timer; exposed via method below
  }

  async scan_trends(correlation?: Correlation) {
    const trends = ['#NewChallenge', '#ViralSong'];
    // eslint-disable-next-line no-console
    console.log('[TrendSpotter] Detected trends:', trends);
    this.notify(EVENT_TRENDS_UPDATE, { correlation, trends });
    await this.bus.publish(EVENT_TRENDS_UPDATE, { correlation, trends });
  }
}

export class PromoManagerAgent extends Notifier {
  constructor(private _bus: EventBus) {
    super();
  }

  async run_campaign(content: GeneratedContent) {
    // eslint-disable-next-line no-console
    console.log(`[PromoManager] Running promo campaign for content: '${content.idea}'`);
  }
}

export interface PipelineResult {
  plan: ContentPlanItem[];
  contents: GeneratedContent[];
  metrics: EngagementMetric[];
  trends: string[];
}

export async function runContentPipeline(req: PlanRequestInfo = {}): Promise<PipelineResult> {
  const external = buildExternalPublisher('ai-team');
  const bus = new EventBus({ external, source: 'ai-team' });
  // Middlewares: log, persist, then fanout SSE
  bus.use(withConsoleLog());
  bus.use(withOutbox(new FileOutbox()));
  bus.use(withSseFanout());

  const planner = new ContentPlannerAgent(bus);
  const generator = new ContentGeneratorAgent(bus);
  const scheduler = new PostSchedulerAgent(bus);
  const tracker = new EngagementTrackerAgent(bus);
  const trendspotter = new TrendSpotterAgent(bus);
  const promomanager = new PromoManagerAgent(bus);

  void promomanager; // kept for future integration

  // Accumulate outputs as they flow through events
  const outcome: PipelineResult = { plan: [], contents: [], metrics: [], trends: [] };

  const unsubPlan = bus.subscribe(EVENT_PLAN_READY, (evt) => {
    outcome.plan = evt?.plan ?? [];
  });
  const unsubContent = bus.subscribe(EVENT_CONTENT_READY, (evt) => {
    outcome.contents = evt?.contents ?? [];
  });
  const unsubMetrics = bus.subscribe(EVENT_ANALYTICS_UPDATE, (evt) => {
    outcome.metrics = (evt?.metrics ?? []).map((m: any) => ({ idea: m.idea, likes: m.likes, comments: m.comments, new_subscribers: m.newSubscribers }));
  });
  const unsubTrends = bus.subscribe(EVENT_TRENDS_UPDATE, (evt) => {
    outcome.trends = evt?.trends ?? [];
  });

  // Kick off the flow
  const modelId = req.modelId ?? 'default-model';
  const correlation = makeCorrelation(modelId);
  await bus.publish(EVENT_PLAN_REQUEST, { correlation, period: (req.period as any) ?? 'next_week', platforms: req.platforms });
  await trendspotter.scan_trends(correlation);

  // Clean up listeners
  unsubPlan();
  unsubContent();
  unsubMetrics();
  unsubTrends();

  return outcome;
}
