Je te le fais en mode :
üëâ √âtape ‚Üí Objectif ‚Üí Fichiers ‚Üí Ce que tu codes concr√®tement.

√âtape 0 ‚Äì Fondations IA (une seule fois)
0.1 ‚Äì Router + client g√©n√©rique

Fichiers :

lib/ai/huntaze-router.ts

lib/ai/aiService.ts (ou √©quivalent)

√Ä faire :

D√©finir les types :

export type AIType =
  | 'analytics'
  | 'content-creation'
  | 'content-variations'
  | 'content-analysis'
  | 'fan-segmentation'
  | 'automation-builder'
  | 'chat'
  | 'offers'
  | 'marketing'
  | 'schedule';


Router mod√®les (comme dans la doc) :

export const MODEL_ROUTING: Record<AIType, string> = {
  analytics: 'mistral-large',
  'content-creation': 'mistral-large',
  'content-variations': 'mistral-large',
  'content-analysis': 'mistral-large',
  'fan-segmentation': 'deepseek-r1',
  'automation-builder': 'deepseek-r1',
  chat: 'llama-3.3-70b',
  offers: 'llama-3.3-70b',
  marketing: 'mistral-large',
  schedule: 'mistral-large',
};


Client g√©n√©rique :

export async function aiRequest<T = unknown>(params: {
  type: AIType;
  prompt: string;
  modelOverride?: string;
  temperature?: number;
}): Promise<T> {
  const model = params.modelOverride ?? MODEL_ROUTING[params.type];

  // appel HTTP √† ton backend / provider ici
  // return parsed JSON / texte
}


Important : d√®s que tu peux, demande du JSON dans tes prompts, comme √ßa tu tapes direct dans des types TypeScript.

√âtape 1 ‚Äì Analytics IA (Insights + Rapports)
1.1 ‚Äì Service d‚Äôinsights

Fichiers :

lib/api/services/analytics.service.ts

lib/ai/analytics-insights.service.ts (nouveau)

√Ä faire :

Cr√©er un type :

export interface AnalyticsInsights {
  keyInsights: string[];         // 3 √©l√©ments
  recommendations: string[];     // 2 √©l√©ments
}


Impl√©menter le service IA :

import { aiRequest } from '../aiService';

export async function generateAnalyticsInsights(
  metrics: AnalyticsMetrics
): Promise<AnalyticsInsights> {
  const prompt = `
    Analyse ces m√©triques OnlyFans et retourne du JSON strict:
    Metrics:
    - ARPU: ${metrics.arpu}
    - LTV: ${metrics.ltv}
    - Churn: ${metrics.churnRate}%
    - MoM Growth: ${metrics.momGrowth}%

    Format JSON:
    {
      "keyInsights": ["...", "...", "..."],
      "recommendations": ["...", "..."]
    }
  `;

  return aiRequest<AnalyticsInsights>({
    type: 'analytics',
    prompt,
  });
}


Dans analytics.service.ts, ajouter une m√©thode :

async getDashboardWithInsights(userId: string) {
  const metrics = await this.getMetrics(userId);
  const insights = await generateAnalyticsInsights(metrics);
  return { metrics, insights };
}

1.2 ‚Äì UI Analytics

Fichiers :

app/(app)/analytics/*

components/analytics/TopContentGrid.tsx (juste pour r√©utiliser plus tard)

√Ä faire :

Sur la page Analytics principale :

R√©cup√©rer metrics + insights.

Bloc ‚Äúüí° Insights IA‚Äù avec :

Liste des keyInsights

Liste des recommendations

√âtape 2 ‚Äì Content Creation (Variations + Captions + Ton)
2.1 ‚Äì Variations A/B auto

Fichiers :

components/content/AIAssistant.tsx

components/content/VariationManager.tsx

√Ä faire :

Service IA :

interface Variation {
  label: string;   // "Plus √©motionnel", etc.
  text: string;
}

export async function generateVariations(
  content: string,
  count = 5
): Promise<Variation[]> {
  const prompt = `
    G√©n√®re ${count} variations de ce contenu OnlyFans:

    "${content}"

    Tu dois r√©pondre en JSON:
    [
      { "label": "plus √©motionnel", "text": "..." },
      { "label": "plus direct/urgent", "text": "..." },
      { "label": "avec emojis", "text": "..." },
      { "label": "plus myst√©rieux", "text": "..." },
      { "label": "call-to-action fort", "text": "..." }
    ]
  `;

  return aiRequest<Variation[]>({
    type: 'content-variations',
    prompt,
  });
}


UI VariationManager :

Bouton ‚ÄúG√©n√©rer des variations IA‚Äù.

State variations.

Pour chaque variation : carte + bouton ‚ÄúUtiliser‚Äù.

2.2 ‚Äì Captions optimis√©es par plateforme + ton

Fichiers :

components/content/ContentCreator.tsx

components/content/AIAssistant.tsx (si tu regroupe la logique)

√Ä faire :

Types :

type Platform = 'twitter' | 'instagram' | 'onlyfans' | 'tiktok';
type Tone = 'casual' | 'sexy' | 'pro' | 'mysterious';


Service IA :

interface CaptionResult {
  platform: Platform;
  tone: Tone;
  caption: string;
  maxLength: number;
  length: number;
}

export async function generateCaption(params: {
  baseContent: string;
  platform: Platform;
  tone: Tone;
}): Promise<CaptionResult> {
  const limit = params.platform === 'twitter' ? 280 :
                params.platform === 'instagram' ? 2200 : 2000;

  const prompt = `
    Tu es expert social media pour cr√©ateur OnlyFans.

    Contenu de base:
    "${params.baseContent}"

    Plateforme: ${params.platform}
    Ton: ${params.tone}
    Longueur max: ${limit} caract√®res.

    Donne une seule caption optimis√©e, en JSON:
    {
      "platform": "${params.platform}",
      "tone": "${params.tone}",
      "caption": "...",
      "maxLength": ${limit},
      "length": <longueur r√©elle>
    }
  `;

  return aiRequest<CaptionResult>({
    type: 'content-creation',
    prompt,
  });
}


UI :

S√©lecteur plateforme + ton.

Bouton ‚ÄúG√©n√©rer caption IA‚Äù.

Afficher le compteur length / maxLength.

√âtape 3 ‚Äì Top Content Analysis (Patterns + reco)

Fichiers :

components/analytics/TopContentGrid.tsx

lib/ai/top-content-analysis.service.ts

√Ä faire :

Service IA :

interface TopContentInsights {
  successPatterns: string[];
  recommendations: string[];
  bestTimes: string[]; // ex: ["Lundi 19-21h", "Samedi 10-12h"]
}

export async function analyzeTopContent(
  items: ContentItem[]
): Promise<TopContentInsights> {
  const minimal = items.map(c => ({
    title: c.title,
    engagement: c.engagementRate,
    likes: c.likes,
    comments: c.comments,
    shares: c.shares,
    publishedAt: c.publishedAt,
    platform: c.platform,
  }));

  const prompt = `
    Analyse ces top posts (OnlyFans + socials) et r√©ponds en JSON:

    ${JSON.stringify(minimal)}

    Format:
    {
      "successPatterns": ["...", "...", "..."],
      "recommendations": ["...", "..."],
      "bestTimes": ["...", "..."]
    }
  `;

  return aiRequest<TopContentInsights>({
    type: 'content-analysis',
    prompt,
  });
}


UI :

Dans TopContentGrid, apr√®s avoir charg√© les posts :

Appel √† analyzeTopContent.

Bloc sous le grid :

‚ÄúPatterns de succ√®s‚Äù

‚ÄúRecommandations‚Äù

‚ÄúMeilleurs cr√©neaux‚Äù.

√âtape 4 ‚Äì Fans CRM (Segmentation + Churn + Upsell)

Fichiers :

app/api/crm/fans/route.ts

app/(app)/fans/page.tsx

lib/ai/fans-crm.service.ts

4.1 ‚Äì Segmentation + churn

Types :

interface FanSegment {
  id: string;
  segment: 'whale' | 'regular' | 'at-risk';
  churnScore: number; // 0-100
  reason?: string;
}

interface FansSegmentationResult {
  segments: FanSegment[];
}


Service IA :

export async function segmentFans(
  fans: RawFan[]
): Promise<FansSegmentationResult> {
  const minimal = fans.map(f => ({
    id: f.id,
    lifetimeValue: f.ltv,
    monthlyValue: f.mrr,
    lastActiveAt: f.lastActiveAt,
    messagesCount: f.messagesCount,
    tipsCount: f.tipsCount,
    subscriptionAgeDays: f.subscriptionAgeDays,
  }));

  const prompt = `
    Segmente ces fans OnlyFans en whales/regulars/at-risk et pr√©dis le churn.

    Donne un JSON:
    {
      "segments": [
        {
          "id": "<id>",
          "segment": "whale" | "regular" | "at-risk",
          "churnScore": 0-100,
          "reason": "..."
        }
      ]
    }

    Data:
    ${JSON.stringify(minimal)}
  `;

  return aiRequest<FansSegmentationResult>({
    type: 'fan-segmentation',
    prompt,
  });
}


API route :

Endpoint /api/crm/fans/segments qui :

R√©cup√®re les fans bruts.

Appelle segmentFans.

Retourne la structure.

UI fans/page.tsx :

Afficher des badges Whale, √Ä risque.

Filtres par segment.

Afficher le churnScore (%) + tooltip reason.

4.2 ‚Äì Upsell suggestions / outreach (optionnel mais rapide)

M√™me principe :
‚Üí Passer quelques fans whale √† l‚ÄôIA et demander un champ upsellIdea + messageTemplate.

√âtape 5 ‚Äì Marketing Campaigns (Generator + Subject Lines)

Fichiers :

app/(app)/marketing/campaigns/new/page.tsx

hooks/marketing/useMarketingCampaigns.ts

lib/ai/marketing.service.ts

5.1 ‚Äì Campaign Generator

Types :

interface GeneratedCampaign {
  subject: string;
  previewText: string;
  bodyHtml: string;
  cta: string;
  angle: string;
}


Service IA :

export async function generateCampaign(params: {
  goal: string;
  audience: string;
  tone: Tone;
}): Promise<GeneratedCampaign> {
  const prompt = `
    Cr√©e une campagne marketing pour cr√©atrice OnlyFans.

    Objectif: ${params.goal}
    Audience: ${params.audience}
    Ton: ${params.tone}

    Retourne du JSON:
    {
      "subject": "...",
      "previewText": "...",
      "bodyHtml": "<p>...</p>",
      "cta": "...",
      "angle": "..."
    }
  `;

  return aiRequest<GeneratedCampaign>({
    type: 'marketing',
    prompt,
  });
}


UI :

Formulaire avec goal, audience, tone.

Bouton ‚ÄúG√©n√©rer avec l‚ÄôIA‚Äù.

Pr√©-remplir les champs du formulaire campagne avec le r√©sultat.

5.2 ‚Äì Subject line optimizer

Petite fonction optimizeSubjectLines(baseSubject, audience) ‚Üí retourne un tableau de 5 sujets, affich√©s sous forme de liste cliquable.

√âtape 6 ‚Äì Automations (Flow Builder + Templates)

Fichiers :

app/(app)/automations/page.tsx

app/(app)/flows/page.tsx

lib/ai/automation-builder.service.ts

6.1 ‚Äì Flow Builder IA

Types :

interface AutomationStep {
  id: string;
  type: 'trigger' | 'condition' | 'action';
  name: string;
  config: Record<string, any>;
}

interface AutomationFlow {
  name: string;
  description: string;
  steps: AutomationStep[];
}


Service IA :

export async function buildAutomationFlow(
  description: string
): Promise<AutomationFlow> {
  const prompt = `
    L'utilisateur d√©crit un flow d'automatisation OnlyFans:

    "${description}"

    Tu dois r√©pondre en JSON:
    {
      "name": "...",
      "description": "...",
      "steps": [
        {
          "id": "step-1",
          "type": "trigger",
          "name": "New subscriber",
          "config": {...}
        },
        {
          "id": "step-2",
          "type": "action",
          "name": "Send welcome message",
          "config": {...}
        }
      ]
    }
  `;

  return aiRequest<AutomationFlow>({
    type: 'automation-builder',
    prompt,
  });
}


UI :

Textarea ‚ÄúD√©cris ton automation‚Äù.

Bouton ‚ÄúG√©n√©rer le flow‚Äù.

Affichage des steps en liste (tu feras un vrai editor visuel plus tard si tu veux).

√âtape 7 ‚Äì Offers & Discounts (Pricing / Bundles)

Fichiers :

app/(app)/offers/page.tsx

lib/ai/offers.service.ts

M√™me pattern : tu passes les produits, prix actuels, historique, et tu demandes au mod√®le (Llama 3.3) un JSON avec :

recommendedPrice

bundleIdeas[]

discountStrategy[]

√âtape 8 ‚Äì Schedule (Smart Scheduling + Gaps)

Fichiers :

app/(app)/schedule/page.tsx

components/content/ContentCalendar.tsx

lib/ai/schedule.service.ts

Tu passes :

historique des posts (date/heure, plateforme, engagement).

planning actuel.

Tu demandes :

bestSlots[] (cr√©neaux recommand√©s).

gaps[] (jours/heures sans contenu).

√©ventuellement perPlatform.

UI :

Mettre en avant les cr√©neaux conseill√©s (halo, bordure sp√©ciale).

Bouton ‚ÄúPlacer automatiquement dans les meilleurs cr√©neaux‚Äù.

√âtape 9 ‚Äì Finitions globales

Quand tout est branch√© :

Ajoute un petit badge ‚ÄúIA‚Äù sur chaque bloc IA.

Ajoute de la gestion d‚Äôerreurs : si l‚ÄôIA fail ‚Üí message fallback propre.

Ajoute de la limitation / cache pour ne pas spam les mod√®les sur chaque re-render.