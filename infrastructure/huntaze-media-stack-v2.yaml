AWSTemplateFormatVersion: '2010-09-09'
Description: 'Huntaze Media Processing Stack - Lambda + Rekognition + DynamoDB + S3'

Parameters:
  Environment:
    Type: String
    Default: production
    AllowedValues:
      - development
      - staging
      - production
    Description: Environment name
  
  AlertEmail:
    Type: String
    Default: alerts@huntaze.com
    Description: Email for moderation alerts

Resources:
  # S3 Bucket for media storage
  MediaVaultBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'huntaze-media-vault-${Environment}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldVersions
            NoncurrentVersionExpirationInDays: 30
            Status: Enabled

  # DynamoDB table for metadata
  MediaVaultTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'HuntazeMediaVault-${Environment}'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: mediaId
          AttributeType: S
        - AttributeName: userId
          AttributeType: S
        - AttributeName: uploadDate
          AttributeType: S
      KeySchema:
        - AttributeName: mediaId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: UserIdIndex
          KeySchema:
            - AttributeName: userId
              KeyType: HASH
            - AttributeName: uploadDate
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true

  # SQS Queues
  AlertQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub 'huntaze-alerts-${Environment}'
      MessageRetentionPeriod: 1209600
      VisibilityTimeout: 300
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt DeadLetterQueue.Arn
        maxReceiveCount: 3

  EnrichmentQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub 'huntaze-enrichment-${Environment}'
      MessageRetentionPeriod: 345600
      VisibilityTimeout: 60

  DeadLetterQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub 'huntaze-dlq-${Environment}'
      MessageRetentionPeriod: 1209600

  # SNS Topic for alerts
  ModerationAlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub 'huntaze-moderation-alerts-${Environment}'
      DisplayName: 'Huntaze Content Moderation Alerts'
      Subscription:
        - Endpoint: !Ref AlertEmail
          Protocol: email

  # IAM Role for Lambda
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'HuntazeImageProcessorRole-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: MediaProcessingPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                Resource: !Sub 'arn:aws:s3:::huntaze-media-vault-${Environment}/*'
              - Effect: Allow
                Action:
                  - rekognition:DetectModerationLabels
                  - rekognition:DetectLabels
                  - rekognition:DetectText
                  - rekognition:DetectFaces
                Resource: '*'
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt MediaVaultTable.Arn
                  - !Sub '${MediaVaultTable.Arn}/index/*'
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                Resource:
                  - !GetAtt AlertQueue.Arn
                  - !GetAtt EnrichmentQueue.Arn
                  - !GetAtt DeadLetterQueue.Arn
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource: !Ref ModerationAlertTopic

  # CloudWatch Log Group
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/huntaze-image-processor-${Environment}'
      RetentionInDays: 30

  # Lambda function for image processing
  ImageProcessorFunction:
    Type: AWS::Lambda::Function
    DependsOn: LogGroup
    Properties:
      FunctionName: !Sub 'huntaze-image-processor-${Environment}'
      Runtime: nodejs18.x
      Handler: index.handler
      Code:
        ZipFile: |
          const { RekognitionClient, DetectModerationLabelsCommand } = require('@aws-sdk/client-rekognition');
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, PutCommand } = require('@aws-sdk/lib-dynamodb');
          const { SQSClient, SendMessageCommand } = require('@aws-sdk/client-sqs');
          const { SNSClient, PublishCommand } = require('@aws-sdk/client-sns');
          
          const rekognition = new RekognitionClient();
          const dynamodb = DynamoDBDocumentClient.from(new DynamoDBClient());
          const sqs = new SQSClient();
          const sns = new SNSClient();
          
          exports.handler = async (event) => {
            console.log('Processing S3 event:', JSON.stringify(event));
            
            for (const record of event.Records) {
              const bucket = record.s3.bucket.name;
              const key = decodeURIComponent(record.s3.object.key.replace(/\+/g, ' '));
              
              try {
                // Analyze with Rekognition
                const moderationResult = await rekognition.send(new DetectModerationLabelsCommand({
                  Image: {
                    S3Object: { Bucket: bucket, Name: key }
                  },
                  MinConfidence: 60
                }));
                
                const labels = moderationResult.ModerationLabels || [];
                
                // Determine content status
                const explicitContent = labels.some(l => 
                  l.ParentName === 'Explicit Nudity' || l.Name === 'Nudity'
                );
                const violence = labels.some(l => 
                  l.ParentName === 'Violence' && l.Confidence > 80
                );
                
                const status = violence ? 'blocked' : 
                              explicitContent ? 'explicit' : 'safe';
                
                // Save to DynamoDB
                const mediaRecord = {
                  mediaId: key,
                  userId: key.split('/')[0],
                  uploadDate: new Date().toISOString(),
                  bucket,
                  status,
                  moderationLabels: labels,
                  analyzedAt: new Date().toISOString()
                };
                
                await dynamodb.send(new PutCommand({
                  TableName: process.env.MEDIA_TABLE,
                  Item: mediaRecord
                }));
                
                // Send alerts for blocked content
                if (status === 'blocked') {
                  await sns.send(new PublishCommand({
                    TopicArn: process.env.ALERT_TOPIC,
                    Subject: 'Content Blocked - Review Required',
                    Message: JSON.stringify({
                      mediaId: key,
                      reason: 'Violence detected',
                      labels: labels.filter(l => l.Confidence > 80)
                    }, null, 2)
                  }));
                }
                
                // Queue for enrichment
                if (status !== 'blocked') {
                  await sqs.send(new SendMessageCommand({
                    QueueUrl: process.env.ENRICHMENT_QUEUE,
                    MessageBody: JSON.stringify({
                      mediaId: key,
                      status,
                      labels
                    })
                  }));
                }
                
                console.log(`Processed ${key}: ${status}`);
                
              } catch (error) {
                console.error(`Error processing ${key}:`, error);
                
                await sqs.send(new SendMessageCommand({
                  QueueUrl: process.env.DLQ_URL,
                  MessageBody: JSON.stringify({
                    error: error.message,
                    bucket,
                    key,
                    timestamp: new Date().toISOString()
                  })
                }));
              }
            }
          };
      MemorySize: 512
      Timeout: 60
      Environment:
        Variables:
          MEDIA_TABLE: !Ref MediaVaultTable
          ALERT_QUEUE: !GetAtt AlertQueue.QueueUrl
          ENRICHMENT_QUEUE: !GetAtt EnrichmentQueue.QueueUrl
          DLQ_URL: !GetAtt DeadLetterQueue.QueueUrl
          ALERT_TOPIC: !Ref ModerationAlertTopic
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
      Role: !GetAtt LambdaExecutionRole.Arn

  # Lambda permission for S3 to invoke
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ImageProcessorFunction
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceArn: !Sub 'arn:aws:s3:::huntaze-media-vault-${Environment}'

Outputs:
  BucketName:
    Description: S3 bucket for media uploads
    Value: !Ref MediaVaultBucket

  TableName:
    Description: DynamoDB table for media metadata
    Value: !Ref MediaVaultTable

  LambdaFunctionArn:
    Description: Lambda function ARN
    Value: !GetAtt ImageProcessorFunction.Arn

  AlertTopicArn:
    Description: SNS topic for alerts
    Value: !Ref ModerationAlertTopic

  EnrichmentQueueUrl:
    Description: SQS queue for enrichment
    Value: !GetAtt EnrichmentQueue.QueueUrl

  AlertQueueUrl:
    Description: SQS queue for alerts
    Value: !GetAtt AlertQueue.QueueUrl