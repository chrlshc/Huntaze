
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Creator
 * 
 */
export type Creator = $Result.DefaultSelection<Prisma.$CreatorPayload>
/**
 * Model CreatorSettings
 * 
 */
export type CreatorSettings = $Result.DefaultSelection<Prisma.$CreatorSettingsPayload>
/**
 * Model SubscriptionPlan
 * 
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Fan
 * 
 */
export type Fan = $Result.DefaultSelection<Prisma.$FanPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Payout
 * 
 */
export type Payout = $Result.DefaultSelection<Prisma.$PayoutPayload>
/**
 * Model Analytics
 * 
 */
export type Analytics = $Result.DefaultSelection<Prisma.$AnalyticsPayload>
/**
 * Model FanRelation
 * 
 */
export type FanRelation = $Result.DefaultSelection<Prisma.$FanRelationPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignRecipient
 * 
 */
export type CampaignRecipient = $Result.DefaultSelection<Prisma.$CampaignRecipientPayload>
/**
 * Model App
 * 
 */
export type App = $Result.DefaultSelection<Prisma.$AppPayload>
/**
 * Model InstalledApp
 * 
 */
export type InstalledApp = $Result.DefaultSelection<Prisma.$InstalledAppPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model LedgerAccount
 * 
 */
export type LedgerAccount = $Result.DefaultSelection<Prisma.$LedgerAccountPayload>
/**
 * Model LedgerTransaction
 * 
 */
export type LedgerTransaction = $Result.DefaultSelection<Prisma.$LedgerTransactionPayload>
/**
 * Model LedgerEntry
 * 
 */
export type LedgerEntry = $Result.DefaultSelection<Prisma.$LedgerEntryPayload>
/**
 * Model CommissionCapMonthly
 * 
 */
export type CommissionCapMonthly = $Result.DefaultSelection<Prisma.$CommissionCapMonthlyPayload>
/**
 * Model ExternalEarningsSource
 * 
 */
export type ExternalEarningsSource = $Result.DefaultSelection<Prisma.$ExternalEarningsSourcePayload>
/**
 * Model ExternalEarningsImport
 * 
 */
export type ExternalEarningsImport = $Result.DefaultSelection<Prisma.$ExternalEarningsImportPayload>
/**
 * Model NormalizedEarning
 * 
 */
export type NormalizedEarning = $Result.DefaultSelection<Prisma.$NormalizedEarningPayload>
/**
 * Model CommissionStatement
 * 
 */
export type CommissionStatement = $Result.DefaultSelection<Prisma.$CommissionStatementPayload>
/**
 * Model DunningState
 * 
 */
export type DunningState = $Result.DefaultSelection<Prisma.$DunningStatePayload>
/**
 * Model PaymentAttempt
 * 
 */
export type PaymentAttempt = $Result.DefaultSelection<Prisma.$PaymentAttemptPayload>
/**
 * Model Automation
 * 
 */
export type Automation = $Result.DefaultSelection<Prisma.$AutomationPayload>
/**
 * Model BackupLog
 * 
 */
export type BackupLog = $Result.DefaultSelection<Prisma.$BackupLogPayload>
/**
 * Model BackupValidation
 * 
 */
export type BackupValidation = $Result.DefaultSelection<Prisma.$BackupValidationPayload>
/**
 * Model BackupIndex
 * 
 */
export type BackupIndex = $Result.DefaultSelection<Prisma.$BackupIndexPayload>
/**
 * Model AIUsageLog
 * 
 */
export type AIUsageLog = $Result.DefaultSelection<Prisma.$AIUsageLogPayload>
/**
 * Model CostReservation
 * 
 */
export type CostReservation = $Result.DefaultSelection<Prisma.$CostReservationPayload>
/**
 * Model PromptOptimization
 * 
 */
export type PromptOptimization = $Result.DefaultSelection<Prisma.$PromptOptimizationPayload>
/**
 * Model CostAlert
 * 
 */
export type CostAlert = $Result.DefaultSelection<Prisma.$CostAlertPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const KycStatus: {
  PENDING: 'PENDING',
  IN_REVIEW: 'IN_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type KycStatus = (typeof KycStatus)[keyof typeof KycStatus]


export const CommissionTier: {
  STARTER: 'STARTER',
  PRO: 'PRO',
  SCALE: 'SCALE',
  ENTERPRISE: 'ENTERPRISE'
};

export type CommissionTier = (typeof CommissionTier)[keyof typeof CommissionTier]


export const AccountStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  CLOSED: 'CLOSED'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const PayoutFrequency: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  BIWEEKLY: 'BIWEEKLY',
  MONTHLY: 'MONTHLY'
};

export type PayoutFrequency = (typeof PayoutFrequency)[keyof typeof PayoutFrequency]


export const ContentAccess: {
  FREE: 'FREE',
  SUBSCRIPTION: 'SUBSCRIPTION',
  PAY_PER_VIEW: 'PAY_PER_VIEW',
  MIXED: 'MIXED'
};

export type ContentAccess = (typeof ContentAccess)[keyof typeof ContentAccess]


export const BillingInterval: {
  DAY: 'DAY',
  WEEK: 'WEEK',
  MONTH: 'MONTH',
  YEAR: 'YEAR'
};

export type BillingInterval = (typeof BillingInterval)[keyof typeof BillingInterval]


export const ProductType: {
  POST: 'POST',
  VIDEO: 'VIDEO',
  IMAGE_SET: 'IMAGE_SET',
  BUNDLE: 'BUNDLE',
  LIVE_STREAM: 'LIVE_STREAM',
  MESSAGE: 'MESSAGE'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  PAST_DUE: 'PAST_DUE',
  CANCELED: 'CANCELED',
  INCOMPLETE: 'INCOMPLETE',
  TRIALING: 'TRIALING',
  PAUSED: 'PAUSED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const PurchaseStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PurchaseStatus = (typeof PurchaseStatus)[keyof typeof PurchaseStatus]


export const TransactionType: {
  SUBSCRIPTION: 'SUBSCRIPTION',
  PURCHASE: 'PURCHASE',
  TIP: 'TIP',
  REFUND: 'REFUND',
  PAYOUT: 'PAYOUT',
  ADJUSTMENT: 'ADJUSTMENT'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REVERSED: 'REVERSED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const PayoutStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED'
};

export type PayoutStatus = (typeof PayoutStatus)[keyof typeof PayoutStatus]


export const PayoutMethod: {
  BANK_TRANSFER: 'BANK_TRANSFER',
  PAYPAL: 'PAYPAL',
  CRYPTO: 'CRYPTO',
  CHECK: 'CHECK'
};

export type PayoutMethod = (typeof PayoutMethod)[keyof typeof PayoutMethod]


export const CampaignType: {
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  PUSH: 'PUSH',
  IN_APP: 'IN_APP'
};

export type CampaignType = (typeof CampaignType)[keyof typeof CampaignType]


export const CampaignStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  SENDING: 'SENDING',
  SENT: 'SENT',
  CANCELED: 'CANCELED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]


export const RecipientStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  OPENED: 'OPENED',
  CLICKED: 'CLICKED',
  FAILED: 'FAILED'
};

export type RecipientStatus = (typeof RecipientStatus)[keyof typeof RecipientStatus]


export const AppCategory: {
  ANALYTICS: 'ANALYTICS',
  MARKETING: 'MARKETING',
  CONTENT: 'CONTENT',
  FINANCE: 'FINANCE',
  PRODUCTIVITY: 'PRODUCTIVITY',
  SOCIAL: 'SOCIAL',
  AI: 'AI'
};

export type AppCategory = (typeof AppCategory)[keyof typeof AppCategory]


export const AppPricing: {
  FREE: 'FREE',
  FREEMIUM: 'FREEMIUM',
  PAID: 'PAID',
  SUBSCRIPTION: 'SUBSCRIPTION'
};

export type AppPricing = (typeof AppPricing)[keyof typeof AppPricing]


export const AppStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  EXPIRED: 'EXPIRED',
  CANCELED: 'CANCELED'
};

export type AppStatus = (typeof AppStatus)[keyof typeof AppStatus]


export const ActorType: {
  CREATOR: 'CREATOR',
  FAN: 'FAN',
  ADMIN: 'ADMIN',
  SYSTEM: 'SYSTEM',
  APP: 'APP'
};

export type ActorType = (typeof ActorType)[keyof typeof ActorType]


export const LedgerAccountType: {
  CASH_PLATFORM_STRIPE: 'CASH_PLATFORM_STRIPE',
  PLATFORM_REV_COMMISSION: 'PLATFORM_REV_COMMISSION',
  AR_COMMISSION: 'AR_COMMISSION',
  ALLOWANCE_DOUBTFUL: 'ALLOWANCE_DOUBTFUL',
  TAX_PAYABLE: 'TAX_PAYABLE',
  CREATOR_BALANCE: 'CREATOR_BALANCE',
  DISPUTE_LIABILITY: 'DISPUTE_LIABILITY'
};

export type LedgerAccountType = (typeof LedgerAccountType)[keyof typeof LedgerAccountType]


export const LedgerTransactionKind: {
  CHARGE: 'CHARGE',
  APP_FEE: 'APP_FEE',
  REFUND: 'REFUND',
  DISPUTE_DEBIT: 'DISPUTE_DEBIT',
  DISPUTE_REVERSAL: 'DISPUTE_REVERSAL',
  PAYOUT: 'PAYOUT',
  CAP_ADJUST: 'CAP_ADJUST',
  SUBSCRIPTION: 'SUBSCRIPTION',
  TAX: 'TAX',
  OFFPLAT_EARNINGS_ACCRUAL: 'OFFPLAT_EARNINGS_ACCRUAL',
  OFFPLAT_COMM_ACCRUAL: 'OFFPLAT_COMM_ACCRUAL',
  AR_SETTLEMENT: 'AR_SETTLEMENT',
  AR_WRITE_OFF: 'AR_WRITE_OFF'
};

export type LedgerTransactionKind = (typeof LedgerTransactionKind)[keyof typeof LedgerTransactionKind]


export const LedgerDirection: {
  DEBIT: 'DEBIT',
  CREDIT: 'CREDIT'
};

export type LedgerDirection = (typeof LedgerDirection)[keyof typeof LedgerDirection]


export const ExternalPlatform: {
  OF: 'OF',
  PATREON: 'PATREON',
  FANSLY: 'FANSLY',
  SUBSTACK: 'SUBSTACK',
  KO_FI: 'KO_FI',
  OTHER: 'OTHER'
};

export type ExternalPlatform = (typeof ExternalPlatform)[keyof typeof ExternalPlatform]


export const DunningStatus: {
  ACTIVE: 'ACTIVE',
  RECOVERED: 'RECOVERED',
  WRITTEN_OFF: 'WRITTEN_OFF',
  SUSPENDED: 'SUSPENDED'
};

export type DunningStatus = (typeof DunningStatus)[keyof typeof DunningStatus]


export const AutomationTrigger: {
  FAN_JOINED: 'FAN_JOINED',
  SUBSCRIPTION_STARTED: 'SUBSCRIPTION_STARTED',
  SUBSCRIPTION_ENDED: 'SUBSCRIPTION_ENDED',
  PURCHASE_MADE: 'PURCHASE_MADE',
  TAG_ADDED: 'TAG_ADDED',
  INACTIVITY: 'INACTIVITY',
  CUSTOM: 'CUSTOM'
};

export type AutomationTrigger = (typeof AutomationTrigger)[keyof typeof AutomationTrigger]


export const AutomationStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  DISABLED: 'DISABLED'
};

export type AutomationStatus = (typeof AutomationStatus)[keyof typeof AutomationStatus]

}

export type KycStatus = $Enums.KycStatus

export const KycStatus: typeof $Enums.KycStatus

export type CommissionTier = $Enums.CommissionTier

export const CommissionTier: typeof $Enums.CommissionTier

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type PayoutFrequency = $Enums.PayoutFrequency

export const PayoutFrequency: typeof $Enums.PayoutFrequency

export type ContentAccess = $Enums.ContentAccess

export const ContentAccess: typeof $Enums.ContentAccess

export type BillingInterval = $Enums.BillingInterval

export const BillingInterval: typeof $Enums.BillingInterval

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type PurchaseStatus = $Enums.PurchaseStatus

export const PurchaseStatus: typeof $Enums.PurchaseStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type PayoutStatus = $Enums.PayoutStatus

export const PayoutStatus: typeof $Enums.PayoutStatus

export type PayoutMethod = $Enums.PayoutMethod

export const PayoutMethod: typeof $Enums.PayoutMethod

export type CampaignType = $Enums.CampaignType

export const CampaignType: typeof $Enums.CampaignType

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

export type RecipientStatus = $Enums.RecipientStatus

export const RecipientStatus: typeof $Enums.RecipientStatus

export type AppCategory = $Enums.AppCategory

export const AppCategory: typeof $Enums.AppCategory

export type AppPricing = $Enums.AppPricing

export const AppPricing: typeof $Enums.AppPricing

export type AppStatus = $Enums.AppStatus

export const AppStatus: typeof $Enums.AppStatus

export type ActorType = $Enums.ActorType

export const ActorType: typeof $Enums.ActorType

export type LedgerAccountType = $Enums.LedgerAccountType

export const LedgerAccountType: typeof $Enums.LedgerAccountType

export type LedgerTransactionKind = $Enums.LedgerTransactionKind

export const LedgerTransactionKind: typeof $Enums.LedgerTransactionKind

export type LedgerDirection = $Enums.LedgerDirection

export const LedgerDirection: typeof $Enums.LedgerDirection

export type ExternalPlatform = $Enums.ExternalPlatform

export const ExternalPlatform: typeof $Enums.ExternalPlatform

export type DunningStatus = $Enums.DunningStatus

export const DunningStatus: typeof $Enums.DunningStatus

export type AutomationTrigger = $Enums.AutomationTrigger

export const AutomationTrigger: typeof $Enums.AutomationTrigger

export type AutomationStatus = $Enums.AutomationStatus

export const AutomationStatus: typeof $Enums.AutomationStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Creators
 * const creators = await prisma.creator.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Creators
   * const creators = await prisma.creator.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.creator`: Exposes CRUD operations for the **Creator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creators
    * const creators = await prisma.creator.findMany()
    * ```
    */
  get creator(): Prisma.CreatorDelegate<ExtArgs>;

  /**
   * `prisma.creatorSettings`: Exposes CRUD operations for the **CreatorSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatorSettings
    * const creatorSettings = await prisma.creatorSettings.findMany()
    * ```
    */
  get creatorSettings(): Prisma.CreatorSettingsDelegate<ExtArgs>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.fan`: Exposes CRUD operations for the **Fan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fans
    * const fans = await prisma.fan.findMany()
    * ```
    */
  get fan(): Prisma.FanDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.payout`: Exposes CRUD operations for the **Payout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payouts
    * const payouts = await prisma.payout.findMany()
    * ```
    */
  get payout(): Prisma.PayoutDelegate<ExtArgs>;

  /**
   * `prisma.analytics`: Exposes CRUD operations for the **Analytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analytics
    * const analytics = await prisma.analytics.findMany()
    * ```
    */
  get analytics(): Prisma.AnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.fanRelation`: Exposes CRUD operations for the **FanRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FanRelations
    * const fanRelations = await prisma.fanRelation.findMany()
    * ```
    */
  get fanRelation(): Prisma.FanRelationDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.campaignRecipient`: Exposes CRUD operations for the **CampaignRecipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignRecipients
    * const campaignRecipients = await prisma.campaignRecipient.findMany()
    * ```
    */
  get campaignRecipient(): Prisma.CampaignRecipientDelegate<ExtArgs>;

  /**
   * `prisma.app`: Exposes CRUD operations for the **App** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apps
    * const apps = await prisma.app.findMany()
    * ```
    */
  get app(): Prisma.AppDelegate<ExtArgs>;

  /**
   * `prisma.installedApp`: Exposes CRUD operations for the **InstalledApp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstalledApps
    * const installedApps = await prisma.installedApp.findMany()
    * ```
    */
  get installedApp(): Prisma.InstalledAppDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.ledgerAccount`: Exposes CRUD operations for the **LedgerAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LedgerAccounts
    * const ledgerAccounts = await prisma.ledgerAccount.findMany()
    * ```
    */
  get ledgerAccount(): Prisma.LedgerAccountDelegate<ExtArgs>;

  /**
   * `prisma.ledgerTransaction`: Exposes CRUD operations for the **LedgerTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LedgerTransactions
    * const ledgerTransactions = await prisma.ledgerTransaction.findMany()
    * ```
    */
  get ledgerTransaction(): Prisma.LedgerTransactionDelegate<ExtArgs>;

  /**
   * `prisma.ledgerEntry`: Exposes CRUD operations for the **LedgerEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LedgerEntries
    * const ledgerEntries = await prisma.ledgerEntry.findMany()
    * ```
    */
  get ledgerEntry(): Prisma.LedgerEntryDelegate<ExtArgs>;

  /**
   * `prisma.commissionCapMonthly`: Exposes CRUD operations for the **CommissionCapMonthly** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommissionCapMonthlies
    * const commissionCapMonthlies = await prisma.commissionCapMonthly.findMany()
    * ```
    */
  get commissionCapMonthly(): Prisma.CommissionCapMonthlyDelegate<ExtArgs>;

  /**
   * `prisma.externalEarningsSource`: Exposes CRUD operations for the **ExternalEarningsSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalEarningsSources
    * const externalEarningsSources = await prisma.externalEarningsSource.findMany()
    * ```
    */
  get externalEarningsSource(): Prisma.ExternalEarningsSourceDelegate<ExtArgs>;

  /**
   * `prisma.externalEarningsImport`: Exposes CRUD operations for the **ExternalEarningsImport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalEarningsImports
    * const externalEarningsImports = await prisma.externalEarningsImport.findMany()
    * ```
    */
  get externalEarningsImport(): Prisma.ExternalEarningsImportDelegate<ExtArgs>;

  /**
   * `prisma.normalizedEarning`: Exposes CRUD operations for the **NormalizedEarning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NormalizedEarnings
    * const normalizedEarnings = await prisma.normalizedEarning.findMany()
    * ```
    */
  get normalizedEarning(): Prisma.NormalizedEarningDelegate<ExtArgs>;

  /**
   * `prisma.commissionStatement`: Exposes CRUD operations for the **CommissionStatement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommissionStatements
    * const commissionStatements = await prisma.commissionStatement.findMany()
    * ```
    */
  get commissionStatement(): Prisma.CommissionStatementDelegate<ExtArgs>;

  /**
   * `prisma.dunningState`: Exposes CRUD operations for the **DunningState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DunningStates
    * const dunningStates = await prisma.dunningState.findMany()
    * ```
    */
  get dunningState(): Prisma.DunningStateDelegate<ExtArgs>;

  /**
   * `prisma.paymentAttempt`: Exposes CRUD operations for the **PaymentAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentAttempts
    * const paymentAttempts = await prisma.paymentAttempt.findMany()
    * ```
    */
  get paymentAttempt(): Prisma.PaymentAttemptDelegate<ExtArgs>;

  /**
   * `prisma.automation`: Exposes CRUD operations for the **Automation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Automations
    * const automations = await prisma.automation.findMany()
    * ```
    */
  get automation(): Prisma.AutomationDelegate<ExtArgs>;

  /**
   * `prisma.backupLog`: Exposes CRUD operations for the **BackupLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BackupLogs
    * const backupLogs = await prisma.backupLog.findMany()
    * ```
    */
  get backupLog(): Prisma.BackupLogDelegate<ExtArgs>;

  /**
   * `prisma.backupValidation`: Exposes CRUD operations for the **BackupValidation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BackupValidations
    * const backupValidations = await prisma.backupValidation.findMany()
    * ```
    */
  get backupValidation(): Prisma.BackupValidationDelegate<ExtArgs>;

  /**
   * `prisma.backupIndex`: Exposes CRUD operations for the **BackupIndex** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BackupIndices
    * const backupIndices = await prisma.backupIndex.findMany()
    * ```
    */
  get backupIndex(): Prisma.BackupIndexDelegate<ExtArgs>;

  /**
   * `prisma.aIUsageLog`: Exposes CRUD operations for the **AIUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIUsageLogs
    * const aIUsageLogs = await prisma.aIUsageLog.findMany()
    * ```
    */
  get aIUsageLog(): Prisma.AIUsageLogDelegate<ExtArgs>;

  /**
   * `prisma.costReservation`: Exposes CRUD operations for the **CostReservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostReservations
    * const costReservations = await prisma.costReservation.findMany()
    * ```
    */
  get costReservation(): Prisma.CostReservationDelegate<ExtArgs>;

  /**
   * `prisma.promptOptimization`: Exposes CRUD operations for the **PromptOptimization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromptOptimizations
    * const promptOptimizations = await prisma.promptOptimization.findMany()
    * ```
    */
  get promptOptimization(): Prisma.PromptOptimizationDelegate<ExtArgs>;

  /**
   * `prisma.costAlert`: Exposes CRUD operations for the **CostAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostAlerts
    * const costAlerts = await prisma.costAlert.findMany()
    * ```
    */
  get costAlert(): Prisma.CostAlertDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Creator: 'Creator',
    CreatorSettings: 'CreatorSettings',
    SubscriptionPlan: 'SubscriptionPlan',
    Product: 'Product',
    Fan: 'Fan',
    Subscription: 'Subscription',
    Purchase: 'Purchase',
    Transaction: 'Transaction',
    Payout: 'Payout',
    Analytics: 'Analytics',
    FanRelation: 'FanRelation',
    Campaign: 'Campaign',
    CampaignRecipient: 'CampaignRecipient',
    App: 'App',
    InstalledApp: 'InstalledApp',
    AuditLog: 'AuditLog',
    LedgerAccount: 'LedgerAccount',
    LedgerTransaction: 'LedgerTransaction',
    LedgerEntry: 'LedgerEntry',
    CommissionCapMonthly: 'CommissionCapMonthly',
    ExternalEarningsSource: 'ExternalEarningsSource',
    ExternalEarningsImport: 'ExternalEarningsImport',
    NormalizedEarning: 'NormalizedEarning',
    CommissionStatement: 'CommissionStatement',
    DunningState: 'DunningState',
    PaymentAttempt: 'PaymentAttempt',
    Automation: 'Automation',
    BackupLog: 'BackupLog',
    BackupValidation: 'BackupValidation',
    BackupIndex: 'BackupIndex',
    AIUsageLog: 'AIUsageLog',
    CostReservation: 'CostReservation',
    PromptOptimization: 'PromptOptimization',
    CostAlert: 'CostAlert'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "creator" | "creatorSettings" | "subscriptionPlan" | "product" | "fan" | "subscription" | "purchase" | "transaction" | "payout" | "analytics" | "fanRelation" | "campaign" | "campaignRecipient" | "app" | "installedApp" | "auditLog" | "ledgerAccount" | "ledgerTransaction" | "ledgerEntry" | "commissionCapMonthly" | "externalEarningsSource" | "externalEarningsImport" | "normalizedEarning" | "commissionStatement" | "dunningState" | "paymentAttempt" | "automation" | "backupLog" | "backupValidation" | "backupIndex" | "aIUsageLog" | "costReservation" | "promptOptimization" | "costAlert"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Creator: {
        payload: Prisma.$CreatorPayload<ExtArgs>
        fields: Prisma.CreatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          findFirst: {
            args: Prisma.CreatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          findMany: {
            args: Prisma.CreatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>[]
          }
          create: {
            args: Prisma.CreatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          createMany: {
            args: Prisma.CreatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>[]
          }
          delete: {
            args: Prisma.CreatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          update: {
            args: Prisma.CreatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          deleteMany: {
            args: Prisma.CreatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          aggregate: {
            args: Prisma.CreatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreator>
          }
          groupBy: {
            args: Prisma.CreatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatorCountArgs<ExtArgs>
            result: $Utils.Optional<CreatorCountAggregateOutputType> | number
          }
        }
      }
      CreatorSettings: {
        payload: Prisma.$CreatorSettingsPayload<ExtArgs>
        fields: Prisma.CreatorSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatorSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatorSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorSettingsPayload>
          }
          findFirst: {
            args: Prisma.CreatorSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatorSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorSettingsPayload>
          }
          findMany: {
            args: Prisma.CreatorSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorSettingsPayload>[]
          }
          create: {
            args: Prisma.CreatorSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorSettingsPayload>
          }
          createMany: {
            args: Prisma.CreatorSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatorSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorSettingsPayload>[]
          }
          delete: {
            args: Prisma.CreatorSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorSettingsPayload>
          }
          update: {
            args: Prisma.CreatorSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorSettingsPayload>
          }
          deleteMany: {
            args: Prisma.CreatorSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatorSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreatorSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorSettingsPayload>
          }
          aggregate: {
            args: Prisma.CreatorSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatorSettings>
          }
          groupBy: {
            args: Prisma.CreatorSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatorSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatorSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<CreatorSettingsCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Fan: {
        payload: Prisma.$FanPayload<ExtArgs>
        fields: Prisma.FanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanPayload>
          }
          findFirst: {
            args: Prisma.FanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanPayload>
          }
          findMany: {
            args: Prisma.FanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanPayload>[]
          }
          create: {
            args: Prisma.FanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanPayload>
          }
          createMany: {
            args: Prisma.FanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanPayload>[]
          }
          delete: {
            args: Prisma.FanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanPayload>
          }
          update: {
            args: Prisma.FanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanPayload>
          }
          deleteMany: {
            args: Prisma.FanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanPayload>
          }
          aggregate: {
            args: Prisma.FanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFan>
          }
          groupBy: {
            args: Prisma.FanGroupByArgs<ExtArgs>
            result: $Utils.Optional<FanGroupByOutputType>[]
          }
          count: {
            args: Prisma.FanCountArgs<ExtArgs>
            result: $Utils.Optional<FanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Payout: {
        payload: Prisma.$PayoutPayload<ExtArgs>
        fields: Prisma.PayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          findFirst: {
            args: Prisma.PayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          findMany: {
            args: Prisma.PayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>[]
          }
          create: {
            args: Prisma.PayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          createMany: {
            args: Prisma.PayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>[]
          }
          delete: {
            args: Prisma.PayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          update: {
            args: Prisma.PayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          deleteMany: {
            args: Prisma.PayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          aggregate: {
            args: Prisma.PayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayout>
          }
          groupBy: {
            args: Prisma.PayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayoutCountArgs<ExtArgs>
            result: $Utils.Optional<PayoutCountAggregateOutputType> | number
          }
        }
      }
      Analytics: {
        payload: Prisma.$AnalyticsPayload<ExtArgs>
        fields: Prisma.AnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findMany: {
            args: Prisma.AnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          create: {
            args: Prisma.AnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          createMany: {
            args: Prisma.AnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          update: {
            args: Prisma.AnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalytics>
          }
          groupBy: {
            args: Prisma.AnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsCountAggregateOutputType> | number
          }
        }
      }
      FanRelation: {
        payload: Prisma.$FanRelationPayload<ExtArgs>
        fields: Prisma.FanRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FanRelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FanRelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanRelationPayload>
          }
          findFirst: {
            args: Prisma.FanRelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FanRelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanRelationPayload>
          }
          findMany: {
            args: Prisma.FanRelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanRelationPayload>[]
          }
          create: {
            args: Prisma.FanRelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanRelationPayload>
          }
          createMany: {
            args: Prisma.FanRelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FanRelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanRelationPayload>[]
          }
          delete: {
            args: Prisma.FanRelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanRelationPayload>
          }
          update: {
            args: Prisma.FanRelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanRelationPayload>
          }
          deleteMany: {
            args: Prisma.FanRelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FanRelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FanRelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanRelationPayload>
          }
          aggregate: {
            args: Prisma.FanRelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFanRelation>
          }
          groupBy: {
            args: Prisma.FanRelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FanRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FanRelationCountArgs<ExtArgs>
            result: $Utils.Optional<FanRelationCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignRecipient: {
        payload: Prisma.$CampaignRecipientPayload<ExtArgs>
        fields: Prisma.CampaignRecipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignRecipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignRecipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          findFirst: {
            args: Prisma.CampaignRecipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignRecipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          findMany: {
            args: Prisma.CampaignRecipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>[]
          }
          create: {
            args: Prisma.CampaignRecipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          createMany: {
            args: Prisma.CampaignRecipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignRecipientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>[]
          }
          delete: {
            args: Prisma.CampaignRecipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          update: {
            args: Prisma.CampaignRecipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          deleteMany: {
            args: Prisma.CampaignRecipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignRecipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignRecipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          aggregate: {
            args: Prisma.CampaignRecipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignRecipient>
          }
          groupBy: {
            args: Prisma.CampaignRecipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignRecipientGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignRecipientCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignRecipientCountAggregateOutputType> | number
          }
        }
      }
      App: {
        payload: Prisma.$AppPayload<ExtArgs>
        fields: Prisma.AppFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          findFirst: {
            args: Prisma.AppFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          findMany: {
            args: Prisma.AppFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>[]
          }
          create: {
            args: Prisma.AppCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          createMany: {
            args: Prisma.AppCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>[]
          }
          delete: {
            args: Prisma.AppDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          update: {
            args: Prisma.AppUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          deleteMany: {
            args: Prisma.AppDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          aggregate: {
            args: Prisma.AppAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp>
          }
          groupBy: {
            args: Prisma.AppGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppCountArgs<ExtArgs>
            result: $Utils.Optional<AppCountAggregateOutputType> | number
          }
        }
      }
      InstalledApp: {
        payload: Prisma.$InstalledAppPayload<ExtArgs>
        fields: Prisma.InstalledAppFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstalledAppFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledAppPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstalledAppFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledAppPayload>
          }
          findFirst: {
            args: Prisma.InstalledAppFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledAppPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstalledAppFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledAppPayload>
          }
          findMany: {
            args: Prisma.InstalledAppFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledAppPayload>[]
          }
          create: {
            args: Prisma.InstalledAppCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledAppPayload>
          }
          createMany: {
            args: Prisma.InstalledAppCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstalledAppCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledAppPayload>[]
          }
          delete: {
            args: Prisma.InstalledAppDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledAppPayload>
          }
          update: {
            args: Prisma.InstalledAppUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledAppPayload>
          }
          deleteMany: {
            args: Prisma.InstalledAppDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstalledAppUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstalledAppUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledAppPayload>
          }
          aggregate: {
            args: Prisma.InstalledAppAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstalledApp>
          }
          groupBy: {
            args: Prisma.InstalledAppGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstalledAppGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstalledAppCountArgs<ExtArgs>
            result: $Utils.Optional<InstalledAppCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      LedgerAccount: {
        payload: Prisma.$LedgerAccountPayload<ExtArgs>
        fields: Prisma.LedgerAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerAccountPayload>
          }
          findFirst: {
            args: Prisma.LedgerAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerAccountPayload>
          }
          findMany: {
            args: Prisma.LedgerAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerAccountPayload>[]
          }
          create: {
            args: Prisma.LedgerAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerAccountPayload>
          }
          createMany: {
            args: Prisma.LedgerAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerAccountPayload>[]
          }
          delete: {
            args: Prisma.LedgerAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerAccountPayload>
          }
          update: {
            args: Prisma.LedgerAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerAccountPayload>
          }
          deleteMany: {
            args: Prisma.LedgerAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LedgerAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerAccountPayload>
          }
          aggregate: {
            args: Prisma.LedgerAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedgerAccount>
          }
          groupBy: {
            args: Prisma.LedgerAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerAccountCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerAccountCountAggregateOutputType> | number
          }
        }
      }
      LedgerTransaction: {
        payload: Prisma.$LedgerTransactionPayload<ExtArgs>
        fields: Prisma.LedgerTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          findFirst: {
            args: Prisma.LedgerTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          findMany: {
            args: Prisma.LedgerTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>[]
          }
          create: {
            args: Prisma.LedgerTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          createMany: {
            args: Prisma.LedgerTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>[]
          }
          delete: {
            args: Prisma.LedgerTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          update: {
            args: Prisma.LedgerTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          deleteMany: {
            args: Prisma.LedgerTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LedgerTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          aggregate: {
            args: Prisma.LedgerTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedgerTransaction>
          }
          groupBy: {
            args: Prisma.LedgerTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerTransactionCountAggregateOutputType> | number
          }
        }
      }
      LedgerEntry: {
        payload: Prisma.$LedgerEntryPayload<ExtArgs>
        fields: Prisma.LedgerEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findFirst: {
            args: Prisma.LedgerEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findMany: {
            args: Prisma.LedgerEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          create: {
            args: Prisma.LedgerEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          createMany: {
            args: Prisma.LedgerEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          delete: {
            args: Prisma.LedgerEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          update: {
            args: Prisma.LedgerEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          deleteMany: {
            args: Prisma.LedgerEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LedgerEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          aggregate: {
            args: Prisma.LedgerEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedgerEntry>
          }
          groupBy: {
            args: Prisma.LedgerEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryCountAggregateOutputType> | number
          }
        }
      }
      CommissionCapMonthly: {
        payload: Prisma.$CommissionCapMonthlyPayload<ExtArgs>
        fields: Prisma.CommissionCapMonthlyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommissionCapMonthlyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionCapMonthlyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommissionCapMonthlyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionCapMonthlyPayload>
          }
          findFirst: {
            args: Prisma.CommissionCapMonthlyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionCapMonthlyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommissionCapMonthlyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionCapMonthlyPayload>
          }
          findMany: {
            args: Prisma.CommissionCapMonthlyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionCapMonthlyPayload>[]
          }
          create: {
            args: Prisma.CommissionCapMonthlyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionCapMonthlyPayload>
          }
          createMany: {
            args: Prisma.CommissionCapMonthlyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommissionCapMonthlyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionCapMonthlyPayload>[]
          }
          delete: {
            args: Prisma.CommissionCapMonthlyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionCapMonthlyPayload>
          }
          update: {
            args: Prisma.CommissionCapMonthlyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionCapMonthlyPayload>
          }
          deleteMany: {
            args: Prisma.CommissionCapMonthlyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommissionCapMonthlyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommissionCapMonthlyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionCapMonthlyPayload>
          }
          aggregate: {
            args: Prisma.CommissionCapMonthlyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommissionCapMonthly>
          }
          groupBy: {
            args: Prisma.CommissionCapMonthlyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommissionCapMonthlyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommissionCapMonthlyCountArgs<ExtArgs>
            result: $Utils.Optional<CommissionCapMonthlyCountAggregateOutputType> | number
          }
        }
      }
      ExternalEarningsSource: {
        payload: Prisma.$ExternalEarningsSourcePayload<ExtArgs>
        fields: Prisma.ExternalEarningsSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalEarningsSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalEarningsSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsSourcePayload>
          }
          findFirst: {
            args: Prisma.ExternalEarningsSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalEarningsSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsSourcePayload>
          }
          findMany: {
            args: Prisma.ExternalEarningsSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsSourcePayload>[]
          }
          create: {
            args: Prisma.ExternalEarningsSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsSourcePayload>
          }
          createMany: {
            args: Prisma.ExternalEarningsSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExternalEarningsSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsSourcePayload>[]
          }
          delete: {
            args: Prisma.ExternalEarningsSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsSourcePayload>
          }
          update: {
            args: Prisma.ExternalEarningsSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsSourcePayload>
          }
          deleteMany: {
            args: Prisma.ExternalEarningsSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalEarningsSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExternalEarningsSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsSourcePayload>
          }
          aggregate: {
            args: Prisma.ExternalEarningsSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalEarningsSource>
          }
          groupBy: {
            args: Prisma.ExternalEarningsSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalEarningsSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalEarningsSourceCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalEarningsSourceCountAggregateOutputType> | number
          }
        }
      }
      ExternalEarningsImport: {
        payload: Prisma.$ExternalEarningsImportPayload<ExtArgs>
        fields: Prisma.ExternalEarningsImportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalEarningsImportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsImportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalEarningsImportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsImportPayload>
          }
          findFirst: {
            args: Prisma.ExternalEarningsImportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsImportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalEarningsImportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsImportPayload>
          }
          findMany: {
            args: Prisma.ExternalEarningsImportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsImportPayload>[]
          }
          create: {
            args: Prisma.ExternalEarningsImportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsImportPayload>
          }
          createMany: {
            args: Prisma.ExternalEarningsImportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExternalEarningsImportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsImportPayload>[]
          }
          delete: {
            args: Prisma.ExternalEarningsImportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsImportPayload>
          }
          update: {
            args: Prisma.ExternalEarningsImportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsImportPayload>
          }
          deleteMany: {
            args: Prisma.ExternalEarningsImportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalEarningsImportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExternalEarningsImportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalEarningsImportPayload>
          }
          aggregate: {
            args: Prisma.ExternalEarningsImportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalEarningsImport>
          }
          groupBy: {
            args: Prisma.ExternalEarningsImportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalEarningsImportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalEarningsImportCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalEarningsImportCountAggregateOutputType> | number
          }
        }
      }
      NormalizedEarning: {
        payload: Prisma.$NormalizedEarningPayload<ExtArgs>
        fields: Prisma.NormalizedEarningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NormalizedEarningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NormalizedEarningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NormalizedEarningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NormalizedEarningPayload>
          }
          findFirst: {
            args: Prisma.NormalizedEarningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NormalizedEarningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NormalizedEarningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NormalizedEarningPayload>
          }
          findMany: {
            args: Prisma.NormalizedEarningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NormalizedEarningPayload>[]
          }
          create: {
            args: Prisma.NormalizedEarningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NormalizedEarningPayload>
          }
          createMany: {
            args: Prisma.NormalizedEarningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NormalizedEarningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NormalizedEarningPayload>[]
          }
          delete: {
            args: Prisma.NormalizedEarningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NormalizedEarningPayload>
          }
          update: {
            args: Prisma.NormalizedEarningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NormalizedEarningPayload>
          }
          deleteMany: {
            args: Prisma.NormalizedEarningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NormalizedEarningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NormalizedEarningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NormalizedEarningPayload>
          }
          aggregate: {
            args: Prisma.NormalizedEarningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNormalizedEarning>
          }
          groupBy: {
            args: Prisma.NormalizedEarningGroupByArgs<ExtArgs>
            result: $Utils.Optional<NormalizedEarningGroupByOutputType>[]
          }
          count: {
            args: Prisma.NormalizedEarningCountArgs<ExtArgs>
            result: $Utils.Optional<NormalizedEarningCountAggregateOutputType> | number
          }
        }
      }
      CommissionStatement: {
        payload: Prisma.$CommissionStatementPayload<ExtArgs>
        fields: Prisma.CommissionStatementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommissionStatementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionStatementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommissionStatementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionStatementPayload>
          }
          findFirst: {
            args: Prisma.CommissionStatementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionStatementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommissionStatementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionStatementPayload>
          }
          findMany: {
            args: Prisma.CommissionStatementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionStatementPayload>[]
          }
          create: {
            args: Prisma.CommissionStatementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionStatementPayload>
          }
          createMany: {
            args: Prisma.CommissionStatementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommissionStatementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionStatementPayload>[]
          }
          delete: {
            args: Prisma.CommissionStatementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionStatementPayload>
          }
          update: {
            args: Prisma.CommissionStatementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionStatementPayload>
          }
          deleteMany: {
            args: Prisma.CommissionStatementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommissionStatementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommissionStatementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionStatementPayload>
          }
          aggregate: {
            args: Prisma.CommissionStatementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommissionStatement>
          }
          groupBy: {
            args: Prisma.CommissionStatementGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommissionStatementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommissionStatementCountArgs<ExtArgs>
            result: $Utils.Optional<CommissionStatementCountAggregateOutputType> | number
          }
        }
      }
      DunningState: {
        payload: Prisma.$DunningStatePayload<ExtArgs>
        fields: Prisma.DunningStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DunningStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DunningStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DunningStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DunningStatePayload>
          }
          findFirst: {
            args: Prisma.DunningStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DunningStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DunningStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DunningStatePayload>
          }
          findMany: {
            args: Prisma.DunningStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DunningStatePayload>[]
          }
          create: {
            args: Prisma.DunningStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DunningStatePayload>
          }
          createMany: {
            args: Prisma.DunningStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DunningStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DunningStatePayload>[]
          }
          delete: {
            args: Prisma.DunningStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DunningStatePayload>
          }
          update: {
            args: Prisma.DunningStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DunningStatePayload>
          }
          deleteMany: {
            args: Prisma.DunningStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DunningStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DunningStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DunningStatePayload>
          }
          aggregate: {
            args: Prisma.DunningStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDunningState>
          }
          groupBy: {
            args: Prisma.DunningStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<DunningStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.DunningStateCountArgs<ExtArgs>
            result: $Utils.Optional<DunningStateCountAggregateOutputType> | number
          }
        }
      }
      PaymentAttempt: {
        payload: Prisma.$PaymentAttemptPayload<ExtArgs>
        fields: Prisma.PaymentAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAttemptPayload>
          }
          findFirst: {
            args: Prisma.PaymentAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAttemptPayload>
          }
          findMany: {
            args: Prisma.PaymentAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAttemptPayload>[]
          }
          create: {
            args: Prisma.PaymentAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAttemptPayload>
          }
          createMany: {
            args: Prisma.PaymentAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAttemptPayload>[]
          }
          delete: {
            args: Prisma.PaymentAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAttemptPayload>
          }
          update: {
            args: Prisma.PaymentAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAttemptPayload>
          }
          deleteMany: {
            args: Prisma.PaymentAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAttemptPayload>
          }
          aggregate: {
            args: Prisma.PaymentAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentAttempt>
          }
          groupBy: {
            args: Prisma.PaymentAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentAttemptCountAggregateOutputType> | number
          }
        }
      }
      Automation: {
        payload: Prisma.$AutomationPayload<ExtArgs>
        fields: Prisma.AutomationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findFirst: {
            args: Prisma.AutomationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findMany: {
            args: Prisma.AutomationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          create: {
            args: Prisma.AutomationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          createMany: {
            args: Prisma.AutomationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          delete: {
            args: Prisma.AutomationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          update: {
            args: Prisma.AutomationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          deleteMany: {
            args: Prisma.AutomationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          aggregate: {
            args: Prisma.AutomationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomation>
          }
          groupBy: {
            args: Prisma.AutomationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationCountAggregateOutputType> | number
          }
        }
      }
      BackupLog: {
        payload: Prisma.$BackupLogPayload<ExtArgs>
        fields: Prisma.BackupLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackupLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackupLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          findFirst: {
            args: Prisma.BackupLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackupLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          findMany: {
            args: Prisma.BackupLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>[]
          }
          create: {
            args: Prisma.BackupLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          createMany: {
            args: Prisma.BackupLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BackupLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>[]
          }
          delete: {
            args: Prisma.BackupLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          update: {
            args: Prisma.BackupLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          deleteMany: {
            args: Prisma.BackupLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackupLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BackupLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          aggregate: {
            args: Prisma.BackupLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackupLog>
          }
          groupBy: {
            args: Prisma.BackupLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackupLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackupLogCountArgs<ExtArgs>
            result: $Utils.Optional<BackupLogCountAggregateOutputType> | number
          }
        }
      }
      BackupValidation: {
        payload: Prisma.$BackupValidationPayload<ExtArgs>
        fields: Prisma.BackupValidationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackupValidationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupValidationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackupValidationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupValidationPayload>
          }
          findFirst: {
            args: Prisma.BackupValidationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupValidationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackupValidationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupValidationPayload>
          }
          findMany: {
            args: Prisma.BackupValidationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupValidationPayload>[]
          }
          create: {
            args: Prisma.BackupValidationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupValidationPayload>
          }
          createMany: {
            args: Prisma.BackupValidationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BackupValidationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupValidationPayload>[]
          }
          delete: {
            args: Prisma.BackupValidationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupValidationPayload>
          }
          update: {
            args: Prisma.BackupValidationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupValidationPayload>
          }
          deleteMany: {
            args: Prisma.BackupValidationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackupValidationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BackupValidationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupValidationPayload>
          }
          aggregate: {
            args: Prisma.BackupValidationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackupValidation>
          }
          groupBy: {
            args: Prisma.BackupValidationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackupValidationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackupValidationCountArgs<ExtArgs>
            result: $Utils.Optional<BackupValidationCountAggregateOutputType> | number
          }
        }
      }
      BackupIndex: {
        payload: Prisma.$BackupIndexPayload<ExtArgs>
        fields: Prisma.BackupIndexFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackupIndexFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupIndexPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackupIndexFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupIndexPayload>
          }
          findFirst: {
            args: Prisma.BackupIndexFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupIndexPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackupIndexFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupIndexPayload>
          }
          findMany: {
            args: Prisma.BackupIndexFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupIndexPayload>[]
          }
          create: {
            args: Prisma.BackupIndexCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupIndexPayload>
          }
          createMany: {
            args: Prisma.BackupIndexCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BackupIndexCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupIndexPayload>[]
          }
          delete: {
            args: Prisma.BackupIndexDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupIndexPayload>
          }
          update: {
            args: Prisma.BackupIndexUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupIndexPayload>
          }
          deleteMany: {
            args: Prisma.BackupIndexDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackupIndexUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BackupIndexUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupIndexPayload>
          }
          aggregate: {
            args: Prisma.BackupIndexAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackupIndex>
          }
          groupBy: {
            args: Prisma.BackupIndexGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackupIndexGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackupIndexCountArgs<ExtArgs>
            result: $Utils.Optional<BackupIndexCountAggregateOutputType> | number
          }
        }
      }
      AIUsageLog: {
        payload: Prisma.$AIUsageLogPayload<ExtArgs>
        fields: Prisma.AIUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          findFirst: {
            args: Prisma.AIUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          findMany: {
            args: Prisma.AIUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>[]
          }
          create: {
            args: Prisma.AIUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          createMany: {
            args: Prisma.AIUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>[]
          }
          delete: {
            args: Prisma.AIUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          update: {
            args: Prisma.AIUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.AIUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          aggregate: {
            args: Prisma.AIUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIUsageLog>
          }
          groupBy: {
            args: Prisma.AIUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<AIUsageLogCountAggregateOutputType> | number
          }
        }
      }
      CostReservation: {
        payload: Prisma.$CostReservationPayload<ExtArgs>
        fields: Prisma.CostReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostReservationPayload>
          }
          findFirst: {
            args: Prisma.CostReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostReservationPayload>
          }
          findMany: {
            args: Prisma.CostReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostReservationPayload>[]
          }
          create: {
            args: Prisma.CostReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostReservationPayload>
          }
          createMany: {
            args: Prisma.CostReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostReservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostReservationPayload>[]
          }
          delete: {
            args: Prisma.CostReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostReservationPayload>
          }
          update: {
            args: Prisma.CostReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostReservationPayload>
          }
          deleteMany: {
            args: Prisma.CostReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CostReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostReservationPayload>
          }
          aggregate: {
            args: Prisma.CostReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostReservation>
          }
          groupBy: {
            args: Prisma.CostReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostReservationCountArgs<ExtArgs>
            result: $Utils.Optional<CostReservationCountAggregateOutputType> | number
          }
        }
      }
      PromptOptimization: {
        payload: Prisma.$PromptOptimizationPayload<ExtArgs>
        fields: Prisma.PromptOptimizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptOptimizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptOptimizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptOptimizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptOptimizationPayload>
          }
          findFirst: {
            args: Prisma.PromptOptimizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptOptimizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptOptimizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptOptimizationPayload>
          }
          findMany: {
            args: Prisma.PromptOptimizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptOptimizationPayload>[]
          }
          create: {
            args: Prisma.PromptOptimizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptOptimizationPayload>
          }
          createMany: {
            args: Prisma.PromptOptimizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromptOptimizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptOptimizationPayload>[]
          }
          delete: {
            args: Prisma.PromptOptimizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptOptimizationPayload>
          }
          update: {
            args: Prisma.PromptOptimizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptOptimizationPayload>
          }
          deleteMany: {
            args: Prisma.PromptOptimizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromptOptimizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromptOptimizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptOptimizationPayload>
          }
          aggregate: {
            args: Prisma.PromptOptimizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromptOptimization>
          }
          groupBy: {
            args: Prisma.PromptOptimizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromptOptimizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptOptimizationCountArgs<ExtArgs>
            result: $Utils.Optional<PromptOptimizationCountAggregateOutputType> | number
          }
        }
      }
      CostAlert: {
        payload: Prisma.$CostAlertPayload<ExtArgs>
        fields: Prisma.CostAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostAlertPayload>
          }
          findFirst: {
            args: Prisma.CostAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostAlertPayload>
          }
          findMany: {
            args: Prisma.CostAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostAlertPayload>[]
          }
          create: {
            args: Prisma.CostAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostAlertPayload>
          }
          createMany: {
            args: Prisma.CostAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostAlertPayload>[]
          }
          delete: {
            args: Prisma.CostAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostAlertPayload>
          }
          update: {
            args: Prisma.CostAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostAlertPayload>
          }
          deleteMany: {
            args: Prisma.CostAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CostAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostAlertPayload>
          }
          aggregate: {
            args: Prisma.CostAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostAlert>
          }
          groupBy: {
            args: Prisma.CostAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostAlertCountArgs<ExtArgs>
            result: $Utils.Optional<CostAlertCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CreatorCountOutputType
   */

  export type CreatorCountOutputType = {
    subscriptionPlans: number
    products: number
    subscribers: number
    transactions: number
    payouts: number
    analytics: number
    installedApps: number
    auditLogs: number
    fanRelations: number
    campaigns: number
  }

  export type CreatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptionPlans?: boolean | CreatorCountOutputTypeCountSubscriptionPlansArgs
    products?: boolean | CreatorCountOutputTypeCountProductsArgs
    subscribers?: boolean | CreatorCountOutputTypeCountSubscribersArgs
    transactions?: boolean | CreatorCountOutputTypeCountTransactionsArgs
    payouts?: boolean | CreatorCountOutputTypeCountPayoutsArgs
    analytics?: boolean | CreatorCountOutputTypeCountAnalyticsArgs
    installedApps?: boolean | CreatorCountOutputTypeCountInstalledAppsArgs
    auditLogs?: boolean | CreatorCountOutputTypeCountAuditLogsArgs
    fanRelations?: boolean | CreatorCountOutputTypeCountFanRelationsArgs
    campaigns?: boolean | CreatorCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorCountOutputType
     */
    select?: CreatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountSubscriptionPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountSubscribersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayoutWhereInput
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsWhereInput
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountInstalledAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalledAppWhereInput
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountFanRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FanRelationWhereInput
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    subscriptions: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    purchases: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | ProductCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }


  /**
   * Count Type FanCountOutputType
   */

  export type FanCountOutputType = {
    subscriptions: number
    purchases: number
    transactions: number
    fanRelations: number
    campaignRecipients: number
  }

  export type FanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | FanCountOutputTypeCountSubscriptionsArgs
    purchases?: boolean | FanCountOutputTypeCountPurchasesArgs
    transactions?: boolean | FanCountOutputTypeCountTransactionsArgs
    fanRelations?: boolean | FanCountOutputTypeCountFanRelationsArgs
    campaignRecipients?: boolean | FanCountOutputTypeCountCampaignRecipientsArgs
  }

  // Custom InputTypes
  /**
   * FanCountOutputType without action
   */
  export type FanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanCountOutputType
     */
    select?: FanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FanCountOutputType without action
   */
  export type FanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * FanCountOutputType without action
   */
  export type FanCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * FanCountOutputType without action
   */
  export type FanCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * FanCountOutputType without action
   */
  export type FanCountOutputTypeCountFanRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FanRelationWhereInput
  }

  /**
   * FanCountOutputType without action
   */
  export type FanCountOutputTypeCountCampaignRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignRecipientWhereInput
  }


  /**
   * Count Type PayoutCountOutputType
   */

  export type PayoutCountOutputType = {
    transactions: number
  }

  export type PayoutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | PayoutCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * PayoutCountOutputType without action
   */
  export type PayoutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayoutCountOutputType
     */
    select?: PayoutCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayoutCountOutputType without action
   */
  export type PayoutCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    recipients: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipients?: boolean | CampaignCountOutputTypeCountRecipientsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignRecipientWhereInput
  }


  /**
   * Count Type AppCountOutputType
   */

  export type AppCountOutputType = {
    installations: number
  }

  export type AppCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installations?: boolean | AppCountOutputTypeCountInstallationsArgs
  }

  // Custom InputTypes
  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppCountOutputType
     */
    select?: AppCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeCountInstallationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalledAppWhereInput
  }


  /**
   * Count Type LedgerAccountCountOutputType
   */

  export type LedgerAccountCountOutputType = {
    entries: number
  }

  export type LedgerAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | LedgerAccountCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * LedgerAccountCountOutputType without action
   */
  export type LedgerAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccountCountOutputType
     */
    select?: LedgerAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LedgerAccountCountOutputType without action
   */
  export type LedgerAccountCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }


  /**
   * Count Type LedgerTransactionCountOutputType
   */

  export type LedgerTransactionCountOutputType = {
    entries: number
  }

  export type LedgerTransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | LedgerTransactionCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * LedgerTransactionCountOutputType without action
   */
  export type LedgerTransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransactionCountOutputType
     */
    select?: LedgerTransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LedgerTransactionCountOutputType without action
   */
  export type LedgerTransactionCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }


  /**
   * Count Type ExternalEarningsSourceCountOutputType
   */

  export type ExternalEarningsSourceCountOutputType = {
    imports: number
    earnings: number
  }

  export type ExternalEarningsSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    imports?: boolean | ExternalEarningsSourceCountOutputTypeCountImportsArgs
    earnings?: boolean | ExternalEarningsSourceCountOutputTypeCountEarningsArgs
  }

  // Custom InputTypes
  /**
   * ExternalEarningsSourceCountOutputType without action
   */
  export type ExternalEarningsSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSourceCountOutputType
     */
    select?: ExternalEarningsSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExternalEarningsSourceCountOutputType without action
   */
  export type ExternalEarningsSourceCountOutputTypeCountImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalEarningsImportWhereInput
  }

  /**
   * ExternalEarningsSourceCountOutputType without action
   */
  export type ExternalEarningsSourceCountOutputTypeCountEarningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NormalizedEarningWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Creator
   */

  export type AggregateCreator = {
    _count: CreatorCountAggregateOutputType | null
    _avg: CreatorAvgAggregateOutputType | null
    _sum: CreatorSumAggregateOutputType | null
    _min: CreatorMinAggregateOutputType | null
    _max: CreatorMaxAggregateOutputType | null
  }

  export type CreatorAvgAggregateOutputType = {
    totalRevenue: Decimal | null
    availableBalance: Decimal | null
  }

  export type CreatorSumAggregateOutputType = {
    totalRevenue: Decimal | null
    availableBalance: Decimal | null
  }

  export type CreatorMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    displayName: string | null
    bio: string | null
    avatar: string | null
    stripeAccountId: string | null
    stripeCustomerId: string | null
    stripeConnected: boolean | null
    kycStatus: $Enums.KycStatus | null
    commissionTier: $Enums.CommissionTier | null
    totalRevenue: Decimal | null
    availableBalance: Decimal | null
    currency: string | null
    locale: string | null
    timezone: string | null
    onboardingCompleted: boolean | null
    emailVerified: boolean | null
    twoFactorEnabled: boolean | null
    phoneNumber: string | null
    smsOptIn: boolean | null
    currentPlan: string | null
    accountStatus: $Enums.AccountStatus | null
    planDowngradedAt: Date | null
    planDowngradeReason: string | null
    suspendedAt: Date | null
    suspensionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreatorMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    displayName: string | null
    bio: string | null
    avatar: string | null
    stripeAccountId: string | null
    stripeCustomerId: string | null
    stripeConnected: boolean | null
    kycStatus: $Enums.KycStatus | null
    commissionTier: $Enums.CommissionTier | null
    totalRevenue: Decimal | null
    availableBalance: Decimal | null
    currency: string | null
    locale: string | null
    timezone: string | null
    onboardingCompleted: boolean | null
    emailVerified: boolean | null
    twoFactorEnabled: boolean | null
    phoneNumber: string | null
    smsOptIn: boolean | null
    currentPlan: string | null
    accountStatus: $Enums.AccountStatus | null
    planDowngradedAt: Date | null
    planDowngradeReason: string | null
    suspendedAt: Date | null
    suspensionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreatorCountAggregateOutputType = {
    id: number
    email: number
    username: number
    displayName: number
    bio: number
    avatar: number
    stripeAccountId: number
    stripeCustomerId: number
    stripeConnected: number
    kycStatus: number
    commissionTier: number
    totalRevenue: number
    availableBalance: number
    currency: number
    locale: number
    timezone: number
    onboardingCompleted: number
    emailVerified: number
    twoFactorEnabled: number
    phoneNumber: number
    smsOptIn: number
    currentPlan: number
    accountStatus: number
    planDowngradedAt: number
    planDowngradeReason: number
    suspendedAt: number
    suspensionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CreatorAvgAggregateInputType = {
    totalRevenue?: true
    availableBalance?: true
  }

  export type CreatorSumAggregateInputType = {
    totalRevenue?: true
    availableBalance?: true
  }

  export type CreatorMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    displayName?: true
    bio?: true
    avatar?: true
    stripeAccountId?: true
    stripeCustomerId?: true
    stripeConnected?: true
    kycStatus?: true
    commissionTier?: true
    totalRevenue?: true
    availableBalance?: true
    currency?: true
    locale?: true
    timezone?: true
    onboardingCompleted?: true
    emailVerified?: true
    twoFactorEnabled?: true
    phoneNumber?: true
    smsOptIn?: true
    currentPlan?: true
    accountStatus?: true
    planDowngradedAt?: true
    planDowngradeReason?: true
    suspendedAt?: true
    suspensionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreatorMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    displayName?: true
    bio?: true
    avatar?: true
    stripeAccountId?: true
    stripeCustomerId?: true
    stripeConnected?: true
    kycStatus?: true
    commissionTier?: true
    totalRevenue?: true
    availableBalance?: true
    currency?: true
    locale?: true
    timezone?: true
    onboardingCompleted?: true
    emailVerified?: true
    twoFactorEnabled?: true
    phoneNumber?: true
    smsOptIn?: true
    currentPlan?: true
    accountStatus?: true
    planDowngradedAt?: true
    planDowngradeReason?: true
    suspendedAt?: true
    suspensionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreatorCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    displayName?: true
    bio?: true
    avatar?: true
    stripeAccountId?: true
    stripeCustomerId?: true
    stripeConnected?: true
    kycStatus?: true
    commissionTier?: true
    totalRevenue?: true
    availableBalance?: true
    currency?: true
    locale?: true
    timezone?: true
    onboardingCompleted?: true
    emailVerified?: true
    twoFactorEnabled?: true
    phoneNumber?: true
    smsOptIn?: true
    currentPlan?: true
    accountStatus?: true
    planDowngradedAt?: true
    planDowngradeReason?: true
    suspendedAt?: true
    suspensionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CreatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creator to aggregate.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creators
    **/
    _count?: true | CreatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatorMaxAggregateInputType
  }

  export type GetCreatorAggregateType<T extends CreatorAggregateArgs> = {
        [P in keyof T & keyof AggregateCreator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreator[P]>
      : GetScalarType<T[P], AggregateCreator[P]>
  }




  export type CreatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatorWhereInput
    orderBy?: CreatorOrderByWithAggregationInput | CreatorOrderByWithAggregationInput[]
    by: CreatorScalarFieldEnum[] | CreatorScalarFieldEnum
    having?: CreatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatorCountAggregateInputType | true
    _avg?: CreatorAvgAggregateInputType
    _sum?: CreatorSumAggregateInputType
    _min?: CreatorMinAggregateInputType
    _max?: CreatorMaxAggregateInputType
  }

  export type CreatorGroupByOutputType = {
    id: string
    email: string
    username: string
    displayName: string
    bio: string | null
    avatar: string | null
    stripeAccountId: string | null
    stripeCustomerId: string | null
    stripeConnected: boolean
    kycStatus: $Enums.KycStatus
    commissionTier: $Enums.CommissionTier
    totalRevenue: Decimal
    availableBalance: Decimal
    currency: string
    locale: string
    timezone: string
    onboardingCompleted: boolean
    emailVerified: boolean
    twoFactorEnabled: boolean
    phoneNumber: string | null
    smsOptIn: boolean
    currentPlan: string
    accountStatus: $Enums.AccountStatus
    planDowngradedAt: Date | null
    planDowngradeReason: string | null
    suspendedAt: Date | null
    suspensionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: CreatorCountAggregateOutputType | null
    _avg: CreatorAvgAggregateOutputType | null
    _sum: CreatorSumAggregateOutputType | null
    _min: CreatorMinAggregateOutputType | null
    _max: CreatorMaxAggregateOutputType | null
  }

  type GetCreatorGroupByPayload<T extends CreatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatorGroupByOutputType[P]>
            : GetScalarType<T[P], CreatorGroupByOutputType[P]>
        }
      >
    >


  export type CreatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    displayName?: boolean
    bio?: boolean
    avatar?: boolean
    stripeAccountId?: boolean
    stripeCustomerId?: boolean
    stripeConnected?: boolean
    kycStatus?: boolean
    commissionTier?: boolean
    totalRevenue?: boolean
    availableBalance?: boolean
    currency?: boolean
    locale?: boolean
    timezone?: boolean
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: boolean
    smsOptIn?: boolean
    currentPlan?: boolean
    accountStatus?: boolean
    planDowngradedAt?: boolean
    planDowngradeReason?: boolean
    suspendedAt?: boolean
    suspensionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptionPlans?: boolean | Creator$subscriptionPlansArgs<ExtArgs>
    products?: boolean | Creator$productsArgs<ExtArgs>
    subscribers?: boolean | Creator$subscribersArgs<ExtArgs>
    transactions?: boolean | Creator$transactionsArgs<ExtArgs>
    payouts?: boolean | Creator$payoutsArgs<ExtArgs>
    analytics?: boolean | Creator$analyticsArgs<ExtArgs>
    installedApps?: boolean | Creator$installedAppsArgs<ExtArgs>
    auditLogs?: boolean | Creator$auditLogsArgs<ExtArgs>
    settings?: boolean | Creator$settingsArgs<ExtArgs>
    fanRelations?: boolean | Creator$fanRelationsArgs<ExtArgs>
    campaigns?: boolean | Creator$campaignsArgs<ExtArgs>
    _count?: boolean | CreatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creator"]>

  export type CreatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    displayName?: boolean
    bio?: boolean
    avatar?: boolean
    stripeAccountId?: boolean
    stripeCustomerId?: boolean
    stripeConnected?: boolean
    kycStatus?: boolean
    commissionTier?: boolean
    totalRevenue?: boolean
    availableBalance?: boolean
    currency?: boolean
    locale?: boolean
    timezone?: boolean
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: boolean
    smsOptIn?: boolean
    currentPlan?: boolean
    accountStatus?: boolean
    planDowngradedAt?: boolean
    planDowngradeReason?: boolean
    suspendedAt?: boolean
    suspensionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["creator"]>

  export type CreatorSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    displayName?: boolean
    bio?: boolean
    avatar?: boolean
    stripeAccountId?: boolean
    stripeCustomerId?: boolean
    stripeConnected?: boolean
    kycStatus?: boolean
    commissionTier?: boolean
    totalRevenue?: boolean
    availableBalance?: boolean
    currency?: boolean
    locale?: boolean
    timezone?: boolean
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: boolean
    smsOptIn?: boolean
    currentPlan?: boolean
    accountStatus?: boolean
    planDowngradedAt?: boolean
    planDowngradeReason?: boolean
    suspendedAt?: boolean
    suspensionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CreatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptionPlans?: boolean | Creator$subscriptionPlansArgs<ExtArgs>
    products?: boolean | Creator$productsArgs<ExtArgs>
    subscribers?: boolean | Creator$subscribersArgs<ExtArgs>
    transactions?: boolean | Creator$transactionsArgs<ExtArgs>
    payouts?: boolean | Creator$payoutsArgs<ExtArgs>
    analytics?: boolean | Creator$analyticsArgs<ExtArgs>
    installedApps?: boolean | Creator$installedAppsArgs<ExtArgs>
    auditLogs?: boolean | Creator$auditLogsArgs<ExtArgs>
    settings?: boolean | Creator$settingsArgs<ExtArgs>
    fanRelations?: boolean | Creator$fanRelationsArgs<ExtArgs>
    campaigns?: boolean | Creator$campaignsArgs<ExtArgs>
    _count?: boolean | CreatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CreatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Creator"
    objects: {
      subscriptionPlans: Prisma.$SubscriptionPlanPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      subscribers: Prisma.$SubscriptionPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      payouts: Prisma.$PayoutPayload<ExtArgs>[]
      analytics: Prisma.$AnalyticsPayload<ExtArgs>[]
      installedApps: Prisma.$InstalledAppPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      settings: Prisma.$CreatorSettingsPayload<ExtArgs> | null
      fanRelations: Prisma.$FanRelationPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      displayName: string
      bio: string | null
      avatar: string | null
      stripeAccountId: string | null
      stripeCustomerId: string | null
      stripeConnected: boolean
      kycStatus: $Enums.KycStatus
      commissionTier: $Enums.CommissionTier
      totalRevenue: Prisma.Decimal
      availableBalance: Prisma.Decimal
      currency: string
      locale: string
      timezone: string
      onboardingCompleted: boolean
      emailVerified: boolean
      twoFactorEnabled: boolean
      phoneNumber: string | null
      smsOptIn: boolean
      currentPlan: string
      accountStatus: $Enums.AccountStatus
      planDowngradedAt: Date | null
      planDowngradeReason: string | null
      suspendedAt: Date | null
      suspensionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["creator"]>
    composites: {}
  }

  type CreatorGetPayload<S extends boolean | null | undefined | CreatorDefaultArgs> = $Result.GetResult<Prisma.$CreatorPayload, S>

  type CreatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreatorCountAggregateInputType | true
    }

  export interface CreatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Creator'], meta: { name: 'Creator' } }
    /**
     * Find zero or one Creator that matches the filter.
     * @param {CreatorFindUniqueArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatorFindUniqueArgs>(args: SelectSubset<T, CreatorFindUniqueArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Creator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreatorFindUniqueOrThrowArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatorFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Creator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindFirstArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatorFindFirstArgs>(args?: SelectSubset<T, CreatorFindFirstArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Creator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindFirstOrThrowArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatorFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Creators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creators
     * const creators = await prisma.creator.findMany()
     * 
     * // Get first 10 Creators
     * const creators = await prisma.creator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatorWithIdOnly = await prisma.creator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatorFindManyArgs>(args?: SelectSubset<T, CreatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Creator.
     * @param {CreatorCreateArgs} args - Arguments to create a Creator.
     * @example
     * // Create one Creator
     * const Creator = await prisma.creator.create({
     *   data: {
     *     // ... data to create a Creator
     *   }
     * })
     * 
     */
    create<T extends CreatorCreateArgs>(args: SelectSubset<T, CreatorCreateArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Creators.
     * @param {CreatorCreateManyArgs} args - Arguments to create many Creators.
     * @example
     * // Create many Creators
     * const creator = await prisma.creator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatorCreateManyArgs>(args?: SelectSubset<T, CreatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Creators and returns the data saved in the database.
     * @param {CreatorCreateManyAndReturnArgs} args - Arguments to create many Creators.
     * @example
     * // Create many Creators
     * const creator = await prisma.creator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Creators and only return the `id`
     * const creatorWithIdOnly = await prisma.creator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatorCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Creator.
     * @param {CreatorDeleteArgs} args - Arguments to delete one Creator.
     * @example
     * // Delete one Creator
     * const Creator = await prisma.creator.delete({
     *   where: {
     *     // ... filter to delete one Creator
     *   }
     * })
     * 
     */
    delete<T extends CreatorDeleteArgs>(args: SelectSubset<T, CreatorDeleteArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Creator.
     * @param {CreatorUpdateArgs} args - Arguments to update one Creator.
     * @example
     * // Update one Creator
     * const creator = await prisma.creator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatorUpdateArgs>(args: SelectSubset<T, CreatorUpdateArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Creators.
     * @param {CreatorDeleteManyArgs} args - Arguments to filter Creators to delete.
     * @example
     * // Delete a few Creators
     * const { count } = await prisma.creator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatorDeleteManyArgs>(args?: SelectSubset<T, CreatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creators
     * const creator = await prisma.creator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatorUpdateManyArgs>(args: SelectSubset<T, CreatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Creator.
     * @param {CreatorUpsertArgs} args - Arguments to update or create a Creator.
     * @example
     * // Update or create a Creator
     * const creator = await prisma.creator.upsert({
     *   create: {
     *     // ... data to create a Creator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Creator we want to update
     *   }
     * })
     */
    upsert<T extends CreatorUpsertArgs>(args: SelectSubset<T, CreatorUpsertArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Creators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorCountArgs} args - Arguments to filter Creators to count.
     * @example
     * // Count the number of Creators
     * const count = await prisma.creator.count({
     *   where: {
     *     // ... the filter for the Creators we want to count
     *   }
     * })
    **/
    count<T extends CreatorCountArgs>(
      args?: Subset<T, CreatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Creator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatorAggregateArgs>(args: Subset<T, CreatorAggregateArgs>): Prisma.PrismaPromise<GetCreatorAggregateType<T>>

    /**
     * Group by Creator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatorGroupByArgs['orderBy'] }
        : { orderBy?: CreatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Creator model
   */
  readonly fields: CreatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Creator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptionPlans<T extends Creator$subscriptionPlansArgs<ExtArgs> = {}>(args?: Subset<T, Creator$subscriptionPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Creator$productsArgs<ExtArgs> = {}>(args?: Subset<T, Creator$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    subscribers<T extends Creator$subscribersArgs<ExtArgs> = {}>(args?: Subset<T, Creator$subscribersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Creator$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Creator$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    payouts<T extends Creator$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, Creator$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findMany"> | Null>
    analytics<T extends Creator$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, Creator$analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findMany"> | Null>
    installedApps<T extends Creator$installedAppsArgs<ExtArgs> = {}>(args?: Subset<T, Creator$installedAppsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Creator$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Creator$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    settings<T extends Creator$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Creator$settingsArgs<ExtArgs>>): Prisma__CreatorSettingsClient<$Result.GetResult<Prisma.$CreatorSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    fanRelations<T extends Creator$fanRelationsArgs<ExtArgs> = {}>(args?: Subset<T, Creator$fanRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "findMany"> | Null>
    campaigns<T extends Creator$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Creator$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Creator model
   */ 
  interface CreatorFieldRefs {
    readonly id: FieldRef<"Creator", 'String'>
    readonly email: FieldRef<"Creator", 'String'>
    readonly username: FieldRef<"Creator", 'String'>
    readonly displayName: FieldRef<"Creator", 'String'>
    readonly bio: FieldRef<"Creator", 'String'>
    readonly avatar: FieldRef<"Creator", 'String'>
    readonly stripeAccountId: FieldRef<"Creator", 'String'>
    readonly stripeCustomerId: FieldRef<"Creator", 'String'>
    readonly stripeConnected: FieldRef<"Creator", 'Boolean'>
    readonly kycStatus: FieldRef<"Creator", 'KycStatus'>
    readonly commissionTier: FieldRef<"Creator", 'CommissionTier'>
    readonly totalRevenue: FieldRef<"Creator", 'Decimal'>
    readonly availableBalance: FieldRef<"Creator", 'Decimal'>
    readonly currency: FieldRef<"Creator", 'String'>
    readonly locale: FieldRef<"Creator", 'String'>
    readonly timezone: FieldRef<"Creator", 'String'>
    readonly onboardingCompleted: FieldRef<"Creator", 'Boolean'>
    readonly emailVerified: FieldRef<"Creator", 'Boolean'>
    readonly twoFactorEnabled: FieldRef<"Creator", 'Boolean'>
    readonly phoneNumber: FieldRef<"Creator", 'String'>
    readonly smsOptIn: FieldRef<"Creator", 'Boolean'>
    readonly currentPlan: FieldRef<"Creator", 'String'>
    readonly accountStatus: FieldRef<"Creator", 'AccountStatus'>
    readonly planDowngradedAt: FieldRef<"Creator", 'DateTime'>
    readonly planDowngradeReason: FieldRef<"Creator", 'String'>
    readonly suspendedAt: FieldRef<"Creator", 'DateTime'>
    readonly suspensionReason: FieldRef<"Creator", 'String'>
    readonly createdAt: FieldRef<"Creator", 'DateTime'>
    readonly updatedAt: FieldRef<"Creator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Creator findUnique
   */
  export type CreatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator findUniqueOrThrow
   */
  export type CreatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator findFirst
   */
  export type CreatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creators.
     */
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
  }

  /**
   * Creator findFirstOrThrow
   */
  export type CreatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creators.
     */
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
  }

  /**
   * Creator findMany
   */
  export type CreatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creators to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
  }

  /**
   * Creator create
   */
  export type CreatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Creator.
     */
    data: XOR<CreatorCreateInput, CreatorUncheckedCreateInput>
  }

  /**
   * Creator createMany
   */
  export type CreatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Creators.
     */
    data: CreatorCreateManyInput | CreatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creator createManyAndReturn
   */
  export type CreatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Creators.
     */
    data: CreatorCreateManyInput | CreatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creator update
   */
  export type CreatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Creator.
     */
    data: XOR<CreatorUpdateInput, CreatorUncheckedUpdateInput>
    /**
     * Choose, which Creator to update.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator updateMany
   */
  export type CreatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Creators.
     */
    data: XOR<CreatorUpdateManyMutationInput, CreatorUncheckedUpdateManyInput>
    /**
     * Filter which Creators to update
     */
    where?: CreatorWhereInput
  }

  /**
   * Creator upsert
   */
  export type CreatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Creator to update in case it exists.
     */
    where: CreatorWhereUniqueInput
    /**
     * In case the Creator found by the `where` argument doesn't exist, create a new Creator with this data.
     */
    create: XOR<CreatorCreateInput, CreatorUncheckedCreateInput>
    /**
     * In case the Creator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatorUpdateInput, CreatorUncheckedUpdateInput>
  }

  /**
   * Creator delete
   */
  export type CreatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter which Creator to delete.
     */
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator deleteMany
   */
  export type CreatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creators to delete
     */
    where?: CreatorWhereInput
  }

  /**
   * Creator.subscriptionPlans
   */
  export type Creator$subscriptionPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    cursor?: SubscriptionPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * Creator.products
   */
  export type Creator$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Creator.subscribers
   */
  export type Creator$subscribersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Creator.transactions
   */
  export type Creator$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Creator.payouts
   */
  export type Creator$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    where?: PayoutWhereInput
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    cursor?: PayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Creator.analytics
   */
  export type Creator$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    where?: AnalyticsWhereInput
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    cursor?: AnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Creator.installedApps
   */
  export type Creator$installedAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
    where?: InstalledAppWhereInput
    orderBy?: InstalledAppOrderByWithRelationInput | InstalledAppOrderByWithRelationInput[]
    cursor?: InstalledAppWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstalledAppScalarFieldEnum | InstalledAppScalarFieldEnum[]
  }

  /**
   * Creator.auditLogs
   */
  export type Creator$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Creator.settings
   */
  export type Creator$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsInclude<ExtArgs> | null
    where?: CreatorSettingsWhereInput
  }

  /**
   * Creator.fanRelations
   */
  export type Creator$fanRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
    where?: FanRelationWhereInput
    orderBy?: FanRelationOrderByWithRelationInput | FanRelationOrderByWithRelationInput[]
    cursor?: FanRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FanRelationScalarFieldEnum | FanRelationScalarFieldEnum[]
  }

  /**
   * Creator.campaigns
   */
  export type Creator$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Creator without action
   */
  export type CreatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
  }


  /**
   * Model CreatorSettings
   */

  export type AggregateCreatorSettings = {
    _count: CreatorSettingsCountAggregateOutputType | null
    _avg: CreatorSettingsAvgAggregateOutputType | null
    _sum: CreatorSettingsSumAggregateOutputType | null
    _min: CreatorSettingsMinAggregateOutputType | null
    _max: CreatorSettingsMaxAggregateOutputType | null
  }

  export type CreatorSettingsAvgAggregateOutputType = {
    minPayout: Decimal | null
  }

  export type CreatorSettingsSumAggregateOutputType = {
    minPayout: Decimal | null
  }

  export type CreatorSettingsMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    pushNotifications: boolean | null
    showPublicProfile: boolean | null
    allowDMs: boolean | null
    minPayout: Decimal | null
    payoutFrequency: $Enums.PayoutFrequency | null
    taxFormSubmitted: boolean | null
    w9Submitted: boolean | null
    defaultContentAccess: $Enums.ContentAccess | null
    watermarkContent: boolean | null
    updatedAt: Date | null
  }

  export type CreatorSettingsMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    pushNotifications: boolean | null
    showPublicProfile: boolean | null
    allowDMs: boolean | null
    minPayout: Decimal | null
    payoutFrequency: $Enums.PayoutFrequency | null
    taxFormSubmitted: boolean | null
    w9Submitted: boolean | null
    defaultContentAccess: $Enums.ContentAccess | null
    watermarkContent: boolean | null
    updatedAt: Date | null
  }

  export type CreatorSettingsCountAggregateOutputType = {
    id: number
    creatorId: number
    emailNotifications: number
    smsNotifications: number
    pushNotifications: number
    showPublicProfile: number
    allowDMs: number
    minPayout: number
    payoutFrequency: number
    taxFormSubmitted: number
    w9Submitted: number
    defaultContentAccess: number
    watermarkContent: number
    updatedAt: number
    _all: number
  }


  export type CreatorSettingsAvgAggregateInputType = {
    minPayout?: true
  }

  export type CreatorSettingsSumAggregateInputType = {
    minPayout?: true
  }

  export type CreatorSettingsMinAggregateInputType = {
    id?: true
    creatorId?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    showPublicProfile?: true
    allowDMs?: true
    minPayout?: true
    payoutFrequency?: true
    taxFormSubmitted?: true
    w9Submitted?: true
    defaultContentAccess?: true
    watermarkContent?: true
    updatedAt?: true
  }

  export type CreatorSettingsMaxAggregateInputType = {
    id?: true
    creatorId?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    showPublicProfile?: true
    allowDMs?: true
    minPayout?: true
    payoutFrequency?: true
    taxFormSubmitted?: true
    w9Submitted?: true
    defaultContentAccess?: true
    watermarkContent?: true
    updatedAt?: true
  }

  export type CreatorSettingsCountAggregateInputType = {
    id?: true
    creatorId?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    showPublicProfile?: true
    allowDMs?: true
    minPayout?: true
    payoutFrequency?: true
    taxFormSubmitted?: true
    w9Submitted?: true
    defaultContentAccess?: true
    watermarkContent?: true
    updatedAt?: true
    _all?: true
  }

  export type CreatorSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatorSettings to aggregate.
     */
    where?: CreatorSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorSettings to fetch.
     */
    orderBy?: CreatorSettingsOrderByWithRelationInput | CreatorSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatorSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatorSettings
    **/
    _count?: true | CreatorSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatorSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatorSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatorSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatorSettingsMaxAggregateInputType
  }

  export type GetCreatorSettingsAggregateType<T extends CreatorSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatorSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatorSettings[P]>
      : GetScalarType<T[P], AggregateCreatorSettings[P]>
  }




  export type CreatorSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatorSettingsWhereInput
    orderBy?: CreatorSettingsOrderByWithAggregationInput | CreatorSettingsOrderByWithAggregationInput[]
    by: CreatorSettingsScalarFieldEnum[] | CreatorSettingsScalarFieldEnum
    having?: CreatorSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatorSettingsCountAggregateInputType | true
    _avg?: CreatorSettingsAvgAggregateInputType
    _sum?: CreatorSettingsSumAggregateInputType
    _min?: CreatorSettingsMinAggregateInputType
    _max?: CreatorSettingsMaxAggregateInputType
  }

  export type CreatorSettingsGroupByOutputType = {
    id: string
    creatorId: string
    emailNotifications: boolean
    smsNotifications: boolean
    pushNotifications: boolean
    showPublicProfile: boolean
    allowDMs: boolean
    minPayout: Decimal
    payoutFrequency: $Enums.PayoutFrequency
    taxFormSubmitted: boolean
    w9Submitted: boolean
    defaultContentAccess: $Enums.ContentAccess
    watermarkContent: boolean
    updatedAt: Date
    _count: CreatorSettingsCountAggregateOutputType | null
    _avg: CreatorSettingsAvgAggregateOutputType | null
    _sum: CreatorSettingsSumAggregateOutputType | null
    _min: CreatorSettingsMinAggregateOutputType | null
    _max: CreatorSettingsMaxAggregateOutputType | null
  }

  type GetCreatorSettingsGroupByPayload<T extends CreatorSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatorSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatorSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatorSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], CreatorSettingsGroupByOutputType[P]>
        }
      >
    >


  export type CreatorSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    showPublicProfile?: boolean
    allowDMs?: boolean
    minPayout?: boolean
    payoutFrequency?: boolean
    taxFormSubmitted?: boolean
    w9Submitted?: boolean
    defaultContentAccess?: boolean
    watermarkContent?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatorSettings"]>

  export type CreatorSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    showPublicProfile?: boolean
    allowDMs?: boolean
    minPayout?: boolean
    payoutFrequency?: boolean
    taxFormSubmitted?: boolean
    w9Submitted?: boolean
    defaultContentAccess?: boolean
    watermarkContent?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatorSettings"]>

  export type CreatorSettingsSelectScalar = {
    id?: boolean
    creatorId?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    showPublicProfile?: boolean
    allowDMs?: boolean
    minPayout?: boolean
    payoutFrequency?: boolean
    taxFormSubmitted?: boolean
    w9Submitted?: boolean
    defaultContentAccess?: boolean
    watermarkContent?: boolean
    updatedAt?: boolean
  }

  export type CreatorSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }
  export type CreatorSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }

  export type $CreatorSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatorSettings"
    objects: {
      creator: Prisma.$CreatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      emailNotifications: boolean
      smsNotifications: boolean
      pushNotifications: boolean
      showPublicProfile: boolean
      allowDMs: boolean
      minPayout: Prisma.Decimal
      payoutFrequency: $Enums.PayoutFrequency
      taxFormSubmitted: boolean
      w9Submitted: boolean
      defaultContentAccess: $Enums.ContentAccess
      watermarkContent: boolean
      updatedAt: Date
    }, ExtArgs["result"]["creatorSettings"]>
    composites: {}
  }

  type CreatorSettingsGetPayload<S extends boolean | null | undefined | CreatorSettingsDefaultArgs> = $Result.GetResult<Prisma.$CreatorSettingsPayload, S>

  type CreatorSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreatorSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreatorSettingsCountAggregateInputType | true
    }

  export interface CreatorSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatorSettings'], meta: { name: 'CreatorSettings' } }
    /**
     * Find zero or one CreatorSettings that matches the filter.
     * @param {CreatorSettingsFindUniqueArgs} args - Arguments to find a CreatorSettings
     * @example
     * // Get one CreatorSettings
     * const creatorSettings = await prisma.creatorSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatorSettingsFindUniqueArgs>(args: SelectSubset<T, CreatorSettingsFindUniqueArgs<ExtArgs>>): Prisma__CreatorSettingsClient<$Result.GetResult<Prisma.$CreatorSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CreatorSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreatorSettingsFindUniqueOrThrowArgs} args - Arguments to find a CreatorSettings
     * @example
     * // Get one CreatorSettings
     * const creatorSettings = await prisma.creatorSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatorSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatorSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatorSettingsClient<$Result.GetResult<Prisma.$CreatorSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CreatorSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorSettingsFindFirstArgs} args - Arguments to find a CreatorSettings
     * @example
     * // Get one CreatorSettings
     * const creatorSettings = await prisma.creatorSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatorSettingsFindFirstArgs>(args?: SelectSubset<T, CreatorSettingsFindFirstArgs<ExtArgs>>): Prisma__CreatorSettingsClient<$Result.GetResult<Prisma.$CreatorSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CreatorSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorSettingsFindFirstOrThrowArgs} args - Arguments to find a CreatorSettings
     * @example
     * // Get one CreatorSettings
     * const creatorSettings = await prisma.creatorSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatorSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatorSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatorSettingsClient<$Result.GetResult<Prisma.$CreatorSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CreatorSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatorSettings
     * const creatorSettings = await prisma.creatorSettings.findMany()
     * 
     * // Get first 10 CreatorSettings
     * const creatorSettings = await prisma.creatorSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatorSettingsWithIdOnly = await prisma.creatorSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatorSettingsFindManyArgs>(args?: SelectSubset<T, CreatorSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CreatorSettings.
     * @param {CreatorSettingsCreateArgs} args - Arguments to create a CreatorSettings.
     * @example
     * // Create one CreatorSettings
     * const CreatorSettings = await prisma.creatorSettings.create({
     *   data: {
     *     // ... data to create a CreatorSettings
     *   }
     * })
     * 
     */
    create<T extends CreatorSettingsCreateArgs>(args: SelectSubset<T, CreatorSettingsCreateArgs<ExtArgs>>): Prisma__CreatorSettingsClient<$Result.GetResult<Prisma.$CreatorSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CreatorSettings.
     * @param {CreatorSettingsCreateManyArgs} args - Arguments to create many CreatorSettings.
     * @example
     * // Create many CreatorSettings
     * const creatorSettings = await prisma.creatorSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatorSettingsCreateManyArgs>(args?: SelectSubset<T, CreatorSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatorSettings and returns the data saved in the database.
     * @param {CreatorSettingsCreateManyAndReturnArgs} args - Arguments to create many CreatorSettings.
     * @example
     * // Create many CreatorSettings
     * const creatorSettings = await prisma.creatorSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatorSettings and only return the `id`
     * const creatorSettingsWithIdOnly = await prisma.creatorSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatorSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatorSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CreatorSettings.
     * @param {CreatorSettingsDeleteArgs} args - Arguments to delete one CreatorSettings.
     * @example
     * // Delete one CreatorSettings
     * const CreatorSettings = await prisma.creatorSettings.delete({
     *   where: {
     *     // ... filter to delete one CreatorSettings
     *   }
     * })
     * 
     */
    delete<T extends CreatorSettingsDeleteArgs>(args: SelectSubset<T, CreatorSettingsDeleteArgs<ExtArgs>>): Prisma__CreatorSettingsClient<$Result.GetResult<Prisma.$CreatorSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CreatorSettings.
     * @param {CreatorSettingsUpdateArgs} args - Arguments to update one CreatorSettings.
     * @example
     * // Update one CreatorSettings
     * const creatorSettings = await prisma.creatorSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatorSettingsUpdateArgs>(args: SelectSubset<T, CreatorSettingsUpdateArgs<ExtArgs>>): Prisma__CreatorSettingsClient<$Result.GetResult<Prisma.$CreatorSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CreatorSettings.
     * @param {CreatorSettingsDeleteManyArgs} args - Arguments to filter CreatorSettings to delete.
     * @example
     * // Delete a few CreatorSettings
     * const { count } = await prisma.creatorSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatorSettingsDeleteManyArgs>(args?: SelectSubset<T, CreatorSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatorSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatorSettings
     * const creatorSettings = await prisma.creatorSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatorSettingsUpdateManyArgs>(args: SelectSubset<T, CreatorSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CreatorSettings.
     * @param {CreatorSettingsUpsertArgs} args - Arguments to update or create a CreatorSettings.
     * @example
     * // Update or create a CreatorSettings
     * const creatorSettings = await prisma.creatorSettings.upsert({
     *   create: {
     *     // ... data to create a CreatorSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatorSettings we want to update
     *   }
     * })
     */
    upsert<T extends CreatorSettingsUpsertArgs>(args: SelectSubset<T, CreatorSettingsUpsertArgs<ExtArgs>>): Prisma__CreatorSettingsClient<$Result.GetResult<Prisma.$CreatorSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CreatorSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorSettingsCountArgs} args - Arguments to filter CreatorSettings to count.
     * @example
     * // Count the number of CreatorSettings
     * const count = await prisma.creatorSettings.count({
     *   where: {
     *     // ... the filter for the CreatorSettings we want to count
     *   }
     * })
    **/
    count<T extends CreatorSettingsCountArgs>(
      args?: Subset<T, CreatorSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatorSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatorSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatorSettingsAggregateArgs>(args: Subset<T, CreatorSettingsAggregateArgs>): Prisma.PrismaPromise<GetCreatorSettingsAggregateType<T>>

    /**
     * Group by CreatorSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatorSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatorSettingsGroupByArgs['orderBy'] }
        : { orderBy?: CreatorSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatorSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatorSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatorSettings model
   */
  readonly fields: CreatorSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatorSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatorSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends CreatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatorDefaultArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatorSettings model
   */ 
  interface CreatorSettingsFieldRefs {
    readonly id: FieldRef<"CreatorSettings", 'String'>
    readonly creatorId: FieldRef<"CreatorSettings", 'String'>
    readonly emailNotifications: FieldRef<"CreatorSettings", 'Boolean'>
    readonly smsNotifications: FieldRef<"CreatorSettings", 'Boolean'>
    readonly pushNotifications: FieldRef<"CreatorSettings", 'Boolean'>
    readonly showPublicProfile: FieldRef<"CreatorSettings", 'Boolean'>
    readonly allowDMs: FieldRef<"CreatorSettings", 'Boolean'>
    readonly minPayout: FieldRef<"CreatorSettings", 'Decimal'>
    readonly payoutFrequency: FieldRef<"CreatorSettings", 'PayoutFrequency'>
    readonly taxFormSubmitted: FieldRef<"CreatorSettings", 'Boolean'>
    readonly w9Submitted: FieldRef<"CreatorSettings", 'Boolean'>
    readonly defaultContentAccess: FieldRef<"CreatorSettings", 'ContentAccess'>
    readonly watermarkContent: FieldRef<"CreatorSettings", 'Boolean'>
    readonly updatedAt: FieldRef<"CreatorSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreatorSettings findUnique
   */
  export type CreatorSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsInclude<ExtArgs> | null
    /**
     * Filter, which CreatorSettings to fetch.
     */
    where: CreatorSettingsWhereUniqueInput
  }

  /**
   * CreatorSettings findUniqueOrThrow
   */
  export type CreatorSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsInclude<ExtArgs> | null
    /**
     * Filter, which CreatorSettings to fetch.
     */
    where: CreatorSettingsWhereUniqueInput
  }

  /**
   * CreatorSettings findFirst
   */
  export type CreatorSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsInclude<ExtArgs> | null
    /**
     * Filter, which CreatorSettings to fetch.
     */
    where?: CreatorSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorSettings to fetch.
     */
    orderBy?: CreatorSettingsOrderByWithRelationInput | CreatorSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatorSettings.
     */
    cursor?: CreatorSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatorSettings.
     */
    distinct?: CreatorSettingsScalarFieldEnum | CreatorSettingsScalarFieldEnum[]
  }

  /**
   * CreatorSettings findFirstOrThrow
   */
  export type CreatorSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsInclude<ExtArgs> | null
    /**
     * Filter, which CreatorSettings to fetch.
     */
    where?: CreatorSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorSettings to fetch.
     */
    orderBy?: CreatorSettingsOrderByWithRelationInput | CreatorSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatorSettings.
     */
    cursor?: CreatorSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatorSettings.
     */
    distinct?: CreatorSettingsScalarFieldEnum | CreatorSettingsScalarFieldEnum[]
  }

  /**
   * CreatorSettings findMany
   */
  export type CreatorSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsInclude<ExtArgs> | null
    /**
     * Filter, which CreatorSettings to fetch.
     */
    where?: CreatorSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorSettings to fetch.
     */
    orderBy?: CreatorSettingsOrderByWithRelationInput | CreatorSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatorSettings.
     */
    cursor?: CreatorSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorSettings.
     */
    skip?: number
    distinct?: CreatorSettingsScalarFieldEnum | CreatorSettingsScalarFieldEnum[]
  }

  /**
   * CreatorSettings create
   */
  export type CreatorSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatorSettings.
     */
    data: XOR<CreatorSettingsCreateInput, CreatorSettingsUncheckedCreateInput>
  }

  /**
   * CreatorSettings createMany
   */
  export type CreatorSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatorSettings.
     */
    data: CreatorSettingsCreateManyInput | CreatorSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatorSettings createManyAndReturn
   */
  export type CreatorSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CreatorSettings.
     */
    data: CreatorSettingsCreateManyInput | CreatorSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatorSettings update
   */
  export type CreatorSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatorSettings.
     */
    data: XOR<CreatorSettingsUpdateInput, CreatorSettingsUncheckedUpdateInput>
    /**
     * Choose, which CreatorSettings to update.
     */
    where: CreatorSettingsWhereUniqueInput
  }

  /**
   * CreatorSettings updateMany
   */
  export type CreatorSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatorSettings.
     */
    data: XOR<CreatorSettingsUpdateManyMutationInput, CreatorSettingsUncheckedUpdateManyInput>
    /**
     * Filter which CreatorSettings to update
     */
    where?: CreatorSettingsWhereInput
  }

  /**
   * CreatorSettings upsert
   */
  export type CreatorSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatorSettings to update in case it exists.
     */
    where: CreatorSettingsWhereUniqueInput
    /**
     * In case the CreatorSettings found by the `where` argument doesn't exist, create a new CreatorSettings with this data.
     */
    create: XOR<CreatorSettingsCreateInput, CreatorSettingsUncheckedCreateInput>
    /**
     * In case the CreatorSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatorSettingsUpdateInput, CreatorSettingsUncheckedUpdateInput>
  }

  /**
   * CreatorSettings delete
   */
  export type CreatorSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsInclude<ExtArgs> | null
    /**
     * Filter which CreatorSettings to delete.
     */
    where: CreatorSettingsWhereUniqueInput
  }

  /**
   * CreatorSettings deleteMany
   */
  export type CreatorSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatorSettings to delete
     */
    where?: CreatorSettingsWhereInput
  }

  /**
   * CreatorSettings without action
   */
  export type CreatorSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorSettings
     */
    select?: CreatorSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorSettingsInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    price: Decimal | null
    intervalCount: number | null
    maxDownloads: number | null
    trialPeriodDays: number | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    price: Decimal | null
    intervalCount: number | null
    maxDownloads: number | null
    trialPeriodDays: number | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    interval: $Enums.BillingInterval | null
    intervalCount: number | null
    maxDownloads: number | null
    earlyAccess: boolean | null
    exclusiveContent: boolean | null
    trialPeriodDays: number | null
    stripePriceId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    interval: $Enums.BillingInterval | null
    intervalCount: number | null
    maxDownloads: number | null
    earlyAccess: boolean | null
    exclusiveContent: boolean | null
    trialPeriodDays: number | null
    stripePriceId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    creatorId: number
    name: number
    description: number
    price: number
    currency: number
    interval: number
    intervalCount: number
    features: number
    maxDownloads: number
    earlyAccess: number
    exclusiveContent: number
    trialPeriodDays: number
    stripePriceId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    price?: true
    intervalCount?: true
    maxDownloads?: true
    trialPeriodDays?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    price?: true
    intervalCount?: true
    maxDownloads?: true
    trialPeriodDays?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    intervalCount?: true
    maxDownloads?: true
    earlyAccess?: true
    exclusiveContent?: true
    trialPeriodDays?: true
    stripePriceId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    intervalCount?: true
    maxDownloads?: true
    earlyAccess?: true
    exclusiveContent?: true
    trialPeriodDays?: true
    stripePriceId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    intervalCount?: true
    features?: true
    maxDownloads?: true
    earlyAccess?: true
    exclusiveContent?: true
    trialPeriodDays?: true
    stripePriceId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: string
    creatorId: string
    name: string
    description: string | null
    price: Decimal
    currency: string
    interval: $Enums.BillingInterval
    intervalCount: number
    features: JsonValue
    maxDownloads: number | null
    earlyAccess: boolean
    exclusiveContent: boolean
    trialPeriodDays: number | null
    stripePriceId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    intervalCount?: boolean
    features?: boolean
    maxDownloads?: boolean
    earlyAccess?: boolean
    exclusiveContent?: boolean
    trialPeriodDays?: boolean
    stripePriceId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    intervalCount?: boolean
    features?: boolean
    maxDownloads?: boolean
    earlyAccess?: boolean
    exclusiveContent?: boolean
    trialPeriodDays?: boolean
    stripePriceId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    creatorId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    intervalCount?: boolean
    features?: boolean
    maxDownloads?: boolean
    earlyAccess?: boolean
    exclusiveContent?: boolean
    trialPeriodDays?: boolean
    stripePriceId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      creator: Prisma.$CreatorPayload<ExtArgs>
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      name: string
      description: string | null
      price: Prisma.Decimal
      currency: string
      interval: $Enums.BillingInterval
      intervalCount: number
      features: Prisma.JsonValue
      maxDownloads: number | null
      earlyAccess: boolean
      exclusiveContent: boolean
      trialPeriodDays: number | null
      stripePriceId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends CreatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatorDefaultArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subscriptions<T extends SubscriptionPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */ 
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'String'>
    readonly creatorId: FieldRef<"SubscriptionPlan", 'String'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly description: FieldRef<"SubscriptionPlan", 'String'>
    readonly price: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly currency: FieldRef<"SubscriptionPlan", 'String'>
    readonly interval: FieldRef<"SubscriptionPlan", 'BillingInterval'>
    readonly intervalCount: FieldRef<"SubscriptionPlan", 'Int'>
    readonly features: FieldRef<"SubscriptionPlan", 'Json'>
    readonly maxDownloads: FieldRef<"SubscriptionPlan", 'Int'>
    readonly earlyAccess: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly exclusiveContent: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly trialPeriodDays: FieldRef<"SubscriptionPlan", 'Int'>
    readonly stripePriceId: FieldRef<"SubscriptionPlan", 'String'>
    readonly isActive: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly createdAt: FieldRef<"SubscriptionPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan.subscriptions
   */
  export type SubscriptionPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    viewCount: number | null
    purchaseCount: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    viewCount: number | null
    purchaseCount: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    type: $Enums.ProductType | null
    title: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    contentUrl: string | null
    thumbnailUrl: string | null
    previewUrl: string | null
    accessType: $Enums.ContentAccess | null
    requiresSubscription: boolean | null
    isPublished: boolean | null
    publishedAt: Date | null
    viewCount: number | null
    purchaseCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    type: $Enums.ProductType | null
    title: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    contentUrl: string | null
    thumbnailUrl: string | null
    previewUrl: string | null
    accessType: $Enums.ContentAccess | null
    requiresSubscription: boolean | null
    isPublished: boolean | null
    publishedAt: Date | null
    viewCount: number | null
    purchaseCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    creatorId: number
    type: number
    title: number
    description: number
    price: number
    currency: number
    contentUrl: number
    thumbnailUrl: number
    previewUrl: number
    accessType: number
    requiresSubscription: number
    tags: number
    isPublished: number
    publishedAt: number
    viewCount: number
    purchaseCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    viewCount?: true
    purchaseCount?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    viewCount?: true
    purchaseCount?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    creatorId?: true
    type?: true
    title?: true
    description?: true
    price?: true
    currency?: true
    contentUrl?: true
    thumbnailUrl?: true
    previewUrl?: true
    accessType?: true
    requiresSubscription?: true
    isPublished?: true
    publishedAt?: true
    viewCount?: true
    purchaseCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    creatorId?: true
    type?: true
    title?: true
    description?: true
    price?: true
    currency?: true
    contentUrl?: true
    thumbnailUrl?: true
    previewUrl?: true
    accessType?: true
    requiresSubscription?: true
    isPublished?: true
    publishedAt?: true
    viewCount?: true
    purchaseCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    creatorId?: true
    type?: true
    title?: true
    description?: true
    price?: true
    currency?: true
    contentUrl?: true
    thumbnailUrl?: true
    previewUrl?: true
    accessType?: true
    requiresSubscription?: true
    tags?: true
    isPublished?: true
    publishedAt?: true
    viewCount?: true
    purchaseCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    creatorId: string
    type: $Enums.ProductType
    title: string
    description: string | null
    price: Decimal | null
    currency: string
    contentUrl: string | null
    thumbnailUrl: string | null
    previewUrl: string | null
    accessType: $Enums.ContentAccess
    requiresSubscription: boolean
    tags: string[]
    isPublished: boolean
    publishedAt: Date | null
    viewCount: number
    purchaseCount: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    contentUrl?: boolean
    thumbnailUrl?: boolean
    previewUrl?: boolean
    accessType?: boolean
    requiresSubscription?: boolean
    tags?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    purchaseCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    purchases?: boolean | Product$purchasesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    contentUrl?: boolean
    thumbnailUrl?: boolean
    previewUrl?: boolean
    accessType?: boolean
    requiresSubscription?: boolean
    tags?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    purchaseCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    creatorId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    contentUrl?: boolean
    thumbnailUrl?: boolean
    previewUrl?: boolean
    accessType?: boolean
    requiresSubscription?: boolean
    tags?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    purchaseCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    purchases?: boolean | Product$purchasesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      creator: Prisma.$CreatorPayload<ExtArgs>
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      type: $Enums.ProductType
      title: string
      description: string | null
      price: Prisma.Decimal | null
      currency: string
      contentUrl: string | null
      thumbnailUrl: string | null
      previewUrl: string | null
      accessType: $Enums.ContentAccess
      requiresSubscription: boolean
      tags: string[]
      isPublished: boolean
      publishedAt: Date | null
      viewCount: number
      purchaseCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends CreatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatorDefaultArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    purchases<T extends Product$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly creatorId: FieldRef<"Product", 'String'>
    readonly type: FieldRef<"Product", 'ProductType'>
    readonly title: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly currency: FieldRef<"Product", 'String'>
    readonly contentUrl: FieldRef<"Product", 'String'>
    readonly thumbnailUrl: FieldRef<"Product", 'String'>
    readonly previewUrl: FieldRef<"Product", 'String'>
    readonly accessType: FieldRef<"Product", 'ContentAccess'>
    readonly requiresSubscription: FieldRef<"Product", 'Boolean'>
    readonly tags: FieldRef<"Product", 'String[]'>
    readonly isPublished: FieldRef<"Product", 'Boolean'>
    readonly publishedAt: FieldRef<"Product", 'DateTime'>
    readonly viewCount: FieldRef<"Product", 'Int'>
    readonly purchaseCount: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.purchases
   */
  export type Product$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Fan
   */

  export type AggregateFan = {
    _count: FanCountAggregateOutputType | null
    _min: FanMinAggregateOutputType | null
    _max: FanMaxAggregateOutputType | null
  }

  export type FanMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    displayName: string | null
    avatar: string | null
    stripeCustomerId: string | null
    emailVerified: boolean | null
    phoneNumber: string | null
    phoneVerified: boolean | null
    locale: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FanMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    displayName: string | null
    avatar: string | null
    stripeCustomerId: string | null
    emailVerified: boolean | null
    phoneNumber: string | null
    phoneVerified: boolean | null
    locale: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FanCountAggregateOutputType = {
    id: number
    email: number
    username: number
    displayName: number
    avatar: number
    stripeCustomerId: number
    emailVerified: number
    phoneNumber: number
    phoneVerified: number
    locale: number
    timezone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FanMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    displayName?: true
    avatar?: true
    stripeCustomerId?: true
    emailVerified?: true
    phoneNumber?: true
    phoneVerified?: true
    locale?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FanMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    displayName?: true
    avatar?: true
    stripeCustomerId?: true
    emailVerified?: true
    phoneNumber?: true
    phoneVerified?: true
    locale?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FanCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    displayName?: true
    avatar?: true
    stripeCustomerId?: true
    emailVerified?: true
    phoneNumber?: true
    phoneVerified?: true
    locale?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fan to aggregate.
     */
    where?: FanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fans to fetch.
     */
    orderBy?: FanOrderByWithRelationInput | FanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fans
    **/
    _count?: true | FanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FanMaxAggregateInputType
  }

  export type GetFanAggregateType<T extends FanAggregateArgs> = {
        [P in keyof T & keyof AggregateFan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFan[P]>
      : GetScalarType<T[P], AggregateFan[P]>
  }




  export type FanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FanWhereInput
    orderBy?: FanOrderByWithAggregationInput | FanOrderByWithAggregationInput[]
    by: FanScalarFieldEnum[] | FanScalarFieldEnum
    having?: FanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FanCountAggregateInputType | true
    _min?: FanMinAggregateInputType
    _max?: FanMaxAggregateInputType
  }

  export type FanGroupByOutputType = {
    id: string
    email: string
    username: string | null
    displayName: string | null
    avatar: string | null
    stripeCustomerId: string | null
    emailVerified: boolean
    phoneNumber: string | null
    phoneVerified: boolean
    locale: string
    timezone: string
    createdAt: Date
    updatedAt: Date
    _count: FanCountAggregateOutputType | null
    _min: FanMinAggregateOutputType | null
    _max: FanMaxAggregateOutputType | null
  }

  type GetFanGroupByPayload<T extends FanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FanGroupByOutputType[P]>
            : GetScalarType<T[P], FanGroupByOutputType[P]>
        }
      >
    >


  export type FanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    displayName?: boolean
    avatar?: boolean
    stripeCustomerId?: boolean
    emailVerified?: boolean
    phoneNumber?: boolean
    phoneVerified?: boolean
    locale?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | Fan$subscriptionsArgs<ExtArgs>
    purchases?: boolean | Fan$purchasesArgs<ExtArgs>
    transactions?: boolean | Fan$transactionsArgs<ExtArgs>
    fanRelations?: boolean | Fan$fanRelationsArgs<ExtArgs>
    campaignRecipients?: boolean | Fan$campaignRecipientsArgs<ExtArgs>
    _count?: boolean | FanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fan"]>

  export type FanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    displayName?: boolean
    avatar?: boolean
    stripeCustomerId?: boolean
    emailVerified?: boolean
    phoneNumber?: boolean
    phoneVerified?: boolean
    locale?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fan"]>

  export type FanSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    displayName?: boolean
    avatar?: boolean
    stripeCustomerId?: boolean
    emailVerified?: boolean
    phoneNumber?: boolean
    phoneVerified?: boolean
    locale?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | Fan$subscriptionsArgs<ExtArgs>
    purchases?: boolean | Fan$purchasesArgs<ExtArgs>
    transactions?: boolean | Fan$transactionsArgs<ExtArgs>
    fanRelations?: boolean | Fan$fanRelationsArgs<ExtArgs>
    campaignRecipients?: boolean | Fan$campaignRecipientsArgs<ExtArgs>
    _count?: boolean | FanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fan"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      fanRelations: Prisma.$FanRelationPayload<ExtArgs>[]
      campaignRecipients: Prisma.$CampaignRecipientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string | null
      displayName: string | null
      avatar: string | null
      stripeCustomerId: string | null
      emailVerified: boolean
      phoneNumber: string | null
      phoneVerified: boolean
      locale: string
      timezone: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fan"]>
    composites: {}
  }

  type FanGetPayload<S extends boolean | null | undefined | FanDefaultArgs> = $Result.GetResult<Prisma.$FanPayload, S>

  type FanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FanCountAggregateInputType | true
    }

  export interface FanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fan'], meta: { name: 'Fan' } }
    /**
     * Find zero or one Fan that matches the filter.
     * @param {FanFindUniqueArgs} args - Arguments to find a Fan
     * @example
     * // Get one Fan
     * const fan = await prisma.fan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FanFindUniqueArgs>(args: SelectSubset<T, FanFindUniqueArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Fan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FanFindUniqueOrThrowArgs} args - Arguments to find a Fan
     * @example
     * // Get one Fan
     * const fan = await prisma.fan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FanFindUniqueOrThrowArgs>(args: SelectSubset<T, FanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Fan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanFindFirstArgs} args - Arguments to find a Fan
     * @example
     * // Get one Fan
     * const fan = await prisma.fan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FanFindFirstArgs>(args?: SelectSubset<T, FanFindFirstArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Fan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanFindFirstOrThrowArgs} args - Arguments to find a Fan
     * @example
     * // Get one Fan
     * const fan = await prisma.fan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FanFindFirstOrThrowArgs>(args?: SelectSubset<T, FanFindFirstOrThrowArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Fans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fans
     * const fans = await prisma.fan.findMany()
     * 
     * // Get first 10 Fans
     * const fans = await prisma.fan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fanWithIdOnly = await prisma.fan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FanFindManyArgs>(args?: SelectSubset<T, FanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Fan.
     * @param {FanCreateArgs} args - Arguments to create a Fan.
     * @example
     * // Create one Fan
     * const Fan = await prisma.fan.create({
     *   data: {
     *     // ... data to create a Fan
     *   }
     * })
     * 
     */
    create<T extends FanCreateArgs>(args: SelectSubset<T, FanCreateArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Fans.
     * @param {FanCreateManyArgs} args - Arguments to create many Fans.
     * @example
     * // Create many Fans
     * const fan = await prisma.fan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FanCreateManyArgs>(args?: SelectSubset<T, FanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fans and returns the data saved in the database.
     * @param {FanCreateManyAndReturnArgs} args - Arguments to create many Fans.
     * @example
     * // Create many Fans
     * const fan = await prisma.fan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fans and only return the `id`
     * const fanWithIdOnly = await prisma.fan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FanCreateManyAndReturnArgs>(args?: SelectSubset<T, FanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Fan.
     * @param {FanDeleteArgs} args - Arguments to delete one Fan.
     * @example
     * // Delete one Fan
     * const Fan = await prisma.fan.delete({
     *   where: {
     *     // ... filter to delete one Fan
     *   }
     * })
     * 
     */
    delete<T extends FanDeleteArgs>(args: SelectSubset<T, FanDeleteArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Fan.
     * @param {FanUpdateArgs} args - Arguments to update one Fan.
     * @example
     * // Update one Fan
     * const fan = await prisma.fan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FanUpdateArgs>(args: SelectSubset<T, FanUpdateArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Fans.
     * @param {FanDeleteManyArgs} args - Arguments to filter Fans to delete.
     * @example
     * // Delete a few Fans
     * const { count } = await prisma.fan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FanDeleteManyArgs>(args?: SelectSubset<T, FanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fans
     * const fan = await prisma.fan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FanUpdateManyArgs>(args: SelectSubset<T, FanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fan.
     * @param {FanUpsertArgs} args - Arguments to update or create a Fan.
     * @example
     * // Update or create a Fan
     * const fan = await prisma.fan.upsert({
     *   create: {
     *     // ... data to create a Fan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fan we want to update
     *   }
     * })
     */
    upsert<T extends FanUpsertArgs>(args: SelectSubset<T, FanUpsertArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Fans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanCountArgs} args - Arguments to filter Fans to count.
     * @example
     * // Count the number of Fans
     * const count = await prisma.fan.count({
     *   where: {
     *     // ... the filter for the Fans we want to count
     *   }
     * })
    **/
    count<T extends FanCountArgs>(
      args?: Subset<T, FanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FanAggregateArgs>(args: Subset<T, FanAggregateArgs>): Prisma.PrismaPromise<GetFanAggregateType<T>>

    /**
     * Group by Fan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FanGroupByArgs['orderBy'] }
        : { orderBy?: FanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fan model
   */
  readonly fields: FanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends Fan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Fan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    purchases<T extends Fan$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Fan$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Fan$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Fan$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    fanRelations<T extends Fan$fanRelationsArgs<ExtArgs> = {}>(args?: Subset<T, Fan$fanRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "findMany"> | Null>
    campaignRecipients<T extends Fan$campaignRecipientsArgs<ExtArgs> = {}>(args?: Subset<T, Fan$campaignRecipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fan model
   */ 
  interface FanFieldRefs {
    readonly id: FieldRef<"Fan", 'String'>
    readonly email: FieldRef<"Fan", 'String'>
    readonly username: FieldRef<"Fan", 'String'>
    readonly displayName: FieldRef<"Fan", 'String'>
    readonly avatar: FieldRef<"Fan", 'String'>
    readonly stripeCustomerId: FieldRef<"Fan", 'String'>
    readonly emailVerified: FieldRef<"Fan", 'Boolean'>
    readonly phoneNumber: FieldRef<"Fan", 'String'>
    readonly phoneVerified: FieldRef<"Fan", 'Boolean'>
    readonly locale: FieldRef<"Fan", 'String'>
    readonly timezone: FieldRef<"Fan", 'String'>
    readonly createdAt: FieldRef<"Fan", 'DateTime'>
    readonly updatedAt: FieldRef<"Fan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fan findUnique
   */
  export type FanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanInclude<ExtArgs> | null
    /**
     * Filter, which Fan to fetch.
     */
    where: FanWhereUniqueInput
  }

  /**
   * Fan findUniqueOrThrow
   */
  export type FanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanInclude<ExtArgs> | null
    /**
     * Filter, which Fan to fetch.
     */
    where: FanWhereUniqueInput
  }

  /**
   * Fan findFirst
   */
  export type FanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanInclude<ExtArgs> | null
    /**
     * Filter, which Fan to fetch.
     */
    where?: FanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fans to fetch.
     */
    orderBy?: FanOrderByWithRelationInput | FanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fans.
     */
    cursor?: FanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fans.
     */
    distinct?: FanScalarFieldEnum | FanScalarFieldEnum[]
  }

  /**
   * Fan findFirstOrThrow
   */
  export type FanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanInclude<ExtArgs> | null
    /**
     * Filter, which Fan to fetch.
     */
    where?: FanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fans to fetch.
     */
    orderBy?: FanOrderByWithRelationInput | FanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fans.
     */
    cursor?: FanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fans.
     */
    distinct?: FanScalarFieldEnum | FanScalarFieldEnum[]
  }

  /**
   * Fan findMany
   */
  export type FanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanInclude<ExtArgs> | null
    /**
     * Filter, which Fans to fetch.
     */
    where?: FanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fans to fetch.
     */
    orderBy?: FanOrderByWithRelationInput | FanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fans.
     */
    cursor?: FanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fans.
     */
    skip?: number
    distinct?: FanScalarFieldEnum | FanScalarFieldEnum[]
  }

  /**
   * Fan create
   */
  export type FanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanInclude<ExtArgs> | null
    /**
     * The data needed to create a Fan.
     */
    data: XOR<FanCreateInput, FanUncheckedCreateInput>
  }

  /**
   * Fan createMany
   */
  export type FanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fans.
     */
    data: FanCreateManyInput | FanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fan createManyAndReturn
   */
  export type FanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Fans.
     */
    data: FanCreateManyInput | FanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fan update
   */
  export type FanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanInclude<ExtArgs> | null
    /**
     * The data needed to update a Fan.
     */
    data: XOR<FanUpdateInput, FanUncheckedUpdateInput>
    /**
     * Choose, which Fan to update.
     */
    where: FanWhereUniqueInput
  }

  /**
   * Fan updateMany
   */
  export type FanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fans.
     */
    data: XOR<FanUpdateManyMutationInput, FanUncheckedUpdateManyInput>
    /**
     * Filter which Fans to update
     */
    where?: FanWhereInput
  }

  /**
   * Fan upsert
   */
  export type FanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanInclude<ExtArgs> | null
    /**
     * The filter to search for the Fan to update in case it exists.
     */
    where: FanWhereUniqueInput
    /**
     * In case the Fan found by the `where` argument doesn't exist, create a new Fan with this data.
     */
    create: XOR<FanCreateInput, FanUncheckedCreateInput>
    /**
     * In case the Fan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FanUpdateInput, FanUncheckedUpdateInput>
  }

  /**
   * Fan delete
   */
  export type FanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanInclude<ExtArgs> | null
    /**
     * Filter which Fan to delete.
     */
    where: FanWhereUniqueInput
  }

  /**
   * Fan deleteMany
   */
  export type FanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fans to delete
     */
    where?: FanWhereInput
  }

  /**
   * Fan.subscriptions
   */
  export type Fan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Fan.purchases
   */
  export type Fan$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Fan.transactions
   */
  export type Fan$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Fan.fanRelations
   */
  export type Fan$fanRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
    where?: FanRelationWhereInput
    orderBy?: FanRelationOrderByWithRelationInput | FanRelationOrderByWithRelationInput[]
    cursor?: FanRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FanRelationScalarFieldEnum | FanRelationScalarFieldEnum[]
  }

  /**
   * Fan.campaignRecipients
   */
  export type Fan$campaignRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    where?: CampaignRecipientWhereInput
    orderBy?: CampaignRecipientOrderByWithRelationInput | CampaignRecipientOrderByWithRelationInput[]
    cursor?: CampaignRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignRecipientScalarFieldEnum | CampaignRecipientScalarFieldEnum[]
  }

  /**
   * Fan without action
   */
  export type FanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    totalSpent: Decimal | null
    renewalCount: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    totalSpent: Decimal | null
    renewalCount: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    fanId: string | null
    creatorId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    endedAt: Date | null
    stripeSubscriptionId: string | null
    totalSpent: Decimal | null
    renewalCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    fanId: string | null
    creatorId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    endedAt: Date | null
    stripeSubscriptionId: string | null
    totalSpent: Decimal | null
    renewalCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    fanId: number
    creatorId: number
    planId: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    canceledAt: number
    endedAt: number
    stripeSubscriptionId: number
    totalSpent: number
    renewalCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    totalSpent?: true
    renewalCount?: true
  }

  export type SubscriptionSumAggregateInputType = {
    totalSpent?: true
    renewalCount?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    fanId?: true
    creatorId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    endedAt?: true
    stripeSubscriptionId?: true
    totalSpent?: true
    renewalCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    fanId?: true
    creatorId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    endedAt?: true
    stripeSubscriptionId?: true
    totalSpent?: true
    renewalCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    fanId?: true
    creatorId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    endedAt?: true
    stripeSubscriptionId?: true
    totalSpent?: true
    renewalCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    fanId: string
    creatorId: string
    planId: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelAtPeriodEnd: boolean
    canceledAt: Date | null
    endedAt: Date | null
    stripeSubscriptionId: string | null
    totalSpent: Decimal
    renewalCount: number
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fanId?: boolean
    creatorId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    endedAt?: boolean
    stripeSubscriptionId?: boolean
    totalSpent?: boolean
    renewalCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fan?: boolean | FanDefaultArgs<ExtArgs>
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fanId?: boolean
    creatorId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    endedAt?: boolean
    stripeSubscriptionId?: boolean
    totalSpent?: boolean
    renewalCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fan?: boolean | FanDefaultArgs<ExtArgs>
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    fanId?: boolean
    creatorId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    endedAt?: boolean
    stripeSubscriptionId?: boolean
    totalSpent?: boolean
    renewalCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fan?: boolean | FanDefaultArgs<ExtArgs>
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fan?: boolean | FanDefaultArgs<ExtArgs>
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      fan: Prisma.$FanPayload<ExtArgs>
      creator: Prisma.$CreatorPayload<ExtArgs>
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fanId: string
      creatorId: string
      planId: string
      status: $Enums.SubscriptionStatus
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelAtPeriodEnd: boolean
      canceledAt: Date | null
      endedAt: Date | null
      stripeSubscriptionId: string | null
      totalSpent: Prisma.Decimal
      renewalCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fan<T extends FanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FanDefaultArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends CreatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatorDefaultArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly fanId: FieldRef<"Subscription", 'String'>
    readonly creatorId: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly endedAt: FieldRef<"Subscription", 'DateTime'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly totalSpent: FieldRef<"Subscription", 'Decimal'>
    readonly renewalCount: FieldRef<"Subscription", 'Int'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    amount: Decimal | null
    downloadCount: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    amount: Decimal | null
    downloadCount: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    fanId: string | null
    productId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PurchaseStatus | null
    stripePaymentIntentId: string | null
    downloadCount: number | null
    lastDownloadAt: Date | null
    createdAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    fanId: string | null
    productId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PurchaseStatus | null
    stripePaymentIntentId: string | null
    downloadCount: number | null
    lastDownloadAt: Date | null
    createdAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    fanId: number
    productId: number
    amount: number
    currency: number
    status: number
    stripePaymentIntentId: number
    downloadCount: number
    lastDownloadAt: number
    createdAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    amount?: true
    downloadCount?: true
  }

  export type PurchaseSumAggregateInputType = {
    amount?: true
    downloadCount?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    fanId?: true
    productId?: true
    amount?: true
    currency?: true
    status?: true
    stripePaymentIntentId?: true
    downloadCount?: true
    lastDownloadAt?: true
    createdAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    fanId?: true
    productId?: true
    amount?: true
    currency?: true
    status?: true
    stripePaymentIntentId?: true
    downloadCount?: true
    lastDownloadAt?: true
    createdAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    fanId?: true
    productId?: true
    amount?: true
    currency?: true
    status?: true
    stripePaymentIntentId?: true
    downloadCount?: true
    lastDownloadAt?: true
    createdAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    fanId: string
    productId: string
    amount: Decimal
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId: string | null
    downloadCount: number
    lastDownloadAt: Date | null
    createdAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fanId?: boolean
    productId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripePaymentIntentId?: boolean
    downloadCount?: boolean
    lastDownloadAt?: boolean
    createdAt?: boolean
    fan?: boolean | FanDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    transaction?: boolean | Purchase$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fanId?: boolean
    productId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripePaymentIntentId?: boolean
    downloadCount?: boolean
    lastDownloadAt?: boolean
    createdAt?: boolean
    fan?: boolean | FanDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    fanId?: boolean
    productId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripePaymentIntentId?: boolean
    downloadCount?: boolean
    lastDownloadAt?: boolean
    createdAt?: boolean
  }

  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fan?: boolean | FanDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    transaction?: boolean | Purchase$transactionArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fan?: boolean | FanDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      fan: Prisma.$FanPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fanId: string
      productId: string
      amount: Prisma.Decimal
      currency: string
      status: $Enums.PurchaseStatus
      stripePaymentIntentId: string | null
      downloadCount: number
      lastDownloadAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fan<T extends FanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FanDefaultArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transaction<T extends Purchase$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */ 
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly fanId: FieldRef<"Purchase", 'String'>
    readonly productId: FieldRef<"Purchase", 'String'>
    readonly amount: FieldRef<"Purchase", 'Decimal'>
    readonly currency: FieldRef<"Purchase", 'String'>
    readonly status: FieldRef<"Purchase", 'PurchaseStatus'>
    readonly stripePaymentIntentId: FieldRef<"Purchase", 'String'>
    readonly downloadCount: FieldRef<"Purchase", 'Int'>
    readonly lastDownloadAt: FieldRef<"Purchase", 'DateTime'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase.transaction
   */
  export type Purchase$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
    platformFee: Decimal | null
    platformFeeRate: Decimal | null
    netAmount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
    platformFee: Decimal | null
    platformFeeRate: Decimal | null
    netAmount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    fanId: string | null
    type: $Enums.TransactionType | null
    amount: Decimal | null
    currency: string | null
    platformFee: Decimal | null
    platformFeeRate: Decimal | null
    netAmount: Decimal | null
    status: $Enums.TransactionStatus | null
    subscriptionId: string | null
    purchaseId: string | null
    payoutId: string | null
    stripeTransferId: string | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    fanId: string | null
    type: $Enums.TransactionType | null
    amount: Decimal | null
    currency: string | null
    platformFee: Decimal | null
    platformFeeRate: Decimal | null
    netAmount: Decimal | null
    status: $Enums.TransactionStatus | null
    subscriptionId: string | null
    purchaseId: string | null
    payoutId: string | null
    stripeTransferId: string | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    creatorId: number
    fanId: number
    type: number
    amount: number
    currency: number
    platformFee: number
    platformFeeRate: number
    netAmount: number
    status: number
    subscriptionId: number
    purchaseId: number
    payoutId: number
    stripeTransferId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    platformFee?: true
    platformFeeRate?: true
    netAmount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    platformFee?: true
    platformFeeRate?: true
    netAmount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    creatorId?: true
    fanId?: true
    type?: true
    amount?: true
    currency?: true
    platformFee?: true
    platformFeeRate?: true
    netAmount?: true
    status?: true
    subscriptionId?: true
    purchaseId?: true
    payoutId?: true
    stripeTransferId?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    creatorId?: true
    fanId?: true
    type?: true
    amount?: true
    currency?: true
    platformFee?: true
    platformFeeRate?: true
    netAmount?: true
    status?: true
    subscriptionId?: true
    purchaseId?: true
    payoutId?: true
    stripeTransferId?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    creatorId?: true
    fanId?: true
    type?: true
    amount?: true
    currency?: true
    platformFee?: true
    platformFeeRate?: true
    netAmount?: true
    status?: true
    subscriptionId?: true
    purchaseId?: true
    payoutId?: true
    stripeTransferId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    creatorId: string
    fanId: string | null
    type: $Enums.TransactionType
    amount: Decimal
    currency: string
    platformFee: Decimal
    platformFeeRate: Decimal
    netAmount: Decimal
    status: $Enums.TransactionStatus
    subscriptionId: string | null
    purchaseId: string | null
    payoutId: string | null
    stripeTransferId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    fanId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    platformFee?: boolean
    platformFeeRate?: boolean
    netAmount?: boolean
    status?: boolean
    subscriptionId?: boolean
    purchaseId?: boolean
    payoutId?: boolean
    stripeTransferId?: boolean
    metadata?: boolean
    createdAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    fan?: boolean | Transaction$fanArgs<ExtArgs>
    purchase?: boolean | Transaction$purchaseArgs<ExtArgs>
    payout?: boolean | Transaction$payoutArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    fanId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    platformFee?: boolean
    platformFeeRate?: boolean
    netAmount?: boolean
    status?: boolean
    subscriptionId?: boolean
    purchaseId?: boolean
    payoutId?: boolean
    stripeTransferId?: boolean
    metadata?: boolean
    createdAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    fan?: boolean | Transaction$fanArgs<ExtArgs>
    purchase?: boolean | Transaction$purchaseArgs<ExtArgs>
    payout?: boolean | Transaction$payoutArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    creatorId?: boolean
    fanId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    platformFee?: boolean
    platformFeeRate?: boolean
    netAmount?: boolean
    status?: boolean
    subscriptionId?: boolean
    purchaseId?: boolean
    payoutId?: boolean
    stripeTransferId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    fan?: boolean | Transaction$fanArgs<ExtArgs>
    purchase?: boolean | Transaction$purchaseArgs<ExtArgs>
    payout?: boolean | Transaction$payoutArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    fan?: boolean | Transaction$fanArgs<ExtArgs>
    purchase?: boolean | Transaction$purchaseArgs<ExtArgs>
    payout?: boolean | Transaction$payoutArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      creator: Prisma.$CreatorPayload<ExtArgs>
      fan: Prisma.$FanPayload<ExtArgs> | null
      purchase: Prisma.$PurchasePayload<ExtArgs> | null
      payout: Prisma.$PayoutPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      fanId: string | null
      type: $Enums.TransactionType
      amount: Prisma.Decimal
      currency: string
      platformFee: Prisma.Decimal
      platformFeeRate: Prisma.Decimal
      netAmount: Prisma.Decimal
      status: $Enums.TransactionStatus
      subscriptionId: string | null
      purchaseId: string | null
      payoutId: string | null
      stripeTransferId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends CreatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatorDefaultArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fan<T extends Transaction$fanArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$fanArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    purchase<T extends Transaction$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$purchaseArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    payout<T extends Transaction$payoutArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$payoutArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly creatorId: FieldRef<"Transaction", 'String'>
    readonly fanId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly platformFee: FieldRef<"Transaction", 'Decimal'>
    readonly platformFeeRate: FieldRef<"Transaction", 'Decimal'>
    readonly netAmount: FieldRef<"Transaction", 'Decimal'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly subscriptionId: FieldRef<"Transaction", 'String'>
    readonly purchaseId: FieldRef<"Transaction", 'String'>
    readonly payoutId: FieldRef<"Transaction", 'String'>
    readonly stripeTransferId: FieldRef<"Transaction", 'String'>
    readonly metadata: FieldRef<"Transaction", 'Json'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction.fan
   */
  export type Transaction$fanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fan
     */
    select?: FanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanInclude<ExtArgs> | null
    where?: FanWhereInput
  }

  /**
   * Transaction.purchase
   */
  export type Transaction$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
  }

  /**
   * Transaction.payout
   */
  export type Transaction$payoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    where?: PayoutWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Payout
   */

  export type AggregatePayout = {
    _count: PayoutCountAggregateOutputType | null
    _avg: PayoutAvgAggregateOutputType | null
    _sum: PayoutSumAggregateOutputType | null
    _min: PayoutMinAggregateOutputType | null
    _max: PayoutMaxAggregateOutputType | null
  }

  export type PayoutAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PayoutSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PayoutMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PayoutStatus | null
    method: $Enums.PayoutMethod | null
    destination: string | null
    stripePayoutId: string | null
    processedAt: Date | null
    failureReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayoutMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PayoutStatus | null
    method: $Enums.PayoutMethod | null
    destination: string | null
    stripePayoutId: string | null
    processedAt: Date | null
    failureReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayoutCountAggregateOutputType = {
    id: number
    creatorId: number
    amount: number
    currency: number
    status: number
    method: number
    destination: number
    stripePayoutId: number
    processedAt: number
    failureReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayoutAvgAggregateInputType = {
    amount?: true
  }

  export type PayoutSumAggregateInputType = {
    amount?: true
  }

  export type PayoutMinAggregateInputType = {
    id?: true
    creatorId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    destination?: true
    stripePayoutId?: true
    processedAt?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayoutMaxAggregateInputType = {
    id?: true
    creatorId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    destination?: true
    stripePayoutId?: true
    processedAt?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayoutCountAggregateInputType = {
    id?: true
    creatorId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    destination?: true
    stripePayoutId?: true
    processedAt?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payout to aggregate.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payouts
    **/
    _count?: true | PayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayoutMaxAggregateInputType
  }

  export type GetPayoutAggregateType<T extends PayoutAggregateArgs> = {
        [P in keyof T & keyof AggregatePayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayout[P]>
      : GetScalarType<T[P], AggregatePayout[P]>
  }




  export type PayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayoutWhereInput
    orderBy?: PayoutOrderByWithAggregationInput | PayoutOrderByWithAggregationInput[]
    by: PayoutScalarFieldEnum[] | PayoutScalarFieldEnum
    having?: PayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayoutCountAggregateInputType | true
    _avg?: PayoutAvgAggregateInputType
    _sum?: PayoutSumAggregateInputType
    _min?: PayoutMinAggregateInputType
    _max?: PayoutMaxAggregateInputType
  }

  export type PayoutGroupByOutputType = {
    id: string
    creatorId: string
    amount: Decimal
    currency: string
    status: $Enums.PayoutStatus
    method: $Enums.PayoutMethod
    destination: string | null
    stripePayoutId: string | null
    processedAt: Date | null
    failureReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: PayoutCountAggregateOutputType | null
    _avg: PayoutAvgAggregateOutputType | null
    _sum: PayoutSumAggregateOutputType | null
    _min: PayoutMinAggregateOutputType | null
    _max: PayoutMaxAggregateOutputType | null
  }

  type GetPayoutGroupByPayload<T extends PayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayoutGroupByOutputType[P]>
            : GetScalarType<T[P], PayoutGroupByOutputType[P]>
        }
      >
    >


  export type PayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    destination?: boolean
    stripePayoutId?: boolean
    processedAt?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    transactions?: boolean | Payout$transactionsArgs<ExtArgs>
    _count?: boolean | PayoutCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payout"]>

  export type PayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    destination?: boolean
    stripePayoutId?: boolean
    processedAt?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payout"]>

  export type PayoutSelectScalar = {
    id?: boolean
    creatorId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    destination?: boolean
    stripePayoutId?: boolean
    processedAt?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    transactions?: boolean | Payout$transactionsArgs<ExtArgs>
    _count?: boolean | PayoutCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }

  export type $PayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payout"
    objects: {
      creator: Prisma.$CreatorPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      amount: Prisma.Decimal
      currency: string
      status: $Enums.PayoutStatus
      method: $Enums.PayoutMethod
      destination: string | null
      stripePayoutId: string | null
      processedAt: Date | null
      failureReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payout"]>
    composites: {}
  }

  type PayoutGetPayload<S extends boolean | null | undefined | PayoutDefaultArgs> = $Result.GetResult<Prisma.$PayoutPayload, S>

  type PayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PayoutFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PayoutCountAggregateInputType | true
    }

  export interface PayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payout'], meta: { name: 'Payout' } }
    /**
     * Find zero or one Payout that matches the filter.
     * @param {PayoutFindUniqueArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayoutFindUniqueArgs>(args: SelectSubset<T, PayoutFindUniqueArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payout that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PayoutFindUniqueOrThrowArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, PayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindFirstArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayoutFindFirstArgs>(args?: SelectSubset<T, PayoutFindFirstArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindFirstOrThrowArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, PayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payouts
     * const payouts = await prisma.payout.findMany()
     * 
     * // Get first 10 Payouts
     * const payouts = await prisma.payout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payoutWithIdOnly = await prisma.payout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayoutFindManyArgs>(args?: SelectSubset<T, PayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payout.
     * @param {PayoutCreateArgs} args - Arguments to create a Payout.
     * @example
     * // Create one Payout
     * const Payout = await prisma.payout.create({
     *   data: {
     *     // ... data to create a Payout
     *   }
     * })
     * 
     */
    create<T extends PayoutCreateArgs>(args: SelectSubset<T, PayoutCreateArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payouts.
     * @param {PayoutCreateManyArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payout = await prisma.payout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayoutCreateManyArgs>(args?: SelectSubset<T, PayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payouts and returns the data saved in the database.
     * @param {PayoutCreateManyAndReturnArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payout = await prisma.payout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payouts and only return the `id`
     * const payoutWithIdOnly = await prisma.payout.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, PayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payout.
     * @param {PayoutDeleteArgs} args - Arguments to delete one Payout.
     * @example
     * // Delete one Payout
     * const Payout = await prisma.payout.delete({
     *   where: {
     *     // ... filter to delete one Payout
     *   }
     * })
     * 
     */
    delete<T extends PayoutDeleteArgs>(args: SelectSubset<T, PayoutDeleteArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payout.
     * @param {PayoutUpdateArgs} args - Arguments to update one Payout.
     * @example
     * // Update one Payout
     * const payout = await prisma.payout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayoutUpdateArgs>(args: SelectSubset<T, PayoutUpdateArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payouts.
     * @param {PayoutDeleteManyArgs} args - Arguments to filter Payouts to delete.
     * @example
     * // Delete a few Payouts
     * const { count } = await prisma.payout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayoutDeleteManyArgs>(args?: SelectSubset<T, PayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payouts
     * const payout = await prisma.payout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayoutUpdateManyArgs>(args: SelectSubset<T, PayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payout.
     * @param {PayoutUpsertArgs} args - Arguments to update or create a Payout.
     * @example
     * // Update or create a Payout
     * const payout = await prisma.payout.upsert({
     *   create: {
     *     // ... data to create a Payout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payout we want to update
     *   }
     * })
     */
    upsert<T extends PayoutUpsertArgs>(args: SelectSubset<T, PayoutUpsertArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutCountArgs} args - Arguments to filter Payouts to count.
     * @example
     * // Count the number of Payouts
     * const count = await prisma.payout.count({
     *   where: {
     *     // ... the filter for the Payouts we want to count
     *   }
     * })
    **/
    count<T extends PayoutCountArgs>(
      args?: Subset<T, PayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayoutAggregateArgs>(args: Subset<T, PayoutAggregateArgs>): Prisma.PrismaPromise<GetPayoutAggregateType<T>>

    /**
     * Group by Payout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayoutGroupByArgs['orderBy'] }
        : { orderBy?: PayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payout model
   */
  readonly fields: PayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends CreatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatorDefaultArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends Payout$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Payout$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payout model
   */ 
  interface PayoutFieldRefs {
    readonly id: FieldRef<"Payout", 'String'>
    readonly creatorId: FieldRef<"Payout", 'String'>
    readonly amount: FieldRef<"Payout", 'Decimal'>
    readonly currency: FieldRef<"Payout", 'String'>
    readonly status: FieldRef<"Payout", 'PayoutStatus'>
    readonly method: FieldRef<"Payout", 'PayoutMethod'>
    readonly destination: FieldRef<"Payout", 'String'>
    readonly stripePayoutId: FieldRef<"Payout", 'String'>
    readonly processedAt: FieldRef<"Payout", 'DateTime'>
    readonly failureReason: FieldRef<"Payout", 'String'>
    readonly createdAt: FieldRef<"Payout", 'DateTime'>
    readonly updatedAt: FieldRef<"Payout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payout findUnique
   */
  export type PayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout findUniqueOrThrow
   */
  export type PayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout findFirst
   */
  export type PayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout findFirstOrThrow
   */
  export type PayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout findMany
   */
  export type PayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payouts to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout create
   */
  export type PayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a Payout.
     */
    data: XOR<PayoutCreateInput, PayoutUncheckedCreateInput>
  }

  /**
   * Payout createMany
   */
  export type PayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payouts.
     */
    data: PayoutCreateManyInput | PayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payout createManyAndReturn
   */
  export type PayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payouts.
     */
    data: PayoutCreateManyInput | PayoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payout update
   */
  export type PayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a Payout.
     */
    data: XOR<PayoutUpdateInput, PayoutUncheckedUpdateInput>
    /**
     * Choose, which Payout to update.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout updateMany
   */
  export type PayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payouts.
     */
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyInput>
    /**
     * Filter which Payouts to update
     */
    where?: PayoutWhereInput
  }

  /**
   * Payout upsert
   */
  export type PayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the Payout to update in case it exists.
     */
    where: PayoutWhereUniqueInput
    /**
     * In case the Payout found by the `where` argument doesn't exist, create a new Payout with this data.
     */
    create: XOR<PayoutCreateInput, PayoutUncheckedCreateInput>
    /**
     * In case the Payout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayoutUpdateInput, PayoutUncheckedUpdateInput>
  }

  /**
   * Payout delete
   */
  export type PayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter which Payout to delete.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout deleteMany
   */
  export type PayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payouts to delete
     */
    where?: PayoutWhereInput
  }

  /**
   * Payout.transactions
   */
  export type Payout$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Payout without action
   */
  export type PayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
  }


  /**
   * Model Analytics
   */

  export type AggregateAnalytics = {
    _count: AnalyticsCountAggregateOutputType | null
    _avg: AnalyticsAvgAggregateOutputType | null
    _sum: AnalyticsSumAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  export type AnalyticsAvgAggregateOutputType = {
    revenue: Decimal | null
    subscriptionRevenue: Decimal | null
    productRevenue: Decimal | null
    newSubscribers: number | null
    churned: number | null
    activeSubscribers: number | null
    pageViews: number | null
    uniqueVisitors: number | null
    contentViews: number | null
    conversionRate: Decimal | null
    avgOrderValue: Decimal | null
  }

  export type AnalyticsSumAggregateOutputType = {
    revenue: Decimal | null
    subscriptionRevenue: Decimal | null
    productRevenue: Decimal | null
    newSubscribers: number | null
    churned: number | null
    activeSubscribers: number | null
    pageViews: number | null
    uniqueVisitors: number | null
    contentViews: number | null
    conversionRate: Decimal | null
    avgOrderValue: Decimal | null
  }

  export type AnalyticsMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    date: Date | null
    revenue: Decimal | null
    subscriptionRevenue: Decimal | null
    productRevenue: Decimal | null
    newSubscribers: number | null
    churned: number | null
    activeSubscribers: number | null
    pageViews: number | null
    uniqueVisitors: number | null
    contentViews: number | null
    conversionRate: Decimal | null
    avgOrderValue: Decimal | null
    createdAt: Date | null
  }

  export type AnalyticsMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    date: Date | null
    revenue: Decimal | null
    subscriptionRevenue: Decimal | null
    productRevenue: Decimal | null
    newSubscribers: number | null
    churned: number | null
    activeSubscribers: number | null
    pageViews: number | null
    uniqueVisitors: number | null
    contentViews: number | null
    conversionRate: Decimal | null
    avgOrderValue: Decimal | null
    createdAt: Date | null
  }

  export type AnalyticsCountAggregateOutputType = {
    id: number
    creatorId: number
    date: number
    revenue: number
    subscriptionRevenue: number
    productRevenue: number
    newSubscribers: number
    churned: number
    activeSubscribers: number
    pageViews: number
    uniqueVisitors: number
    contentViews: number
    conversionRate: number
    avgOrderValue: number
    createdAt: number
    _all: number
  }


  export type AnalyticsAvgAggregateInputType = {
    revenue?: true
    subscriptionRevenue?: true
    productRevenue?: true
    newSubscribers?: true
    churned?: true
    activeSubscribers?: true
    pageViews?: true
    uniqueVisitors?: true
    contentViews?: true
    conversionRate?: true
    avgOrderValue?: true
  }

  export type AnalyticsSumAggregateInputType = {
    revenue?: true
    subscriptionRevenue?: true
    productRevenue?: true
    newSubscribers?: true
    churned?: true
    activeSubscribers?: true
    pageViews?: true
    uniqueVisitors?: true
    contentViews?: true
    conversionRate?: true
    avgOrderValue?: true
  }

  export type AnalyticsMinAggregateInputType = {
    id?: true
    creatorId?: true
    date?: true
    revenue?: true
    subscriptionRevenue?: true
    productRevenue?: true
    newSubscribers?: true
    churned?: true
    activeSubscribers?: true
    pageViews?: true
    uniqueVisitors?: true
    contentViews?: true
    conversionRate?: true
    avgOrderValue?: true
    createdAt?: true
  }

  export type AnalyticsMaxAggregateInputType = {
    id?: true
    creatorId?: true
    date?: true
    revenue?: true
    subscriptionRevenue?: true
    productRevenue?: true
    newSubscribers?: true
    churned?: true
    activeSubscribers?: true
    pageViews?: true
    uniqueVisitors?: true
    contentViews?: true
    conversionRate?: true
    avgOrderValue?: true
    createdAt?: true
  }

  export type AnalyticsCountAggregateInputType = {
    id?: true
    creatorId?: true
    date?: true
    revenue?: true
    subscriptionRevenue?: true
    productRevenue?: true
    newSubscribers?: true
    churned?: true
    activeSubscribers?: true
    pageViews?: true
    uniqueVisitors?: true
    contentViews?: true
    conversionRate?: true
    avgOrderValue?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to aggregate.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Analytics
    **/
    _count?: true | AnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsMaxAggregateInputType
  }

  export type GetAnalyticsAggregateType<T extends AnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalytics[P]>
      : GetScalarType<T[P], AggregateAnalytics[P]>
  }




  export type AnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsWhereInput
    orderBy?: AnalyticsOrderByWithAggregationInput | AnalyticsOrderByWithAggregationInput[]
    by: AnalyticsScalarFieldEnum[] | AnalyticsScalarFieldEnum
    having?: AnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsCountAggregateInputType | true
    _avg?: AnalyticsAvgAggregateInputType
    _sum?: AnalyticsSumAggregateInputType
    _min?: AnalyticsMinAggregateInputType
    _max?: AnalyticsMaxAggregateInputType
  }

  export type AnalyticsGroupByOutputType = {
    id: string
    creatorId: string
    date: Date
    revenue: Decimal
    subscriptionRevenue: Decimal
    productRevenue: Decimal
    newSubscribers: number
    churned: number
    activeSubscribers: number
    pageViews: number
    uniqueVisitors: number
    contentViews: number
    conversionRate: Decimal | null
    avgOrderValue: Decimal | null
    createdAt: Date
    _count: AnalyticsCountAggregateOutputType | null
    _avg: AnalyticsAvgAggregateOutputType | null
    _sum: AnalyticsSumAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  type GetAnalyticsGroupByPayload<T extends AnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    date?: boolean
    revenue?: boolean
    subscriptionRevenue?: boolean
    productRevenue?: boolean
    newSubscribers?: boolean
    churned?: boolean
    activeSubscribers?: boolean
    pageViews?: boolean
    uniqueVisitors?: boolean
    contentViews?: boolean
    conversionRate?: boolean
    avgOrderValue?: boolean
    createdAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    date?: boolean
    revenue?: boolean
    subscriptionRevenue?: boolean
    productRevenue?: boolean
    newSubscribers?: boolean
    churned?: boolean
    activeSubscribers?: boolean
    pageViews?: boolean
    uniqueVisitors?: boolean
    contentViews?: boolean
    conversionRate?: boolean
    avgOrderValue?: boolean
    createdAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectScalar = {
    id?: boolean
    creatorId?: boolean
    date?: boolean
    revenue?: boolean
    subscriptionRevenue?: boolean
    productRevenue?: boolean
    newSubscribers?: boolean
    churned?: boolean
    activeSubscribers?: boolean
    pageViews?: boolean
    uniqueVisitors?: boolean
    contentViews?: boolean
    conversionRate?: boolean
    avgOrderValue?: boolean
    createdAt?: boolean
  }

  export type AnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }
  export type AnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }

  export type $AnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Analytics"
    objects: {
      creator: Prisma.$CreatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      date: Date
      revenue: Prisma.Decimal
      subscriptionRevenue: Prisma.Decimal
      productRevenue: Prisma.Decimal
      newSubscribers: number
      churned: number
      activeSubscribers: number
      pageViews: number
      uniqueVisitors: number
      contentViews: number
      conversionRate: Prisma.Decimal | null
      avgOrderValue: Prisma.Decimal | null
      createdAt: Date
    }, ExtArgs["result"]["analytics"]>
    composites: {}
  }

  type AnalyticsGetPayload<S extends boolean | null | undefined | AnalyticsDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsPayload, S>

  type AnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalyticsCountAggregateInputType | true
    }

  export interface AnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Analytics'], meta: { name: 'Analytics' } }
    /**
     * Find zero or one Analytics that matches the filter.
     * @param {AnalyticsFindUniqueArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsFindUniqueArgs>(args: SelectSubset<T, AnalyticsFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Analytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnalyticsFindUniqueOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsFindFirstArgs>(args?: SelectSubset<T, AnalyticsFindFirstArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Analytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analytics
     * const analytics = await prisma.analytics.findMany()
     * 
     * // Get first 10 Analytics
     * const analytics = await prisma.analytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsWithIdOnly = await prisma.analytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsFindManyArgs>(args?: SelectSubset<T, AnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Analytics.
     * @param {AnalyticsCreateArgs} args - Arguments to create a Analytics.
     * @example
     * // Create one Analytics
     * const Analytics = await prisma.analytics.create({
     *   data: {
     *     // ... data to create a Analytics
     *   }
     * })
     * 
     */
    create<T extends AnalyticsCreateArgs>(args: SelectSubset<T, AnalyticsCreateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Analytics.
     * @param {AnalyticsCreateManyArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsCreateManyArgs>(args?: SelectSubset<T, AnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Analytics and returns the data saved in the database.
     * @param {AnalyticsCreateManyAndReturnArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Analytics.
     * @param {AnalyticsDeleteArgs} args - Arguments to delete one Analytics.
     * @example
     * // Delete one Analytics
     * const Analytics = await prisma.analytics.delete({
     *   where: {
     *     // ... filter to delete one Analytics
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsDeleteArgs>(args: SelectSubset<T, AnalyticsDeleteArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Analytics.
     * @param {AnalyticsUpdateArgs} args - Arguments to update one Analytics.
     * @example
     * // Update one Analytics
     * const analytics = await prisma.analytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsUpdateArgs>(args: SelectSubset<T, AnalyticsUpdateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Analytics.
     * @param {AnalyticsDeleteManyArgs} args - Arguments to filter Analytics to delete.
     * @example
     * // Delete a few Analytics
     * const { count } = await prisma.analytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsDeleteManyArgs>(args?: SelectSubset<T, AnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsUpdateManyArgs>(args: SelectSubset<T, AnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Analytics.
     * @param {AnalyticsUpsertArgs} args - Arguments to update or create a Analytics.
     * @example
     * // Update or create a Analytics
     * const analytics = await prisma.analytics.upsert({
     *   create: {
     *     // ... data to create a Analytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analytics we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsUpsertArgs>(args: SelectSubset<T, AnalyticsUpsertArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCountArgs} args - Arguments to filter Analytics to count.
     * @example
     * // Count the number of Analytics
     * const count = await prisma.analytics.count({
     *   where: {
     *     // ... the filter for the Analytics we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsCountArgs>(
      args?: Subset<T, AnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsAggregateArgs>(args: Subset<T, AnalyticsAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsAggregateType<T>>

    /**
     * Group by Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Analytics model
   */
  readonly fields: AnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Analytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends CreatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatorDefaultArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Analytics model
   */ 
  interface AnalyticsFieldRefs {
    readonly id: FieldRef<"Analytics", 'String'>
    readonly creatorId: FieldRef<"Analytics", 'String'>
    readonly date: FieldRef<"Analytics", 'DateTime'>
    readonly revenue: FieldRef<"Analytics", 'Decimal'>
    readonly subscriptionRevenue: FieldRef<"Analytics", 'Decimal'>
    readonly productRevenue: FieldRef<"Analytics", 'Decimal'>
    readonly newSubscribers: FieldRef<"Analytics", 'Int'>
    readonly churned: FieldRef<"Analytics", 'Int'>
    readonly activeSubscribers: FieldRef<"Analytics", 'Int'>
    readonly pageViews: FieldRef<"Analytics", 'Int'>
    readonly uniqueVisitors: FieldRef<"Analytics", 'Int'>
    readonly contentViews: FieldRef<"Analytics", 'Int'>
    readonly conversionRate: FieldRef<"Analytics", 'Decimal'>
    readonly avgOrderValue: FieldRef<"Analytics", 'Decimal'>
    readonly createdAt: FieldRef<"Analytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Analytics findUnique
   */
  export type AnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findUniqueOrThrow
   */
  export type AnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findFirst
   */
  export type AnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findFirstOrThrow
   */
  export type AnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findMany
   */
  export type AnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics create
   */
  export type AnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a Analytics.
     */
    data: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
  }

  /**
   * Analytics createMany
   */
  export type AnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analytics createManyAndReturn
   */
  export type AnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Analytics update
   */
  export type AnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a Analytics.
     */
    data: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
    /**
     * Choose, which Analytics to update.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics updateMany
   */
  export type AnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
  }

  /**
   * Analytics upsert
   */
  export type AnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the Analytics to update in case it exists.
     */
    where: AnalyticsWhereUniqueInput
    /**
     * In case the Analytics found by the `where` argument doesn't exist, create a new Analytics with this data.
     */
    create: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
    /**
     * In case the Analytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
  }

  /**
   * Analytics delete
   */
  export type AnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter which Analytics to delete.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics deleteMany
   */
  export type AnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to delete
     */
    where?: AnalyticsWhereInput
  }

  /**
   * Analytics without action
   */
  export type AnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model FanRelation
   */

  export type AggregateFanRelation = {
    _count: FanRelationCountAggregateOutputType | null
    _avg: FanRelationAvgAggregateOutputType | null
    _sum: FanRelationSumAggregateOutputType | null
    _min: FanRelationMinAggregateOutputType | null
    _max: FanRelationMaxAggregateOutputType | null
  }

  export type FanRelationAvgAggregateOutputType = {
    engagementScore: number | null
    lifetimeValue: Decimal | null
  }

  export type FanRelationSumAggregateOutputType = {
    engagementScore: number | null
    lifetimeValue: Decimal | null
  }

  export type FanRelationMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    fanId: string | null
    notes: string | null
    engagementScore: number | null
    lifetimeValue: Decimal | null
    lastInteraction: Date | null
    emailOptIn: boolean | null
    smsOptIn: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FanRelationMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    fanId: string | null
    notes: string | null
    engagementScore: number | null
    lifetimeValue: Decimal | null
    lastInteraction: Date | null
    emailOptIn: boolean | null
    smsOptIn: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FanRelationCountAggregateOutputType = {
    id: number
    creatorId: number
    fanId: number
    tags: number
    notes: number
    engagementScore: number
    lifetimeValue: number
    lastInteraction: number
    emailOptIn: number
    smsOptIn: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FanRelationAvgAggregateInputType = {
    engagementScore?: true
    lifetimeValue?: true
  }

  export type FanRelationSumAggregateInputType = {
    engagementScore?: true
    lifetimeValue?: true
  }

  export type FanRelationMinAggregateInputType = {
    id?: true
    creatorId?: true
    fanId?: true
    notes?: true
    engagementScore?: true
    lifetimeValue?: true
    lastInteraction?: true
    emailOptIn?: true
    smsOptIn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FanRelationMaxAggregateInputType = {
    id?: true
    creatorId?: true
    fanId?: true
    notes?: true
    engagementScore?: true
    lifetimeValue?: true
    lastInteraction?: true
    emailOptIn?: true
    smsOptIn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FanRelationCountAggregateInputType = {
    id?: true
    creatorId?: true
    fanId?: true
    tags?: true
    notes?: true
    engagementScore?: true
    lifetimeValue?: true
    lastInteraction?: true
    emailOptIn?: true
    smsOptIn?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FanRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FanRelation to aggregate.
     */
    where?: FanRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FanRelations to fetch.
     */
    orderBy?: FanRelationOrderByWithRelationInput | FanRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FanRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FanRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FanRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FanRelations
    **/
    _count?: true | FanRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FanRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FanRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FanRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FanRelationMaxAggregateInputType
  }

  export type GetFanRelationAggregateType<T extends FanRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateFanRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFanRelation[P]>
      : GetScalarType<T[P], AggregateFanRelation[P]>
  }




  export type FanRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FanRelationWhereInput
    orderBy?: FanRelationOrderByWithAggregationInput | FanRelationOrderByWithAggregationInput[]
    by: FanRelationScalarFieldEnum[] | FanRelationScalarFieldEnum
    having?: FanRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FanRelationCountAggregateInputType | true
    _avg?: FanRelationAvgAggregateInputType
    _sum?: FanRelationSumAggregateInputType
    _min?: FanRelationMinAggregateInputType
    _max?: FanRelationMaxAggregateInputType
  }

  export type FanRelationGroupByOutputType = {
    id: string
    creatorId: string
    fanId: string
    tags: string[]
    notes: string | null
    engagementScore: number
    lifetimeValue: Decimal
    lastInteraction: Date | null
    emailOptIn: boolean
    smsOptIn: boolean
    createdAt: Date
    updatedAt: Date
    _count: FanRelationCountAggregateOutputType | null
    _avg: FanRelationAvgAggregateOutputType | null
    _sum: FanRelationSumAggregateOutputType | null
    _min: FanRelationMinAggregateOutputType | null
    _max: FanRelationMaxAggregateOutputType | null
  }

  type GetFanRelationGroupByPayload<T extends FanRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FanRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FanRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FanRelationGroupByOutputType[P]>
            : GetScalarType<T[P], FanRelationGroupByOutputType[P]>
        }
      >
    >


  export type FanRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    fanId?: boolean
    tags?: boolean
    notes?: boolean
    engagementScore?: boolean
    lifetimeValue?: boolean
    lastInteraction?: boolean
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    fan?: boolean | FanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fanRelation"]>

  export type FanRelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    fanId?: boolean
    tags?: boolean
    notes?: boolean
    engagementScore?: boolean
    lifetimeValue?: boolean
    lastInteraction?: boolean
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    fan?: boolean | FanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fanRelation"]>

  export type FanRelationSelectScalar = {
    id?: boolean
    creatorId?: boolean
    fanId?: boolean
    tags?: boolean
    notes?: boolean
    engagementScore?: boolean
    lifetimeValue?: boolean
    lastInteraction?: boolean
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FanRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    fan?: boolean | FanDefaultArgs<ExtArgs>
  }
  export type FanRelationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    fan?: boolean | FanDefaultArgs<ExtArgs>
  }

  export type $FanRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FanRelation"
    objects: {
      creator: Prisma.$CreatorPayload<ExtArgs>
      fan: Prisma.$FanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      fanId: string
      tags: string[]
      notes: string | null
      engagementScore: number
      lifetimeValue: Prisma.Decimal
      lastInteraction: Date | null
      emailOptIn: boolean
      smsOptIn: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fanRelation"]>
    composites: {}
  }

  type FanRelationGetPayload<S extends boolean | null | undefined | FanRelationDefaultArgs> = $Result.GetResult<Prisma.$FanRelationPayload, S>

  type FanRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FanRelationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FanRelationCountAggregateInputType | true
    }

  export interface FanRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FanRelation'], meta: { name: 'FanRelation' } }
    /**
     * Find zero or one FanRelation that matches the filter.
     * @param {FanRelationFindUniqueArgs} args - Arguments to find a FanRelation
     * @example
     * // Get one FanRelation
     * const fanRelation = await prisma.fanRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FanRelationFindUniqueArgs>(args: SelectSubset<T, FanRelationFindUniqueArgs<ExtArgs>>): Prisma__FanRelationClient<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FanRelation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FanRelationFindUniqueOrThrowArgs} args - Arguments to find a FanRelation
     * @example
     * // Get one FanRelation
     * const fanRelation = await prisma.fanRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FanRelationFindUniqueOrThrowArgs>(args: SelectSubset<T, FanRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FanRelationClient<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FanRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanRelationFindFirstArgs} args - Arguments to find a FanRelation
     * @example
     * // Get one FanRelation
     * const fanRelation = await prisma.fanRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FanRelationFindFirstArgs>(args?: SelectSubset<T, FanRelationFindFirstArgs<ExtArgs>>): Prisma__FanRelationClient<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FanRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanRelationFindFirstOrThrowArgs} args - Arguments to find a FanRelation
     * @example
     * // Get one FanRelation
     * const fanRelation = await prisma.fanRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FanRelationFindFirstOrThrowArgs>(args?: SelectSubset<T, FanRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FanRelationClient<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FanRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FanRelations
     * const fanRelations = await prisma.fanRelation.findMany()
     * 
     * // Get first 10 FanRelations
     * const fanRelations = await prisma.fanRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fanRelationWithIdOnly = await prisma.fanRelation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FanRelationFindManyArgs>(args?: SelectSubset<T, FanRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FanRelation.
     * @param {FanRelationCreateArgs} args - Arguments to create a FanRelation.
     * @example
     * // Create one FanRelation
     * const FanRelation = await prisma.fanRelation.create({
     *   data: {
     *     // ... data to create a FanRelation
     *   }
     * })
     * 
     */
    create<T extends FanRelationCreateArgs>(args: SelectSubset<T, FanRelationCreateArgs<ExtArgs>>): Prisma__FanRelationClient<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FanRelations.
     * @param {FanRelationCreateManyArgs} args - Arguments to create many FanRelations.
     * @example
     * // Create many FanRelations
     * const fanRelation = await prisma.fanRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FanRelationCreateManyArgs>(args?: SelectSubset<T, FanRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FanRelations and returns the data saved in the database.
     * @param {FanRelationCreateManyAndReturnArgs} args - Arguments to create many FanRelations.
     * @example
     * // Create many FanRelations
     * const fanRelation = await prisma.fanRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FanRelations and only return the `id`
     * const fanRelationWithIdOnly = await prisma.fanRelation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FanRelationCreateManyAndReturnArgs>(args?: SelectSubset<T, FanRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FanRelation.
     * @param {FanRelationDeleteArgs} args - Arguments to delete one FanRelation.
     * @example
     * // Delete one FanRelation
     * const FanRelation = await prisma.fanRelation.delete({
     *   where: {
     *     // ... filter to delete one FanRelation
     *   }
     * })
     * 
     */
    delete<T extends FanRelationDeleteArgs>(args: SelectSubset<T, FanRelationDeleteArgs<ExtArgs>>): Prisma__FanRelationClient<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FanRelation.
     * @param {FanRelationUpdateArgs} args - Arguments to update one FanRelation.
     * @example
     * // Update one FanRelation
     * const fanRelation = await prisma.fanRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FanRelationUpdateArgs>(args: SelectSubset<T, FanRelationUpdateArgs<ExtArgs>>): Prisma__FanRelationClient<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FanRelations.
     * @param {FanRelationDeleteManyArgs} args - Arguments to filter FanRelations to delete.
     * @example
     * // Delete a few FanRelations
     * const { count } = await prisma.fanRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FanRelationDeleteManyArgs>(args?: SelectSubset<T, FanRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FanRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FanRelations
     * const fanRelation = await prisma.fanRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FanRelationUpdateManyArgs>(args: SelectSubset<T, FanRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FanRelation.
     * @param {FanRelationUpsertArgs} args - Arguments to update or create a FanRelation.
     * @example
     * // Update or create a FanRelation
     * const fanRelation = await prisma.fanRelation.upsert({
     *   create: {
     *     // ... data to create a FanRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FanRelation we want to update
     *   }
     * })
     */
    upsert<T extends FanRelationUpsertArgs>(args: SelectSubset<T, FanRelationUpsertArgs<ExtArgs>>): Prisma__FanRelationClient<$Result.GetResult<Prisma.$FanRelationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FanRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanRelationCountArgs} args - Arguments to filter FanRelations to count.
     * @example
     * // Count the number of FanRelations
     * const count = await prisma.fanRelation.count({
     *   where: {
     *     // ... the filter for the FanRelations we want to count
     *   }
     * })
    **/
    count<T extends FanRelationCountArgs>(
      args?: Subset<T, FanRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FanRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FanRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FanRelationAggregateArgs>(args: Subset<T, FanRelationAggregateArgs>): Prisma.PrismaPromise<GetFanRelationAggregateType<T>>

    /**
     * Group by FanRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FanRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FanRelationGroupByArgs['orderBy'] }
        : { orderBy?: FanRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FanRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFanRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FanRelation model
   */
  readonly fields: FanRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FanRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FanRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends CreatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatorDefaultArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fan<T extends FanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FanDefaultArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FanRelation model
   */ 
  interface FanRelationFieldRefs {
    readonly id: FieldRef<"FanRelation", 'String'>
    readonly creatorId: FieldRef<"FanRelation", 'String'>
    readonly fanId: FieldRef<"FanRelation", 'String'>
    readonly tags: FieldRef<"FanRelation", 'String[]'>
    readonly notes: FieldRef<"FanRelation", 'String'>
    readonly engagementScore: FieldRef<"FanRelation", 'Int'>
    readonly lifetimeValue: FieldRef<"FanRelation", 'Decimal'>
    readonly lastInteraction: FieldRef<"FanRelation", 'DateTime'>
    readonly emailOptIn: FieldRef<"FanRelation", 'Boolean'>
    readonly smsOptIn: FieldRef<"FanRelation", 'Boolean'>
    readonly createdAt: FieldRef<"FanRelation", 'DateTime'>
    readonly updatedAt: FieldRef<"FanRelation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FanRelation findUnique
   */
  export type FanRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
    /**
     * Filter, which FanRelation to fetch.
     */
    where: FanRelationWhereUniqueInput
  }

  /**
   * FanRelation findUniqueOrThrow
   */
  export type FanRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
    /**
     * Filter, which FanRelation to fetch.
     */
    where: FanRelationWhereUniqueInput
  }

  /**
   * FanRelation findFirst
   */
  export type FanRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
    /**
     * Filter, which FanRelation to fetch.
     */
    where?: FanRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FanRelations to fetch.
     */
    orderBy?: FanRelationOrderByWithRelationInput | FanRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FanRelations.
     */
    cursor?: FanRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FanRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FanRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FanRelations.
     */
    distinct?: FanRelationScalarFieldEnum | FanRelationScalarFieldEnum[]
  }

  /**
   * FanRelation findFirstOrThrow
   */
  export type FanRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
    /**
     * Filter, which FanRelation to fetch.
     */
    where?: FanRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FanRelations to fetch.
     */
    orderBy?: FanRelationOrderByWithRelationInput | FanRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FanRelations.
     */
    cursor?: FanRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FanRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FanRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FanRelations.
     */
    distinct?: FanRelationScalarFieldEnum | FanRelationScalarFieldEnum[]
  }

  /**
   * FanRelation findMany
   */
  export type FanRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
    /**
     * Filter, which FanRelations to fetch.
     */
    where?: FanRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FanRelations to fetch.
     */
    orderBy?: FanRelationOrderByWithRelationInput | FanRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FanRelations.
     */
    cursor?: FanRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FanRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FanRelations.
     */
    skip?: number
    distinct?: FanRelationScalarFieldEnum | FanRelationScalarFieldEnum[]
  }

  /**
   * FanRelation create
   */
  export type FanRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a FanRelation.
     */
    data: XOR<FanRelationCreateInput, FanRelationUncheckedCreateInput>
  }

  /**
   * FanRelation createMany
   */
  export type FanRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FanRelations.
     */
    data: FanRelationCreateManyInput | FanRelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FanRelation createManyAndReturn
   */
  export type FanRelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FanRelations.
     */
    data: FanRelationCreateManyInput | FanRelationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FanRelation update
   */
  export type FanRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a FanRelation.
     */
    data: XOR<FanRelationUpdateInput, FanRelationUncheckedUpdateInput>
    /**
     * Choose, which FanRelation to update.
     */
    where: FanRelationWhereUniqueInput
  }

  /**
   * FanRelation updateMany
   */
  export type FanRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FanRelations.
     */
    data: XOR<FanRelationUpdateManyMutationInput, FanRelationUncheckedUpdateManyInput>
    /**
     * Filter which FanRelations to update
     */
    where?: FanRelationWhereInput
  }

  /**
   * FanRelation upsert
   */
  export type FanRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the FanRelation to update in case it exists.
     */
    where: FanRelationWhereUniqueInput
    /**
     * In case the FanRelation found by the `where` argument doesn't exist, create a new FanRelation with this data.
     */
    create: XOR<FanRelationCreateInput, FanRelationUncheckedCreateInput>
    /**
     * In case the FanRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FanRelationUpdateInput, FanRelationUncheckedUpdateInput>
  }

  /**
   * FanRelation delete
   */
  export type FanRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
    /**
     * Filter which FanRelation to delete.
     */
    where: FanRelationWhereUniqueInput
  }

  /**
   * FanRelation deleteMany
   */
  export type FanRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FanRelations to delete
     */
    where?: FanRelationWhereInput
  }

  /**
   * FanRelation without action
   */
  export type FanRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanRelation
     */
    select?: FanRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanRelationInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
  }

  export type CampaignSumAggregateOutputType = {
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    name: string | null
    type: $Enums.CampaignType | null
    status: $Enums.CampaignStatus | null
    subject: string | null
    content: string | null
    scheduledFor: Date | null
    sentAt: Date | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    name: string | null
    type: $Enums.CampaignType | null
    status: $Enums.CampaignStatus | null
    subject: string | null
    content: string | null
    scheduledFor: Date | null
    sentAt: Date | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    creatorId: number
    name: number
    type: number
    status: number
    subject: number
    content: number
    targetTags: number
    targetSegment: number
    scheduledFor: number
    sentAt: number
    sentCount: number
    openCount: number
    clickCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    sentCount?: true
    openCount?: true
    clickCount?: true
  }

  export type CampaignSumAggregateInputType = {
    sentCount?: true
    openCount?: true
    clickCount?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    type?: true
    status?: true
    subject?: true
    content?: true
    scheduledFor?: true
    sentAt?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    type?: true
    status?: true
    subject?: true
    content?: true
    scheduledFor?: true
    sentAt?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    type?: true
    status?: true
    subject?: true
    content?: true
    targetTags?: true
    targetSegment?: true
    scheduledFor?: true
    sentAt?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    creatorId: string
    name: string
    type: $Enums.CampaignType
    status: $Enums.CampaignStatus
    subject: string | null
    content: string
    targetTags: string[]
    targetSegment: JsonValue | null
    scheduledFor: Date | null
    sentAt: Date | null
    sentCount: number
    openCount: number
    clickCount: number
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    content?: boolean
    targetTags?: boolean
    targetSegment?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    recipients?: boolean | Campaign$recipientsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    content?: boolean
    targetTags?: boolean
    targetSegment?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    creatorId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    content?: boolean
    targetTags?: boolean
    targetSegment?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    recipients?: boolean | Campaign$recipientsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      creator: Prisma.$CreatorPayload<ExtArgs>
      recipients: Prisma.$CampaignRecipientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      name: string
      type: $Enums.CampaignType
      status: $Enums.CampaignStatus
      subject: string | null
      content: string
      targetTags: string[]
      targetSegment: Prisma.JsonValue | null
      scheduledFor: Date | null
      sentAt: Date | null
      sentCount: number
      openCount: number
      clickCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends CreatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatorDefaultArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    recipients<T extends Campaign$recipientsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$recipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly creatorId: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly type: FieldRef<"Campaign", 'CampaignType'>
    readonly status: FieldRef<"Campaign", 'CampaignStatus'>
    readonly subject: FieldRef<"Campaign", 'String'>
    readonly content: FieldRef<"Campaign", 'String'>
    readonly targetTags: FieldRef<"Campaign", 'String[]'>
    readonly targetSegment: FieldRef<"Campaign", 'Json'>
    readonly scheduledFor: FieldRef<"Campaign", 'DateTime'>
    readonly sentAt: FieldRef<"Campaign", 'DateTime'>
    readonly sentCount: FieldRef<"Campaign", 'Int'>
    readonly openCount: FieldRef<"Campaign", 'Int'>
    readonly clickCount: FieldRef<"Campaign", 'Int'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.recipients
   */
  export type Campaign$recipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    where?: CampaignRecipientWhereInput
    orderBy?: CampaignRecipientOrderByWithRelationInput | CampaignRecipientOrderByWithRelationInput[]
    cursor?: CampaignRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignRecipientScalarFieldEnum | CampaignRecipientScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignRecipient
   */

  export type AggregateCampaignRecipient = {
    _count: CampaignRecipientCountAggregateOutputType | null
    _min: CampaignRecipientMinAggregateOutputType | null
    _max: CampaignRecipientMaxAggregateOutputType | null
  }

  export type CampaignRecipientMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    fanId: string | null
    status: $Enums.RecipientStatus | null
    sentAt: Date | null
    openedAt: Date | null
    clickedAt: Date | null
  }

  export type CampaignRecipientMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    fanId: string | null
    status: $Enums.RecipientStatus | null
    sentAt: Date | null
    openedAt: Date | null
    clickedAt: Date | null
  }

  export type CampaignRecipientCountAggregateOutputType = {
    id: number
    campaignId: number
    fanId: number
    status: number
    sentAt: number
    openedAt: number
    clickedAt: number
    _all: number
  }


  export type CampaignRecipientMinAggregateInputType = {
    id?: true
    campaignId?: true
    fanId?: true
    status?: true
    sentAt?: true
    openedAt?: true
    clickedAt?: true
  }

  export type CampaignRecipientMaxAggregateInputType = {
    id?: true
    campaignId?: true
    fanId?: true
    status?: true
    sentAt?: true
    openedAt?: true
    clickedAt?: true
  }

  export type CampaignRecipientCountAggregateInputType = {
    id?: true
    campaignId?: true
    fanId?: true
    status?: true
    sentAt?: true
    openedAt?: true
    clickedAt?: true
    _all?: true
  }

  export type CampaignRecipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignRecipient to aggregate.
     */
    where?: CampaignRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRecipients to fetch.
     */
    orderBy?: CampaignRecipientOrderByWithRelationInput | CampaignRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignRecipients
    **/
    _count?: true | CampaignRecipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignRecipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignRecipientMaxAggregateInputType
  }

  export type GetCampaignRecipientAggregateType<T extends CampaignRecipientAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignRecipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignRecipient[P]>
      : GetScalarType<T[P], AggregateCampaignRecipient[P]>
  }




  export type CampaignRecipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignRecipientWhereInput
    orderBy?: CampaignRecipientOrderByWithAggregationInput | CampaignRecipientOrderByWithAggregationInput[]
    by: CampaignRecipientScalarFieldEnum[] | CampaignRecipientScalarFieldEnum
    having?: CampaignRecipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignRecipientCountAggregateInputType | true
    _min?: CampaignRecipientMinAggregateInputType
    _max?: CampaignRecipientMaxAggregateInputType
  }

  export type CampaignRecipientGroupByOutputType = {
    id: string
    campaignId: string
    fanId: string
    status: $Enums.RecipientStatus
    sentAt: Date | null
    openedAt: Date | null
    clickedAt: Date | null
    _count: CampaignRecipientCountAggregateOutputType | null
    _min: CampaignRecipientMinAggregateOutputType | null
    _max: CampaignRecipientMaxAggregateOutputType | null
  }

  type GetCampaignRecipientGroupByPayload<T extends CampaignRecipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignRecipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignRecipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignRecipientGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignRecipientGroupByOutputType[P]>
        }
      >
    >


  export type CampaignRecipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    fanId?: boolean
    status?: boolean
    sentAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    fan?: boolean | FanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignRecipient"]>

  export type CampaignRecipientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    fanId?: boolean
    status?: boolean
    sentAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    fan?: boolean | FanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignRecipient"]>

  export type CampaignRecipientSelectScalar = {
    id?: boolean
    campaignId?: boolean
    fanId?: boolean
    status?: boolean
    sentAt?: boolean
    openedAt?: boolean
    clickedAt?: boolean
  }

  export type CampaignRecipientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    fan?: boolean | FanDefaultArgs<ExtArgs>
  }
  export type CampaignRecipientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    fan?: boolean | FanDefaultArgs<ExtArgs>
  }

  export type $CampaignRecipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignRecipient"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      fan: Prisma.$FanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      fanId: string
      status: $Enums.RecipientStatus
      sentAt: Date | null
      openedAt: Date | null
      clickedAt: Date | null
    }, ExtArgs["result"]["campaignRecipient"]>
    composites: {}
  }

  type CampaignRecipientGetPayload<S extends boolean | null | undefined | CampaignRecipientDefaultArgs> = $Result.GetResult<Prisma.$CampaignRecipientPayload, S>

  type CampaignRecipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignRecipientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignRecipientCountAggregateInputType | true
    }

  export interface CampaignRecipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignRecipient'], meta: { name: 'CampaignRecipient' } }
    /**
     * Find zero or one CampaignRecipient that matches the filter.
     * @param {CampaignRecipientFindUniqueArgs} args - Arguments to find a CampaignRecipient
     * @example
     * // Get one CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignRecipientFindUniqueArgs>(args: SelectSubset<T, CampaignRecipientFindUniqueArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignRecipient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignRecipientFindUniqueOrThrowArgs} args - Arguments to find a CampaignRecipient
     * @example
     * // Get one CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignRecipientFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignRecipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignRecipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientFindFirstArgs} args - Arguments to find a CampaignRecipient
     * @example
     * // Get one CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignRecipientFindFirstArgs>(args?: SelectSubset<T, CampaignRecipientFindFirstArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignRecipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientFindFirstOrThrowArgs} args - Arguments to find a CampaignRecipient
     * @example
     * // Get one CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignRecipientFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignRecipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignRecipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignRecipients
     * const campaignRecipients = await prisma.campaignRecipient.findMany()
     * 
     * // Get first 10 CampaignRecipients
     * const campaignRecipients = await prisma.campaignRecipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignRecipientWithIdOnly = await prisma.campaignRecipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignRecipientFindManyArgs>(args?: SelectSubset<T, CampaignRecipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignRecipient.
     * @param {CampaignRecipientCreateArgs} args - Arguments to create a CampaignRecipient.
     * @example
     * // Create one CampaignRecipient
     * const CampaignRecipient = await prisma.campaignRecipient.create({
     *   data: {
     *     // ... data to create a CampaignRecipient
     *   }
     * })
     * 
     */
    create<T extends CampaignRecipientCreateArgs>(args: SelectSubset<T, CampaignRecipientCreateArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignRecipients.
     * @param {CampaignRecipientCreateManyArgs} args - Arguments to create many CampaignRecipients.
     * @example
     * // Create many CampaignRecipients
     * const campaignRecipient = await prisma.campaignRecipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignRecipientCreateManyArgs>(args?: SelectSubset<T, CampaignRecipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignRecipients and returns the data saved in the database.
     * @param {CampaignRecipientCreateManyAndReturnArgs} args - Arguments to create many CampaignRecipients.
     * @example
     * // Create many CampaignRecipients
     * const campaignRecipient = await prisma.campaignRecipient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignRecipients and only return the `id`
     * const campaignRecipientWithIdOnly = await prisma.campaignRecipient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignRecipientCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignRecipientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignRecipient.
     * @param {CampaignRecipientDeleteArgs} args - Arguments to delete one CampaignRecipient.
     * @example
     * // Delete one CampaignRecipient
     * const CampaignRecipient = await prisma.campaignRecipient.delete({
     *   where: {
     *     // ... filter to delete one CampaignRecipient
     *   }
     * })
     * 
     */
    delete<T extends CampaignRecipientDeleteArgs>(args: SelectSubset<T, CampaignRecipientDeleteArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignRecipient.
     * @param {CampaignRecipientUpdateArgs} args - Arguments to update one CampaignRecipient.
     * @example
     * // Update one CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignRecipientUpdateArgs>(args: SelectSubset<T, CampaignRecipientUpdateArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignRecipients.
     * @param {CampaignRecipientDeleteManyArgs} args - Arguments to filter CampaignRecipients to delete.
     * @example
     * // Delete a few CampaignRecipients
     * const { count } = await prisma.campaignRecipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignRecipientDeleteManyArgs>(args?: SelectSubset<T, CampaignRecipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignRecipients
     * const campaignRecipient = await prisma.campaignRecipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignRecipientUpdateManyArgs>(args: SelectSubset<T, CampaignRecipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignRecipient.
     * @param {CampaignRecipientUpsertArgs} args - Arguments to update or create a CampaignRecipient.
     * @example
     * // Update or create a CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.upsert({
     *   create: {
     *     // ... data to create a CampaignRecipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignRecipient we want to update
     *   }
     * })
     */
    upsert<T extends CampaignRecipientUpsertArgs>(args: SelectSubset<T, CampaignRecipientUpsertArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientCountArgs} args - Arguments to filter CampaignRecipients to count.
     * @example
     * // Count the number of CampaignRecipients
     * const count = await prisma.campaignRecipient.count({
     *   where: {
     *     // ... the filter for the CampaignRecipients we want to count
     *   }
     * })
    **/
    count<T extends CampaignRecipientCountArgs>(
      args?: Subset<T, CampaignRecipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignRecipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignRecipientAggregateArgs>(args: Subset<T, CampaignRecipientAggregateArgs>): Prisma.PrismaPromise<GetCampaignRecipientAggregateType<T>>

    /**
     * Group by CampaignRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignRecipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignRecipientGroupByArgs['orderBy'] }
        : { orderBy?: CampaignRecipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignRecipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignRecipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignRecipient model
   */
  readonly fields: CampaignRecipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignRecipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignRecipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fan<T extends FanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FanDefaultArgs<ExtArgs>>): Prisma__FanClient<$Result.GetResult<Prisma.$FanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignRecipient model
   */ 
  interface CampaignRecipientFieldRefs {
    readonly id: FieldRef<"CampaignRecipient", 'String'>
    readonly campaignId: FieldRef<"CampaignRecipient", 'String'>
    readonly fanId: FieldRef<"CampaignRecipient", 'String'>
    readonly status: FieldRef<"CampaignRecipient", 'RecipientStatus'>
    readonly sentAt: FieldRef<"CampaignRecipient", 'DateTime'>
    readonly openedAt: FieldRef<"CampaignRecipient", 'DateTime'>
    readonly clickedAt: FieldRef<"CampaignRecipient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignRecipient findUnique
   */
  export type CampaignRecipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRecipient to fetch.
     */
    where: CampaignRecipientWhereUniqueInput
  }

  /**
   * CampaignRecipient findUniqueOrThrow
   */
  export type CampaignRecipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRecipient to fetch.
     */
    where: CampaignRecipientWhereUniqueInput
  }

  /**
   * CampaignRecipient findFirst
   */
  export type CampaignRecipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRecipient to fetch.
     */
    where?: CampaignRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRecipients to fetch.
     */
    orderBy?: CampaignRecipientOrderByWithRelationInput | CampaignRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignRecipients.
     */
    cursor?: CampaignRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignRecipients.
     */
    distinct?: CampaignRecipientScalarFieldEnum | CampaignRecipientScalarFieldEnum[]
  }

  /**
   * CampaignRecipient findFirstOrThrow
   */
  export type CampaignRecipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRecipient to fetch.
     */
    where?: CampaignRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRecipients to fetch.
     */
    orderBy?: CampaignRecipientOrderByWithRelationInput | CampaignRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignRecipients.
     */
    cursor?: CampaignRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignRecipients.
     */
    distinct?: CampaignRecipientScalarFieldEnum | CampaignRecipientScalarFieldEnum[]
  }

  /**
   * CampaignRecipient findMany
   */
  export type CampaignRecipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRecipients to fetch.
     */
    where?: CampaignRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRecipients to fetch.
     */
    orderBy?: CampaignRecipientOrderByWithRelationInput | CampaignRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignRecipients.
     */
    cursor?: CampaignRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRecipients.
     */
    skip?: number
    distinct?: CampaignRecipientScalarFieldEnum | CampaignRecipientScalarFieldEnum[]
  }

  /**
   * CampaignRecipient create
   */
  export type CampaignRecipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignRecipient.
     */
    data: XOR<CampaignRecipientCreateInput, CampaignRecipientUncheckedCreateInput>
  }

  /**
   * CampaignRecipient createMany
   */
  export type CampaignRecipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignRecipients.
     */
    data: CampaignRecipientCreateManyInput | CampaignRecipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignRecipient createManyAndReturn
   */
  export type CampaignRecipientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignRecipients.
     */
    data: CampaignRecipientCreateManyInput | CampaignRecipientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignRecipient update
   */
  export type CampaignRecipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignRecipient.
     */
    data: XOR<CampaignRecipientUpdateInput, CampaignRecipientUncheckedUpdateInput>
    /**
     * Choose, which CampaignRecipient to update.
     */
    where: CampaignRecipientWhereUniqueInput
  }

  /**
   * CampaignRecipient updateMany
   */
  export type CampaignRecipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignRecipients.
     */
    data: XOR<CampaignRecipientUpdateManyMutationInput, CampaignRecipientUncheckedUpdateManyInput>
    /**
     * Filter which CampaignRecipients to update
     */
    where?: CampaignRecipientWhereInput
  }

  /**
   * CampaignRecipient upsert
   */
  export type CampaignRecipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignRecipient to update in case it exists.
     */
    where: CampaignRecipientWhereUniqueInput
    /**
     * In case the CampaignRecipient found by the `where` argument doesn't exist, create a new CampaignRecipient with this data.
     */
    create: XOR<CampaignRecipientCreateInput, CampaignRecipientUncheckedCreateInput>
    /**
     * In case the CampaignRecipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignRecipientUpdateInput, CampaignRecipientUncheckedUpdateInput>
  }

  /**
   * CampaignRecipient delete
   */
  export type CampaignRecipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter which CampaignRecipient to delete.
     */
    where: CampaignRecipientWhereUniqueInput
  }

  /**
   * CampaignRecipient deleteMany
   */
  export type CampaignRecipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignRecipients to delete
     */
    where?: CampaignRecipientWhereInput
  }

  /**
   * CampaignRecipient without action
   */
  export type CampaignRecipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
  }


  /**
   * Model App
   */

  export type AggregateApp = {
    _count: AppCountAggregateOutputType | null
    _avg: AppAvgAggregateOutputType | null
    _sum: AppSumAggregateOutputType | null
    _min: AppMinAggregateOutputType | null
    _max: AppMaxAggregateOutputType | null
  }

  export type AppAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type AppSumAggregateOutputType = {
    price: Decimal | null
  }

  export type AppMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    developer: string | null
    website: string | null
    category: $Enums.AppCategory | null
    pricing: $Enums.AppPricing | null
    price: Decimal | null
    webhookUrl: string | null
    isPublished: boolean | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    developer: string | null
    website: string | null
    category: $Enums.AppCategory | null
    pricing: $Enums.AppPricing | null
    price: Decimal | null
    webhookUrl: string | null
    isPublished: boolean | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    icon: number
    developer: number
    website: number
    category: number
    pricing: number
    price: number
    webhookUrl: number
    scopes: number
    isPublished: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppAvgAggregateInputType = {
    price?: true
  }

  export type AppSumAggregateInputType = {
    price?: true
  }

  export type AppMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    developer?: true
    website?: true
    category?: true
    pricing?: true
    price?: true
    webhookUrl?: true
    isPublished?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    developer?: true
    website?: true
    category?: true
    pricing?: true
    price?: true
    webhookUrl?: true
    isPublished?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    developer?: true
    website?: true
    category?: true
    pricing?: true
    price?: true
    webhookUrl?: true
    scopes?: true
    isPublished?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which App to aggregate.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Apps
    **/
    _count?: true | AppCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppMaxAggregateInputType
  }

  export type GetAppAggregateType<T extends AppAggregateArgs> = {
        [P in keyof T & keyof AggregateApp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp[P]>
      : GetScalarType<T[P], AggregateApp[P]>
  }




  export type AppGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppWhereInput
    orderBy?: AppOrderByWithAggregationInput | AppOrderByWithAggregationInput[]
    by: AppScalarFieldEnum[] | AppScalarFieldEnum
    having?: AppScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppCountAggregateInputType | true
    _avg?: AppAvgAggregateInputType
    _sum?: AppSumAggregateInputType
    _min?: AppMinAggregateInputType
    _max?: AppMaxAggregateInputType
  }

  export type AppGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string
    icon: string | null
    developer: string
    website: string | null
    category: $Enums.AppCategory
    pricing: $Enums.AppPricing
    price: Decimal | null
    webhookUrl: string | null
    scopes: string[]
    isPublished: boolean
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: AppCountAggregateOutputType | null
    _avg: AppAvgAggregateOutputType | null
    _sum: AppSumAggregateOutputType | null
    _min: AppMinAggregateOutputType | null
    _max: AppMaxAggregateOutputType | null
  }

  type GetAppGroupByPayload<T extends AppGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppGroupByOutputType[P]>
            : GetScalarType<T[P], AppGroupByOutputType[P]>
        }
      >
    >


  export type AppSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    developer?: boolean
    website?: boolean
    category?: boolean
    pricing?: boolean
    price?: boolean
    webhookUrl?: boolean
    scopes?: boolean
    isPublished?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    installations?: boolean | App$installationsArgs<ExtArgs>
    _count?: boolean | AppCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app"]>

  export type AppSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    developer?: boolean
    website?: boolean
    category?: boolean
    pricing?: boolean
    price?: boolean
    webhookUrl?: boolean
    scopes?: boolean
    isPublished?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["app"]>

  export type AppSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    developer?: boolean
    website?: boolean
    category?: boolean
    pricing?: boolean
    price?: boolean
    webhookUrl?: boolean
    scopes?: boolean
    isPublished?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installations?: boolean | App$installationsArgs<ExtArgs>
    _count?: boolean | AppCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AppPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "App"
    objects: {
      installations: Prisma.$InstalledAppPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string
      icon: string | null
      developer: string
      website: string | null
      category: $Enums.AppCategory
      pricing: $Enums.AppPricing
      price: Prisma.Decimal | null
      webhookUrl: string | null
      scopes: string[]
      isPublished: boolean
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["app"]>
    composites: {}
  }

  type AppGetPayload<S extends boolean | null | undefined | AppDefaultArgs> = $Result.GetResult<Prisma.$AppPayload, S>

  type AppCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppCountAggregateInputType | true
    }

  export interface AppDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['App'], meta: { name: 'App' } }
    /**
     * Find zero or one App that matches the filter.
     * @param {AppFindUniqueArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppFindUniqueArgs>(args: SelectSubset<T, AppFindUniqueArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppFindUniqueOrThrowArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppFindUniqueOrThrowArgs>(args: SelectSubset<T, AppFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFindFirstArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppFindFirstArgs>(args?: SelectSubset<T, AppFindFirstArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFindFirstOrThrowArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppFindFirstOrThrowArgs>(args?: SelectSubset<T, AppFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Apps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apps
     * const apps = await prisma.app.findMany()
     * 
     * // Get first 10 Apps
     * const apps = await prisma.app.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appWithIdOnly = await prisma.app.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppFindManyArgs>(args?: SelectSubset<T, AppFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App.
     * @param {AppCreateArgs} args - Arguments to create a App.
     * @example
     * // Create one App
     * const App = await prisma.app.create({
     *   data: {
     *     // ... data to create a App
     *   }
     * })
     * 
     */
    create<T extends AppCreateArgs>(args: SelectSubset<T, AppCreateArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Apps.
     * @param {AppCreateManyArgs} args - Arguments to create many Apps.
     * @example
     * // Create many Apps
     * const app = await prisma.app.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppCreateManyArgs>(args?: SelectSubset<T, AppCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Apps and returns the data saved in the database.
     * @param {AppCreateManyAndReturnArgs} args - Arguments to create many Apps.
     * @example
     * // Create many Apps
     * const app = await prisma.app.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Apps and only return the `id`
     * const appWithIdOnly = await prisma.app.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppCreateManyAndReturnArgs>(args?: SelectSubset<T, AppCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App.
     * @param {AppDeleteArgs} args - Arguments to delete one App.
     * @example
     * // Delete one App
     * const App = await prisma.app.delete({
     *   where: {
     *     // ... filter to delete one App
     *   }
     * })
     * 
     */
    delete<T extends AppDeleteArgs>(args: SelectSubset<T, AppDeleteArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App.
     * @param {AppUpdateArgs} args - Arguments to update one App.
     * @example
     * // Update one App
     * const app = await prisma.app.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppUpdateArgs>(args: SelectSubset<T, AppUpdateArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Apps.
     * @param {AppDeleteManyArgs} args - Arguments to filter Apps to delete.
     * @example
     * // Delete a few Apps
     * const { count } = await prisma.app.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppDeleteManyArgs>(args?: SelectSubset<T, AppDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apps
     * const app = await prisma.app.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppUpdateManyArgs>(args: SelectSubset<T, AppUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App.
     * @param {AppUpsertArgs} args - Arguments to update or create a App.
     * @example
     * // Update or create a App
     * const app = await prisma.app.upsert({
     *   create: {
     *     // ... data to create a App
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App we want to update
     *   }
     * })
     */
    upsert<T extends AppUpsertArgs>(args: SelectSubset<T, AppUpsertArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppCountArgs} args - Arguments to filter Apps to count.
     * @example
     * // Count the number of Apps
     * const count = await prisma.app.count({
     *   where: {
     *     // ... the filter for the Apps we want to count
     *   }
     * })
    **/
    count<T extends AppCountArgs>(
      args?: Subset<T, AppCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppAggregateArgs>(args: Subset<T, AppAggregateArgs>): Prisma.PrismaPromise<GetAppAggregateType<T>>

    /**
     * Group by App.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppGroupByArgs['orderBy'] }
        : { orderBy?: AppGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the App model
   */
  readonly fields: AppFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for App.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    installations<T extends App$installationsArgs<ExtArgs> = {}>(args?: Subset<T, App$installationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the App model
   */ 
  interface AppFieldRefs {
    readonly id: FieldRef<"App", 'String'>
    readonly name: FieldRef<"App", 'String'>
    readonly slug: FieldRef<"App", 'String'>
    readonly description: FieldRef<"App", 'String'>
    readonly icon: FieldRef<"App", 'String'>
    readonly developer: FieldRef<"App", 'String'>
    readonly website: FieldRef<"App", 'String'>
    readonly category: FieldRef<"App", 'AppCategory'>
    readonly pricing: FieldRef<"App", 'AppPricing'>
    readonly price: FieldRef<"App", 'Decimal'>
    readonly webhookUrl: FieldRef<"App", 'String'>
    readonly scopes: FieldRef<"App", 'String[]'>
    readonly isPublished: FieldRef<"App", 'Boolean'>
    readonly isVerified: FieldRef<"App", 'Boolean'>
    readonly createdAt: FieldRef<"App", 'DateTime'>
    readonly updatedAt: FieldRef<"App", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * App findUnique
   */
  export type AppFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App findUniqueOrThrow
   */
  export type AppFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App findFirst
   */
  export type AppFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apps.
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apps.
     */
    distinct?: AppScalarFieldEnum | AppScalarFieldEnum[]
  }

  /**
   * App findFirstOrThrow
   */
  export type AppFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apps.
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apps.
     */
    distinct?: AppScalarFieldEnum | AppScalarFieldEnum[]
  }

  /**
   * App findMany
   */
  export type AppFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which Apps to fetch.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Apps.
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    distinct?: AppScalarFieldEnum | AppScalarFieldEnum[]
  }

  /**
   * App create
   */
  export type AppCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * The data needed to create a App.
     */
    data: XOR<AppCreateInput, AppUncheckedCreateInput>
  }

  /**
   * App createMany
   */
  export type AppCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Apps.
     */
    data: AppCreateManyInput | AppCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * App createManyAndReturn
   */
  export type AppCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Apps.
     */
    data: AppCreateManyInput | AppCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * App update
   */
  export type AppUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * The data needed to update a App.
     */
    data: XOR<AppUpdateInput, AppUncheckedUpdateInput>
    /**
     * Choose, which App to update.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App updateMany
   */
  export type AppUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Apps.
     */
    data: XOR<AppUpdateManyMutationInput, AppUncheckedUpdateManyInput>
    /**
     * Filter which Apps to update
     */
    where?: AppWhereInput
  }

  /**
   * App upsert
   */
  export type AppUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * The filter to search for the App to update in case it exists.
     */
    where: AppWhereUniqueInput
    /**
     * In case the App found by the `where` argument doesn't exist, create a new App with this data.
     */
    create: XOR<AppCreateInput, AppUncheckedCreateInput>
    /**
     * In case the App was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppUpdateInput, AppUncheckedUpdateInput>
  }

  /**
   * App delete
   */
  export type AppDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter which App to delete.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App deleteMany
   */
  export type AppDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Apps to delete
     */
    where?: AppWhereInput
  }

  /**
   * App.installations
   */
  export type App$installationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
    where?: InstalledAppWhereInput
    orderBy?: InstalledAppOrderByWithRelationInput | InstalledAppOrderByWithRelationInput[]
    cursor?: InstalledAppWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstalledAppScalarFieldEnum | InstalledAppScalarFieldEnum[]
  }

  /**
   * App without action
   */
  export type AppDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
  }


  /**
   * Model InstalledApp
   */

  export type AggregateInstalledApp = {
    _count: InstalledAppCountAggregateOutputType | null
    _min: InstalledAppMinAggregateOutputType | null
    _max: InstalledAppMaxAggregateOutputType | null
  }

  export type InstalledAppMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    appId: string | null
    status: $Enums.AppStatus | null
    billingCycle: $Enums.BillingInterval | null
    nextBilling: Date | null
    installedAt: Date | null
    uninstalledAt: Date | null
  }

  export type InstalledAppMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    appId: string | null
    status: $Enums.AppStatus | null
    billingCycle: $Enums.BillingInterval | null
    nextBilling: Date | null
    installedAt: Date | null
    uninstalledAt: Date | null
  }

  export type InstalledAppCountAggregateOutputType = {
    id: number
    creatorId: number
    appId: number
    status: number
    settings: number
    billingCycle: number
    nextBilling: number
    installedAt: number
    uninstalledAt: number
    _all: number
  }


  export type InstalledAppMinAggregateInputType = {
    id?: true
    creatorId?: true
    appId?: true
    status?: true
    billingCycle?: true
    nextBilling?: true
    installedAt?: true
    uninstalledAt?: true
  }

  export type InstalledAppMaxAggregateInputType = {
    id?: true
    creatorId?: true
    appId?: true
    status?: true
    billingCycle?: true
    nextBilling?: true
    installedAt?: true
    uninstalledAt?: true
  }

  export type InstalledAppCountAggregateInputType = {
    id?: true
    creatorId?: true
    appId?: true
    status?: true
    settings?: true
    billingCycle?: true
    nextBilling?: true
    installedAt?: true
    uninstalledAt?: true
    _all?: true
  }

  export type InstalledAppAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstalledApp to aggregate.
     */
    where?: InstalledAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalledApps to fetch.
     */
    orderBy?: InstalledAppOrderByWithRelationInput | InstalledAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstalledAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalledApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalledApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstalledApps
    **/
    _count?: true | InstalledAppCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstalledAppMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstalledAppMaxAggregateInputType
  }

  export type GetInstalledAppAggregateType<T extends InstalledAppAggregateArgs> = {
        [P in keyof T & keyof AggregateInstalledApp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstalledApp[P]>
      : GetScalarType<T[P], AggregateInstalledApp[P]>
  }




  export type InstalledAppGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalledAppWhereInput
    orderBy?: InstalledAppOrderByWithAggregationInput | InstalledAppOrderByWithAggregationInput[]
    by: InstalledAppScalarFieldEnum[] | InstalledAppScalarFieldEnum
    having?: InstalledAppScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstalledAppCountAggregateInputType | true
    _min?: InstalledAppMinAggregateInputType
    _max?: InstalledAppMaxAggregateInputType
  }

  export type InstalledAppGroupByOutputType = {
    id: string
    creatorId: string
    appId: string
    status: $Enums.AppStatus
    settings: JsonValue | null
    billingCycle: $Enums.BillingInterval | null
    nextBilling: Date | null
    installedAt: Date
    uninstalledAt: Date | null
    _count: InstalledAppCountAggregateOutputType | null
    _min: InstalledAppMinAggregateOutputType | null
    _max: InstalledAppMaxAggregateOutputType | null
  }

  type GetInstalledAppGroupByPayload<T extends InstalledAppGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstalledAppGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstalledAppGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstalledAppGroupByOutputType[P]>
            : GetScalarType<T[P], InstalledAppGroupByOutputType[P]>
        }
      >
    >


  export type InstalledAppSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    appId?: boolean
    status?: boolean
    settings?: boolean
    billingCycle?: boolean
    nextBilling?: boolean
    installedAt?: boolean
    uninstalledAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installedApp"]>

  export type InstalledAppSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    appId?: boolean
    status?: boolean
    settings?: boolean
    billingCycle?: boolean
    nextBilling?: boolean
    installedAt?: boolean
    uninstalledAt?: boolean
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installedApp"]>

  export type InstalledAppSelectScalar = {
    id?: boolean
    creatorId?: boolean
    appId?: boolean
    status?: boolean
    settings?: boolean
    billingCycle?: boolean
    nextBilling?: boolean
    installedAt?: boolean
    uninstalledAt?: boolean
  }

  export type InstalledAppInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type InstalledAppIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CreatorDefaultArgs<ExtArgs>
    app?: boolean | AppDefaultArgs<ExtArgs>
  }

  export type $InstalledAppPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstalledApp"
    objects: {
      creator: Prisma.$CreatorPayload<ExtArgs>
      app: Prisma.$AppPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      appId: string
      status: $Enums.AppStatus
      settings: Prisma.JsonValue | null
      billingCycle: $Enums.BillingInterval | null
      nextBilling: Date | null
      installedAt: Date
      uninstalledAt: Date | null
    }, ExtArgs["result"]["installedApp"]>
    composites: {}
  }

  type InstalledAppGetPayload<S extends boolean | null | undefined | InstalledAppDefaultArgs> = $Result.GetResult<Prisma.$InstalledAppPayload, S>

  type InstalledAppCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstalledAppFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstalledAppCountAggregateInputType | true
    }

  export interface InstalledAppDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstalledApp'], meta: { name: 'InstalledApp' } }
    /**
     * Find zero or one InstalledApp that matches the filter.
     * @param {InstalledAppFindUniqueArgs} args - Arguments to find a InstalledApp
     * @example
     * // Get one InstalledApp
     * const installedApp = await prisma.installedApp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstalledAppFindUniqueArgs>(args: SelectSubset<T, InstalledAppFindUniqueArgs<ExtArgs>>): Prisma__InstalledAppClient<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InstalledApp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InstalledAppFindUniqueOrThrowArgs} args - Arguments to find a InstalledApp
     * @example
     * // Get one InstalledApp
     * const installedApp = await prisma.installedApp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstalledAppFindUniqueOrThrowArgs>(args: SelectSubset<T, InstalledAppFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstalledAppClient<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InstalledApp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledAppFindFirstArgs} args - Arguments to find a InstalledApp
     * @example
     * // Get one InstalledApp
     * const installedApp = await prisma.installedApp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstalledAppFindFirstArgs>(args?: SelectSubset<T, InstalledAppFindFirstArgs<ExtArgs>>): Prisma__InstalledAppClient<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InstalledApp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledAppFindFirstOrThrowArgs} args - Arguments to find a InstalledApp
     * @example
     * // Get one InstalledApp
     * const installedApp = await prisma.installedApp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstalledAppFindFirstOrThrowArgs>(args?: SelectSubset<T, InstalledAppFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstalledAppClient<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InstalledApps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledAppFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstalledApps
     * const installedApps = await prisma.installedApp.findMany()
     * 
     * // Get first 10 InstalledApps
     * const installedApps = await prisma.installedApp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const installedAppWithIdOnly = await prisma.installedApp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstalledAppFindManyArgs>(args?: SelectSubset<T, InstalledAppFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InstalledApp.
     * @param {InstalledAppCreateArgs} args - Arguments to create a InstalledApp.
     * @example
     * // Create one InstalledApp
     * const InstalledApp = await prisma.installedApp.create({
     *   data: {
     *     // ... data to create a InstalledApp
     *   }
     * })
     * 
     */
    create<T extends InstalledAppCreateArgs>(args: SelectSubset<T, InstalledAppCreateArgs<ExtArgs>>): Prisma__InstalledAppClient<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InstalledApps.
     * @param {InstalledAppCreateManyArgs} args - Arguments to create many InstalledApps.
     * @example
     * // Create many InstalledApps
     * const installedApp = await prisma.installedApp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstalledAppCreateManyArgs>(args?: SelectSubset<T, InstalledAppCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstalledApps and returns the data saved in the database.
     * @param {InstalledAppCreateManyAndReturnArgs} args - Arguments to create many InstalledApps.
     * @example
     * // Create many InstalledApps
     * const installedApp = await prisma.installedApp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstalledApps and only return the `id`
     * const installedAppWithIdOnly = await prisma.installedApp.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstalledAppCreateManyAndReturnArgs>(args?: SelectSubset<T, InstalledAppCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InstalledApp.
     * @param {InstalledAppDeleteArgs} args - Arguments to delete one InstalledApp.
     * @example
     * // Delete one InstalledApp
     * const InstalledApp = await prisma.installedApp.delete({
     *   where: {
     *     // ... filter to delete one InstalledApp
     *   }
     * })
     * 
     */
    delete<T extends InstalledAppDeleteArgs>(args: SelectSubset<T, InstalledAppDeleteArgs<ExtArgs>>): Prisma__InstalledAppClient<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InstalledApp.
     * @param {InstalledAppUpdateArgs} args - Arguments to update one InstalledApp.
     * @example
     * // Update one InstalledApp
     * const installedApp = await prisma.installedApp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstalledAppUpdateArgs>(args: SelectSubset<T, InstalledAppUpdateArgs<ExtArgs>>): Prisma__InstalledAppClient<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InstalledApps.
     * @param {InstalledAppDeleteManyArgs} args - Arguments to filter InstalledApps to delete.
     * @example
     * // Delete a few InstalledApps
     * const { count } = await prisma.installedApp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstalledAppDeleteManyArgs>(args?: SelectSubset<T, InstalledAppDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstalledApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledAppUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstalledApps
     * const installedApp = await prisma.installedApp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstalledAppUpdateManyArgs>(args: SelectSubset<T, InstalledAppUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InstalledApp.
     * @param {InstalledAppUpsertArgs} args - Arguments to update or create a InstalledApp.
     * @example
     * // Update or create a InstalledApp
     * const installedApp = await prisma.installedApp.upsert({
     *   create: {
     *     // ... data to create a InstalledApp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstalledApp we want to update
     *   }
     * })
     */
    upsert<T extends InstalledAppUpsertArgs>(args: SelectSubset<T, InstalledAppUpsertArgs<ExtArgs>>): Prisma__InstalledAppClient<$Result.GetResult<Prisma.$InstalledAppPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InstalledApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledAppCountArgs} args - Arguments to filter InstalledApps to count.
     * @example
     * // Count the number of InstalledApps
     * const count = await prisma.installedApp.count({
     *   where: {
     *     // ... the filter for the InstalledApps we want to count
     *   }
     * })
    **/
    count<T extends InstalledAppCountArgs>(
      args?: Subset<T, InstalledAppCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstalledAppCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstalledApp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledAppAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstalledAppAggregateArgs>(args: Subset<T, InstalledAppAggregateArgs>): Prisma.PrismaPromise<GetInstalledAppAggregateType<T>>

    /**
     * Group by InstalledApp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledAppGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstalledAppGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstalledAppGroupByArgs['orderBy'] }
        : { orderBy?: InstalledAppGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstalledAppGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstalledAppGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstalledApp model
   */
  readonly fields: InstalledAppFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstalledApp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstalledAppClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends CreatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatorDefaultArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    app<T extends AppDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppDefaultArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstalledApp model
   */ 
  interface InstalledAppFieldRefs {
    readonly id: FieldRef<"InstalledApp", 'String'>
    readonly creatorId: FieldRef<"InstalledApp", 'String'>
    readonly appId: FieldRef<"InstalledApp", 'String'>
    readonly status: FieldRef<"InstalledApp", 'AppStatus'>
    readonly settings: FieldRef<"InstalledApp", 'Json'>
    readonly billingCycle: FieldRef<"InstalledApp", 'BillingInterval'>
    readonly nextBilling: FieldRef<"InstalledApp", 'DateTime'>
    readonly installedAt: FieldRef<"InstalledApp", 'DateTime'>
    readonly uninstalledAt: FieldRef<"InstalledApp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstalledApp findUnique
   */
  export type InstalledAppFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
    /**
     * Filter, which InstalledApp to fetch.
     */
    where: InstalledAppWhereUniqueInput
  }

  /**
   * InstalledApp findUniqueOrThrow
   */
  export type InstalledAppFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
    /**
     * Filter, which InstalledApp to fetch.
     */
    where: InstalledAppWhereUniqueInput
  }

  /**
   * InstalledApp findFirst
   */
  export type InstalledAppFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
    /**
     * Filter, which InstalledApp to fetch.
     */
    where?: InstalledAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalledApps to fetch.
     */
    orderBy?: InstalledAppOrderByWithRelationInput | InstalledAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstalledApps.
     */
    cursor?: InstalledAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalledApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalledApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstalledApps.
     */
    distinct?: InstalledAppScalarFieldEnum | InstalledAppScalarFieldEnum[]
  }

  /**
   * InstalledApp findFirstOrThrow
   */
  export type InstalledAppFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
    /**
     * Filter, which InstalledApp to fetch.
     */
    where?: InstalledAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalledApps to fetch.
     */
    orderBy?: InstalledAppOrderByWithRelationInput | InstalledAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstalledApps.
     */
    cursor?: InstalledAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalledApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalledApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstalledApps.
     */
    distinct?: InstalledAppScalarFieldEnum | InstalledAppScalarFieldEnum[]
  }

  /**
   * InstalledApp findMany
   */
  export type InstalledAppFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
    /**
     * Filter, which InstalledApps to fetch.
     */
    where?: InstalledAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalledApps to fetch.
     */
    orderBy?: InstalledAppOrderByWithRelationInput | InstalledAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstalledApps.
     */
    cursor?: InstalledAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalledApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalledApps.
     */
    skip?: number
    distinct?: InstalledAppScalarFieldEnum | InstalledAppScalarFieldEnum[]
  }

  /**
   * InstalledApp create
   */
  export type InstalledAppCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
    /**
     * The data needed to create a InstalledApp.
     */
    data: XOR<InstalledAppCreateInput, InstalledAppUncheckedCreateInput>
  }

  /**
   * InstalledApp createMany
   */
  export type InstalledAppCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstalledApps.
     */
    data: InstalledAppCreateManyInput | InstalledAppCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstalledApp createManyAndReturn
   */
  export type InstalledAppCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InstalledApps.
     */
    data: InstalledAppCreateManyInput | InstalledAppCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstalledApp update
   */
  export type InstalledAppUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
    /**
     * The data needed to update a InstalledApp.
     */
    data: XOR<InstalledAppUpdateInput, InstalledAppUncheckedUpdateInput>
    /**
     * Choose, which InstalledApp to update.
     */
    where: InstalledAppWhereUniqueInput
  }

  /**
   * InstalledApp updateMany
   */
  export type InstalledAppUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstalledApps.
     */
    data: XOR<InstalledAppUpdateManyMutationInput, InstalledAppUncheckedUpdateManyInput>
    /**
     * Filter which InstalledApps to update
     */
    where?: InstalledAppWhereInput
  }

  /**
   * InstalledApp upsert
   */
  export type InstalledAppUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
    /**
     * The filter to search for the InstalledApp to update in case it exists.
     */
    where: InstalledAppWhereUniqueInput
    /**
     * In case the InstalledApp found by the `where` argument doesn't exist, create a new InstalledApp with this data.
     */
    create: XOR<InstalledAppCreateInput, InstalledAppUncheckedCreateInput>
    /**
     * In case the InstalledApp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstalledAppUpdateInput, InstalledAppUncheckedUpdateInput>
  }

  /**
   * InstalledApp delete
   */
  export type InstalledAppDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
    /**
     * Filter which InstalledApp to delete.
     */
    where: InstalledAppWhereUniqueInput
  }

  /**
   * InstalledApp deleteMany
   */
  export type InstalledAppDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstalledApps to delete
     */
    where?: InstalledAppWhereInput
  }

  /**
   * InstalledApp without action
   */
  export type InstalledAppDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledApp
     */
    select?: InstalledAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalledAppInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    actorId: string | null
    actorType: $Enums.ActorType | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    actorId: string | null
    actorType: $Enums.ActorType | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    creatorId: number
    actorId: number
    actorType: number
    action: number
    resource: number
    resourceId: number
    ipAddress: number
    userAgent: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    creatorId?: true
    actorId?: true
    actorType?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    creatorId?: true
    actorId?: true
    actorType?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    creatorId?: true
    actorId?: true
    actorType?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    creatorId: string | null
    actorId: string
    actorType: $Enums.ActorType
    action: string
    resource: string
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    actorId?: boolean
    actorType?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    creator?: boolean | AuditLog$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    actorId?: boolean
    actorType?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    creator?: boolean | AuditLog$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    creatorId?: boolean
    actorId?: boolean
    actorType?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | AuditLog$creatorArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | AuditLog$creatorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      creator: Prisma.$CreatorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string | null
      actorId: string
      actorType: $Enums.ActorType
      action: string
      resource: string
      resourceId: string | null
      ipAddress: string | null
      userAgent: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends AuditLog$creatorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$creatorArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly creatorId: FieldRef<"AuditLog", 'String'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly actorType: FieldRef<"AuditLog", 'ActorType'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.creator
   */
  export type AuditLog$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    where?: CreatorWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model LedgerAccount
   */

  export type AggregateLedgerAccount = {
    _count: LedgerAccountCountAggregateOutputType | null
    _avg: LedgerAccountAvgAggregateOutputType | null
    _sum: LedgerAccountSumAggregateOutputType | null
    _min: LedgerAccountMinAggregateOutputType | null
    _max: LedgerAccountMaxAggregateOutputType | null
  }

  export type LedgerAccountAvgAggregateOutputType = {
    balance: number | null
  }

  export type LedgerAccountSumAggregateOutputType = {
    balance: bigint | null
  }

  export type LedgerAccountMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.LedgerAccountType | null
    currency: string | null
    ownerId: string | null
    balance: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LedgerAccountMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.LedgerAccountType | null
    currency: string | null
    ownerId: string | null
    balance: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LedgerAccountCountAggregateOutputType = {
    id: number
    tenantId: number
    type: number
    currency: number
    ownerId: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LedgerAccountAvgAggregateInputType = {
    balance?: true
  }

  export type LedgerAccountSumAggregateInputType = {
    balance?: true
  }

  export type LedgerAccountMinAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    currency?: true
    ownerId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LedgerAccountMaxAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    currency?: true
    ownerId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LedgerAccountCountAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    currency?: true
    ownerId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LedgerAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerAccount to aggregate.
     */
    where?: LedgerAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerAccounts to fetch.
     */
    orderBy?: LedgerAccountOrderByWithRelationInput | LedgerAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LedgerAccounts
    **/
    _count?: true | LedgerAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerAccountMaxAggregateInputType
  }

  export type GetLedgerAccountAggregateType<T extends LedgerAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateLedgerAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedgerAccount[P]>
      : GetScalarType<T[P], AggregateLedgerAccount[P]>
  }




  export type LedgerAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerAccountWhereInput
    orderBy?: LedgerAccountOrderByWithAggregationInput | LedgerAccountOrderByWithAggregationInput[]
    by: LedgerAccountScalarFieldEnum[] | LedgerAccountScalarFieldEnum
    having?: LedgerAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerAccountCountAggregateInputType | true
    _avg?: LedgerAccountAvgAggregateInputType
    _sum?: LedgerAccountSumAggregateInputType
    _min?: LedgerAccountMinAggregateInputType
    _max?: LedgerAccountMaxAggregateInputType
  }

  export type LedgerAccountGroupByOutputType = {
    id: string
    tenantId: string
    type: $Enums.LedgerAccountType
    currency: string
    ownerId: string | null
    balance: bigint
    createdAt: Date
    updatedAt: Date
    _count: LedgerAccountCountAggregateOutputType | null
    _avg: LedgerAccountAvgAggregateOutputType | null
    _sum: LedgerAccountSumAggregateOutputType | null
    _min: LedgerAccountMinAggregateOutputType | null
    _max: LedgerAccountMaxAggregateOutputType | null
  }

  type GetLedgerAccountGroupByPayload<T extends LedgerAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerAccountGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerAccountGroupByOutputType[P]>
        }
      >
    >


  export type LedgerAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    currency?: boolean
    ownerId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entries?: boolean | LedgerAccount$entriesArgs<ExtArgs>
    _count?: boolean | LedgerAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerAccount"]>

  export type LedgerAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    currency?: boolean
    ownerId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ledgerAccount"]>

  export type LedgerAccountSelectScalar = {
    id?: boolean
    tenantId?: boolean
    type?: boolean
    currency?: boolean
    ownerId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LedgerAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | LedgerAccount$entriesArgs<ExtArgs>
    _count?: boolean | LedgerAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LedgerAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LedgerAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LedgerAccount"
    objects: {
      entries: Prisma.$LedgerEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      type: $Enums.LedgerAccountType
      currency: string
      ownerId: string | null
      balance: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ledgerAccount"]>
    composites: {}
  }

  type LedgerAccountGetPayload<S extends boolean | null | undefined | LedgerAccountDefaultArgs> = $Result.GetResult<Prisma.$LedgerAccountPayload, S>

  type LedgerAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LedgerAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LedgerAccountCountAggregateInputType | true
    }

  export interface LedgerAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LedgerAccount'], meta: { name: 'LedgerAccount' } }
    /**
     * Find zero or one LedgerAccount that matches the filter.
     * @param {LedgerAccountFindUniqueArgs} args - Arguments to find a LedgerAccount
     * @example
     * // Get one LedgerAccount
     * const ledgerAccount = await prisma.ledgerAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerAccountFindUniqueArgs>(args: SelectSubset<T, LedgerAccountFindUniqueArgs<ExtArgs>>): Prisma__LedgerAccountClient<$Result.GetResult<Prisma.$LedgerAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LedgerAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LedgerAccountFindUniqueOrThrowArgs} args - Arguments to find a LedgerAccount
     * @example
     * // Get one LedgerAccount
     * const ledgerAccount = await prisma.ledgerAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerAccountClient<$Result.GetResult<Prisma.$LedgerAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LedgerAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerAccountFindFirstArgs} args - Arguments to find a LedgerAccount
     * @example
     * // Get one LedgerAccount
     * const ledgerAccount = await prisma.ledgerAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerAccountFindFirstArgs>(args?: SelectSubset<T, LedgerAccountFindFirstArgs<ExtArgs>>): Prisma__LedgerAccountClient<$Result.GetResult<Prisma.$LedgerAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LedgerAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerAccountFindFirstOrThrowArgs} args - Arguments to find a LedgerAccount
     * @example
     * // Get one LedgerAccount
     * const ledgerAccount = await prisma.ledgerAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerAccountClient<$Result.GetResult<Prisma.$LedgerAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LedgerAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LedgerAccounts
     * const ledgerAccounts = await prisma.ledgerAccount.findMany()
     * 
     * // Get first 10 LedgerAccounts
     * const ledgerAccounts = await prisma.ledgerAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerAccountWithIdOnly = await prisma.ledgerAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerAccountFindManyArgs>(args?: SelectSubset<T, LedgerAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LedgerAccount.
     * @param {LedgerAccountCreateArgs} args - Arguments to create a LedgerAccount.
     * @example
     * // Create one LedgerAccount
     * const LedgerAccount = await prisma.ledgerAccount.create({
     *   data: {
     *     // ... data to create a LedgerAccount
     *   }
     * })
     * 
     */
    create<T extends LedgerAccountCreateArgs>(args: SelectSubset<T, LedgerAccountCreateArgs<ExtArgs>>): Prisma__LedgerAccountClient<$Result.GetResult<Prisma.$LedgerAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LedgerAccounts.
     * @param {LedgerAccountCreateManyArgs} args - Arguments to create many LedgerAccounts.
     * @example
     * // Create many LedgerAccounts
     * const ledgerAccount = await prisma.ledgerAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerAccountCreateManyArgs>(args?: SelectSubset<T, LedgerAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LedgerAccounts and returns the data saved in the database.
     * @param {LedgerAccountCreateManyAndReturnArgs} args - Arguments to create many LedgerAccounts.
     * @example
     * // Create many LedgerAccounts
     * const ledgerAccount = await prisma.ledgerAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LedgerAccounts and only return the `id`
     * const ledgerAccountWithIdOnly = await prisma.ledgerAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LedgerAccount.
     * @param {LedgerAccountDeleteArgs} args - Arguments to delete one LedgerAccount.
     * @example
     * // Delete one LedgerAccount
     * const LedgerAccount = await prisma.ledgerAccount.delete({
     *   where: {
     *     // ... filter to delete one LedgerAccount
     *   }
     * })
     * 
     */
    delete<T extends LedgerAccountDeleteArgs>(args: SelectSubset<T, LedgerAccountDeleteArgs<ExtArgs>>): Prisma__LedgerAccountClient<$Result.GetResult<Prisma.$LedgerAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LedgerAccount.
     * @param {LedgerAccountUpdateArgs} args - Arguments to update one LedgerAccount.
     * @example
     * // Update one LedgerAccount
     * const ledgerAccount = await prisma.ledgerAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerAccountUpdateArgs>(args: SelectSubset<T, LedgerAccountUpdateArgs<ExtArgs>>): Prisma__LedgerAccountClient<$Result.GetResult<Prisma.$LedgerAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LedgerAccounts.
     * @param {LedgerAccountDeleteManyArgs} args - Arguments to filter LedgerAccounts to delete.
     * @example
     * // Delete a few LedgerAccounts
     * const { count } = await prisma.ledgerAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerAccountDeleteManyArgs>(args?: SelectSubset<T, LedgerAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LedgerAccounts
     * const ledgerAccount = await prisma.ledgerAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerAccountUpdateManyArgs>(args: SelectSubset<T, LedgerAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LedgerAccount.
     * @param {LedgerAccountUpsertArgs} args - Arguments to update or create a LedgerAccount.
     * @example
     * // Update or create a LedgerAccount
     * const ledgerAccount = await prisma.ledgerAccount.upsert({
     *   create: {
     *     // ... data to create a LedgerAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LedgerAccount we want to update
     *   }
     * })
     */
    upsert<T extends LedgerAccountUpsertArgs>(args: SelectSubset<T, LedgerAccountUpsertArgs<ExtArgs>>): Prisma__LedgerAccountClient<$Result.GetResult<Prisma.$LedgerAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LedgerAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerAccountCountArgs} args - Arguments to filter LedgerAccounts to count.
     * @example
     * // Count the number of LedgerAccounts
     * const count = await prisma.ledgerAccount.count({
     *   where: {
     *     // ... the filter for the LedgerAccounts we want to count
     *   }
     * })
    **/
    count<T extends LedgerAccountCountArgs>(
      args?: Subset<T, LedgerAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LedgerAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerAccountAggregateArgs>(args: Subset<T, LedgerAccountAggregateArgs>): Prisma.PrismaPromise<GetLedgerAccountAggregateType<T>>

    /**
     * Group by LedgerAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerAccountGroupByArgs['orderBy'] }
        : { orderBy?: LedgerAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LedgerAccount model
   */
  readonly fields: LedgerAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LedgerAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends LedgerAccount$entriesArgs<ExtArgs> = {}>(args?: Subset<T, LedgerAccount$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LedgerAccount model
   */ 
  interface LedgerAccountFieldRefs {
    readonly id: FieldRef<"LedgerAccount", 'String'>
    readonly tenantId: FieldRef<"LedgerAccount", 'String'>
    readonly type: FieldRef<"LedgerAccount", 'LedgerAccountType'>
    readonly currency: FieldRef<"LedgerAccount", 'String'>
    readonly ownerId: FieldRef<"LedgerAccount", 'String'>
    readonly balance: FieldRef<"LedgerAccount", 'BigInt'>
    readonly createdAt: FieldRef<"LedgerAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"LedgerAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LedgerAccount findUnique
   */
  export type LedgerAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccount
     */
    select?: LedgerAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerAccountInclude<ExtArgs> | null
    /**
     * Filter, which LedgerAccount to fetch.
     */
    where: LedgerAccountWhereUniqueInput
  }

  /**
   * LedgerAccount findUniqueOrThrow
   */
  export type LedgerAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccount
     */
    select?: LedgerAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerAccountInclude<ExtArgs> | null
    /**
     * Filter, which LedgerAccount to fetch.
     */
    where: LedgerAccountWhereUniqueInput
  }

  /**
   * LedgerAccount findFirst
   */
  export type LedgerAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccount
     */
    select?: LedgerAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerAccountInclude<ExtArgs> | null
    /**
     * Filter, which LedgerAccount to fetch.
     */
    where?: LedgerAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerAccounts to fetch.
     */
    orderBy?: LedgerAccountOrderByWithRelationInput | LedgerAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerAccounts.
     */
    cursor?: LedgerAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerAccounts.
     */
    distinct?: LedgerAccountScalarFieldEnum | LedgerAccountScalarFieldEnum[]
  }

  /**
   * LedgerAccount findFirstOrThrow
   */
  export type LedgerAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccount
     */
    select?: LedgerAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerAccountInclude<ExtArgs> | null
    /**
     * Filter, which LedgerAccount to fetch.
     */
    where?: LedgerAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerAccounts to fetch.
     */
    orderBy?: LedgerAccountOrderByWithRelationInput | LedgerAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerAccounts.
     */
    cursor?: LedgerAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerAccounts.
     */
    distinct?: LedgerAccountScalarFieldEnum | LedgerAccountScalarFieldEnum[]
  }

  /**
   * LedgerAccount findMany
   */
  export type LedgerAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccount
     */
    select?: LedgerAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerAccountInclude<ExtArgs> | null
    /**
     * Filter, which LedgerAccounts to fetch.
     */
    where?: LedgerAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerAccounts to fetch.
     */
    orderBy?: LedgerAccountOrderByWithRelationInput | LedgerAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LedgerAccounts.
     */
    cursor?: LedgerAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerAccounts.
     */
    skip?: number
    distinct?: LedgerAccountScalarFieldEnum | LedgerAccountScalarFieldEnum[]
  }

  /**
   * LedgerAccount create
   */
  export type LedgerAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccount
     */
    select?: LedgerAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a LedgerAccount.
     */
    data: XOR<LedgerAccountCreateInput, LedgerAccountUncheckedCreateInput>
  }

  /**
   * LedgerAccount createMany
   */
  export type LedgerAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LedgerAccounts.
     */
    data: LedgerAccountCreateManyInput | LedgerAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerAccount createManyAndReturn
   */
  export type LedgerAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccount
     */
    select?: LedgerAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LedgerAccounts.
     */
    data: LedgerAccountCreateManyInput | LedgerAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerAccount update
   */
  export type LedgerAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccount
     */
    select?: LedgerAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a LedgerAccount.
     */
    data: XOR<LedgerAccountUpdateInput, LedgerAccountUncheckedUpdateInput>
    /**
     * Choose, which LedgerAccount to update.
     */
    where: LedgerAccountWhereUniqueInput
  }

  /**
   * LedgerAccount updateMany
   */
  export type LedgerAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LedgerAccounts.
     */
    data: XOR<LedgerAccountUpdateManyMutationInput, LedgerAccountUncheckedUpdateManyInput>
    /**
     * Filter which LedgerAccounts to update
     */
    where?: LedgerAccountWhereInput
  }

  /**
   * LedgerAccount upsert
   */
  export type LedgerAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccount
     */
    select?: LedgerAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the LedgerAccount to update in case it exists.
     */
    where: LedgerAccountWhereUniqueInput
    /**
     * In case the LedgerAccount found by the `where` argument doesn't exist, create a new LedgerAccount with this data.
     */
    create: XOR<LedgerAccountCreateInput, LedgerAccountUncheckedCreateInput>
    /**
     * In case the LedgerAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerAccountUpdateInput, LedgerAccountUncheckedUpdateInput>
  }

  /**
   * LedgerAccount delete
   */
  export type LedgerAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccount
     */
    select?: LedgerAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerAccountInclude<ExtArgs> | null
    /**
     * Filter which LedgerAccount to delete.
     */
    where: LedgerAccountWhereUniqueInput
  }

  /**
   * LedgerAccount deleteMany
   */
  export type LedgerAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerAccounts to delete
     */
    where?: LedgerAccountWhereInput
  }

  /**
   * LedgerAccount.entries
   */
  export type LedgerAccount$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerAccount without action
   */
  export type LedgerAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerAccount
     */
    select?: LedgerAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerAccountInclude<ExtArgs> | null
  }


  /**
   * Model LedgerTransaction
   */

  export type AggregateLedgerTransaction = {
    _count: LedgerTransactionCountAggregateOutputType | null
    _min: LedgerTransactionMinAggregateOutputType | null
    _max: LedgerTransactionMaxAggregateOutputType | null
  }

  export type LedgerTransactionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    kind: $Enums.LedgerTransactionKind | null
    currency: string | null
    occurredAt: Date | null
    memo: string | null
    source: string | null
    extRef: string | null
    stripeEventId: string | null
    idempotencyKey: string | null
    reversedBy: string | null
    createdAt: Date | null
  }

  export type LedgerTransactionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    kind: $Enums.LedgerTransactionKind | null
    currency: string | null
    occurredAt: Date | null
    memo: string | null
    source: string | null
    extRef: string | null
    stripeEventId: string | null
    idempotencyKey: string | null
    reversedBy: string | null
    createdAt: Date | null
  }

  export type LedgerTransactionCountAggregateOutputType = {
    id: number
    tenantId: number
    kind: number
    currency: number
    occurredAt: number
    memo: number
    source: number
    extRef: number
    stripeEventId: number
    idempotencyKey: number
    reversedBy: number
    createdAt: number
    _all: number
  }


  export type LedgerTransactionMinAggregateInputType = {
    id?: true
    tenantId?: true
    kind?: true
    currency?: true
    occurredAt?: true
    memo?: true
    source?: true
    extRef?: true
    stripeEventId?: true
    idempotencyKey?: true
    reversedBy?: true
    createdAt?: true
  }

  export type LedgerTransactionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    kind?: true
    currency?: true
    occurredAt?: true
    memo?: true
    source?: true
    extRef?: true
    stripeEventId?: true
    idempotencyKey?: true
    reversedBy?: true
    createdAt?: true
  }

  export type LedgerTransactionCountAggregateInputType = {
    id?: true
    tenantId?: true
    kind?: true
    currency?: true
    occurredAt?: true
    memo?: true
    source?: true
    extRef?: true
    stripeEventId?: true
    idempotencyKey?: true
    reversedBy?: true
    createdAt?: true
    _all?: true
  }

  export type LedgerTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerTransaction to aggregate.
     */
    where?: LedgerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerTransactions to fetch.
     */
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LedgerTransactions
    **/
    _count?: true | LedgerTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerTransactionMaxAggregateInputType
  }

  export type GetLedgerTransactionAggregateType<T extends LedgerTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateLedgerTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedgerTransaction[P]>
      : GetScalarType<T[P], AggregateLedgerTransaction[P]>
  }




  export type LedgerTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerTransactionWhereInput
    orderBy?: LedgerTransactionOrderByWithAggregationInput | LedgerTransactionOrderByWithAggregationInput[]
    by: LedgerTransactionScalarFieldEnum[] | LedgerTransactionScalarFieldEnum
    having?: LedgerTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerTransactionCountAggregateInputType | true
    _min?: LedgerTransactionMinAggregateInputType
    _max?: LedgerTransactionMaxAggregateInputType
  }

  export type LedgerTransactionGroupByOutputType = {
    id: string
    tenantId: string
    kind: $Enums.LedgerTransactionKind
    currency: string
    occurredAt: Date
    memo: string | null
    source: string | null
    extRef: string | null
    stripeEventId: string | null
    idempotencyKey: string | null
    reversedBy: string | null
    createdAt: Date
    _count: LedgerTransactionCountAggregateOutputType | null
    _min: LedgerTransactionMinAggregateOutputType | null
    _max: LedgerTransactionMaxAggregateOutputType | null
  }

  type GetLedgerTransactionGroupByPayload<T extends LedgerTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerTransactionGroupByOutputType[P]>
        }
      >
    >


  export type LedgerTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kind?: boolean
    currency?: boolean
    occurredAt?: boolean
    memo?: boolean
    source?: boolean
    extRef?: boolean
    stripeEventId?: boolean
    idempotencyKey?: boolean
    reversedBy?: boolean
    createdAt?: boolean
    entries?: boolean | LedgerTransaction$entriesArgs<ExtArgs>
    _count?: boolean | LedgerTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerTransaction"]>

  export type LedgerTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kind?: boolean
    currency?: boolean
    occurredAt?: boolean
    memo?: boolean
    source?: boolean
    extRef?: boolean
    stripeEventId?: boolean
    idempotencyKey?: boolean
    reversedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ledgerTransaction"]>

  export type LedgerTransactionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    kind?: boolean
    currency?: boolean
    occurredAt?: boolean
    memo?: boolean
    source?: boolean
    extRef?: boolean
    stripeEventId?: boolean
    idempotencyKey?: boolean
    reversedBy?: boolean
    createdAt?: boolean
  }

  export type LedgerTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | LedgerTransaction$entriesArgs<ExtArgs>
    _count?: boolean | LedgerTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LedgerTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LedgerTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LedgerTransaction"
    objects: {
      entries: Prisma.$LedgerEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      kind: $Enums.LedgerTransactionKind
      currency: string
      occurredAt: Date
      memo: string | null
      source: string | null
      extRef: string | null
      stripeEventId: string | null
      idempotencyKey: string | null
      reversedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["ledgerTransaction"]>
    composites: {}
  }

  type LedgerTransactionGetPayload<S extends boolean | null | undefined | LedgerTransactionDefaultArgs> = $Result.GetResult<Prisma.$LedgerTransactionPayload, S>

  type LedgerTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LedgerTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LedgerTransactionCountAggregateInputType | true
    }

  export interface LedgerTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LedgerTransaction'], meta: { name: 'LedgerTransaction' } }
    /**
     * Find zero or one LedgerTransaction that matches the filter.
     * @param {LedgerTransactionFindUniqueArgs} args - Arguments to find a LedgerTransaction
     * @example
     * // Get one LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerTransactionFindUniqueArgs>(args: SelectSubset<T, LedgerTransactionFindUniqueArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LedgerTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LedgerTransactionFindUniqueOrThrowArgs} args - Arguments to find a LedgerTransaction
     * @example
     * // Get one LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LedgerTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionFindFirstArgs} args - Arguments to find a LedgerTransaction
     * @example
     * // Get one LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerTransactionFindFirstArgs>(args?: SelectSubset<T, LedgerTransactionFindFirstArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LedgerTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionFindFirstOrThrowArgs} args - Arguments to find a LedgerTransaction
     * @example
     * // Get one LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LedgerTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LedgerTransactions
     * const ledgerTransactions = await prisma.ledgerTransaction.findMany()
     * 
     * // Get first 10 LedgerTransactions
     * const ledgerTransactions = await prisma.ledgerTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerTransactionWithIdOnly = await prisma.ledgerTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerTransactionFindManyArgs>(args?: SelectSubset<T, LedgerTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LedgerTransaction.
     * @param {LedgerTransactionCreateArgs} args - Arguments to create a LedgerTransaction.
     * @example
     * // Create one LedgerTransaction
     * const LedgerTransaction = await prisma.ledgerTransaction.create({
     *   data: {
     *     // ... data to create a LedgerTransaction
     *   }
     * })
     * 
     */
    create<T extends LedgerTransactionCreateArgs>(args: SelectSubset<T, LedgerTransactionCreateArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LedgerTransactions.
     * @param {LedgerTransactionCreateManyArgs} args - Arguments to create many LedgerTransactions.
     * @example
     * // Create many LedgerTransactions
     * const ledgerTransaction = await prisma.ledgerTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerTransactionCreateManyArgs>(args?: SelectSubset<T, LedgerTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LedgerTransactions and returns the data saved in the database.
     * @param {LedgerTransactionCreateManyAndReturnArgs} args - Arguments to create many LedgerTransactions.
     * @example
     * // Create many LedgerTransactions
     * const ledgerTransaction = await prisma.ledgerTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LedgerTransactions and only return the `id`
     * const ledgerTransactionWithIdOnly = await prisma.ledgerTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LedgerTransaction.
     * @param {LedgerTransactionDeleteArgs} args - Arguments to delete one LedgerTransaction.
     * @example
     * // Delete one LedgerTransaction
     * const LedgerTransaction = await prisma.ledgerTransaction.delete({
     *   where: {
     *     // ... filter to delete one LedgerTransaction
     *   }
     * })
     * 
     */
    delete<T extends LedgerTransactionDeleteArgs>(args: SelectSubset<T, LedgerTransactionDeleteArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LedgerTransaction.
     * @param {LedgerTransactionUpdateArgs} args - Arguments to update one LedgerTransaction.
     * @example
     * // Update one LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerTransactionUpdateArgs>(args: SelectSubset<T, LedgerTransactionUpdateArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LedgerTransactions.
     * @param {LedgerTransactionDeleteManyArgs} args - Arguments to filter LedgerTransactions to delete.
     * @example
     * // Delete a few LedgerTransactions
     * const { count } = await prisma.ledgerTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerTransactionDeleteManyArgs>(args?: SelectSubset<T, LedgerTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LedgerTransactions
     * const ledgerTransaction = await prisma.ledgerTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerTransactionUpdateManyArgs>(args: SelectSubset<T, LedgerTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LedgerTransaction.
     * @param {LedgerTransactionUpsertArgs} args - Arguments to update or create a LedgerTransaction.
     * @example
     * // Update or create a LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.upsert({
     *   create: {
     *     // ... data to create a LedgerTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LedgerTransaction we want to update
     *   }
     * })
     */
    upsert<T extends LedgerTransactionUpsertArgs>(args: SelectSubset<T, LedgerTransactionUpsertArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LedgerTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionCountArgs} args - Arguments to filter LedgerTransactions to count.
     * @example
     * // Count the number of LedgerTransactions
     * const count = await prisma.ledgerTransaction.count({
     *   where: {
     *     // ... the filter for the LedgerTransactions we want to count
     *   }
     * })
    **/
    count<T extends LedgerTransactionCountArgs>(
      args?: Subset<T, LedgerTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LedgerTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerTransactionAggregateArgs>(args: Subset<T, LedgerTransactionAggregateArgs>): Prisma.PrismaPromise<GetLedgerTransactionAggregateType<T>>

    /**
     * Group by LedgerTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerTransactionGroupByArgs['orderBy'] }
        : { orderBy?: LedgerTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LedgerTransaction model
   */
  readonly fields: LedgerTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LedgerTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends LedgerTransaction$entriesArgs<ExtArgs> = {}>(args?: Subset<T, LedgerTransaction$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LedgerTransaction model
   */ 
  interface LedgerTransactionFieldRefs {
    readonly id: FieldRef<"LedgerTransaction", 'String'>
    readonly tenantId: FieldRef<"LedgerTransaction", 'String'>
    readonly kind: FieldRef<"LedgerTransaction", 'LedgerTransactionKind'>
    readonly currency: FieldRef<"LedgerTransaction", 'String'>
    readonly occurredAt: FieldRef<"LedgerTransaction", 'DateTime'>
    readonly memo: FieldRef<"LedgerTransaction", 'String'>
    readonly source: FieldRef<"LedgerTransaction", 'String'>
    readonly extRef: FieldRef<"LedgerTransaction", 'String'>
    readonly stripeEventId: FieldRef<"LedgerTransaction", 'String'>
    readonly idempotencyKey: FieldRef<"LedgerTransaction", 'String'>
    readonly reversedBy: FieldRef<"LedgerTransaction", 'String'>
    readonly createdAt: FieldRef<"LedgerTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LedgerTransaction findUnique
   */
  export type LedgerTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LedgerTransaction to fetch.
     */
    where: LedgerTransactionWhereUniqueInput
  }

  /**
   * LedgerTransaction findUniqueOrThrow
   */
  export type LedgerTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LedgerTransaction to fetch.
     */
    where: LedgerTransactionWhereUniqueInput
  }

  /**
   * LedgerTransaction findFirst
   */
  export type LedgerTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LedgerTransaction to fetch.
     */
    where?: LedgerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerTransactions to fetch.
     */
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerTransactions.
     */
    cursor?: LedgerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerTransactions.
     */
    distinct?: LedgerTransactionScalarFieldEnum | LedgerTransactionScalarFieldEnum[]
  }

  /**
   * LedgerTransaction findFirstOrThrow
   */
  export type LedgerTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LedgerTransaction to fetch.
     */
    where?: LedgerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerTransactions to fetch.
     */
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerTransactions.
     */
    cursor?: LedgerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerTransactions.
     */
    distinct?: LedgerTransactionScalarFieldEnum | LedgerTransactionScalarFieldEnum[]
  }

  /**
   * LedgerTransaction findMany
   */
  export type LedgerTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LedgerTransactions to fetch.
     */
    where?: LedgerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerTransactions to fetch.
     */
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LedgerTransactions.
     */
    cursor?: LedgerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerTransactions.
     */
    skip?: number
    distinct?: LedgerTransactionScalarFieldEnum | LedgerTransactionScalarFieldEnum[]
  }

  /**
   * LedgerTransaction create
   */
  export type LedgerTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a LedgerTransaction.
     */
    data: XOR<LedgerTransactionCreateInput, LedgerTransactionUncheckedCreateInput>
  }

  /**
   * LedgerTransaction createMany
   */
  export type LedgerTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LedgerTransactions.
     */
    data: LedgerTransactionCreateManyInput | LedgerTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerTransaction createManyAndReturn
   */
  export type LedgerTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LedgerTransactions.
     */
    data: LedgerTransactionCreateManyInput | LedgerTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerTransaction update
   */
  export type LedgerTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a LedgerTransaction.
     */
    data: XOR<LedgerTransactionUpdateInput, LedgerTransactionUncheckedUpdateInput>
    /**
     * Choose, which LedgerTransaction to update.
     */
    where: LedgerTransactionWhereUniqueInput
  }

  /**
   * LedgerTransaction updateMany
   */
  export type LedgerTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LedgerTransactions.
     */
    data: XOR<LedgerTransactionUpdateManyMutationInput, LedgerTransactionUncheckedUpdateManyInput>
    /**
     * Filter which LedgerTransactions to update
     */
    where?: LedgerTransactionWhereInput
  }

  /**
   * LedgerTransaction upsert
   */
  export type LedgerTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the LedgerTransaction to update in case it exists.
     */
    where: LedgerTransactionWhereUniqueInput
    /**
     * In case the LedgerTransaction found by the `where` argument doesn't exist, create a new LedgerTransaction with this data.
     */
    create: XOR<LedgerTransactionCreateInput, LedgerTransactionUncheckedCreateInput>
    /**
     * In case the LedgerTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerTransactionUpdateInput, LedgerTransactionUncheckedUpdateInput>
  }

  /**
   * LedgerTransaction delete
   */
  export type LedgerTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter which LedgerTransaction to delete.
     */
    where: LedgerTransactionWhereUniqueInput
  }

  /**
   * LedgerTransaction deleteMany
   */
  export type LedgerTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerTransactions to delete
     */
    where?: LedgerTransactionWhereInput
  }

  /**
   * LedgerTransaction.entries
   */
  export type LedgerTransaction$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerTransaction without action
   */
  export type LedgerTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
  }


  /**
   * Model LedgerEntry
   */

  export type AggregateLedgerEntry = {
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  export type LedgerEntryAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type LedgerEntrySumAggregateOutputType = {
    amountCents: bigint | null
  }

  export type LedgerEntryMinAggregateOutputType = {
    id: string | null
    txId: string | null
    accountId: string | null
    direction: $Enums.LedgerDirection | null
    amountCents: bigint | null
    currency: string | null
    createdAt: Date | null
  }

  export type LedgerEntryMaxAggregateOutputType = {
    id: string | null
    txId: string | null
    accountId: string | null
    direction: $Enums.LedgerDirection | null
    amountCents: bigint | null
    currency: string | null
    createdAt: Date | null
  }

  export type LedgerEntryCountAggregateOutputType = {
    id: number
    txId: number
    accountId: number
    direction: number
    amountCents: number
    currency: number
    createdAt: number
    _all: number
  }


  export type LedgerEntryAvgAggregateInputType = {
    amountCents?: true
  }

  export type LedgerEntrySumAggregateInputType = {
    amountCents?: true
  }

  export type LedgerEntryMinAggregateInputType = {
    id?: true
    txId?: true
    accountId?: true
    direction?: true
    amountCents?: true
    currency?: true
    createdAt?: true
  }

  export type LedgerEntryMaxAggregateInputType = {
    id?: true
    txId?: true
    accountId?: true
    direction?: true
    amountCents?: true
    currency?: true
    createdAt?: true
  }

  export type LedgerEntryCountAggregateInputType = {
    id?: true
    txId?: true
    accountId?: true
    direction?: true
    amountCents?: true
    currency?: true
    createdAt?: true
    _all?: true
  }

  export type LedgerEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntry to aggregate.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LedgerEntries
    **/
    _count?: true | LedgerEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type GetLedgerEntryAggregateType<T extends LedgerEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLedgerEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedgerEntry[P]>
      : GetScalarType<T[P], AggregateLedgerEntry[P]>
  }




  export type LedgerEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithAggregationInput | LedgerEntryOrderByWithAggregationInput[]
    by: LedgerEntryScalarFieldEnum[] | LedgerEntryScalarFieldEnum
    having?: LedgerEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerEntryCountAggregateInputType | true
    _avg?: LedgerEntryAvgAggregateInputType
    _sum?: LedgerEntrySumAggregateInputType
    _min?: LedgerEntryMinAggregateInputType
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type LedgerEntryGroupByOutputType = {
    id: string
    txId: string
    accountId: string
    direction: $Enums.LedgerDirection
    amountCents: bigint
    currency: string
    createdAt: Date
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  type GetLedgerEntryGroupByPayload<T extends LedgerEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
        }
      >
    >


  export type LedgerEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txId?: boolean
    accountId?: boolean
    direction?: boolean
    amountCents?: boolean
    currency?: boolean
    createdAt?: boolean
    transaction?: boolean | LedgerTransactionDefaultArgs<ExtArgs>
    account?: boolean | LedgerAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txId?: boolean
    accountId?: boolean
    direction?: boolean
    amountCents?: boolean
    currency?: boolean
    createdAt?: boolean
    transaction?: boolean | LedgerTransactionDefaultArgs<ExtArgs>
    account?: boolean | LedgerAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectScalar = {
    id?: boolean
    txId?: boolean
    accountId?: boolean
    direction?: boolean
    amountCents?: boolean
    currency?: boolean
    createdAt?: boolean
  }

  export type LedgerEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | LedgerTransactionDefaultArgs<ExtArgs>
    account?: boolean | LedgerAccountDefaultArgs<ExtArgs>
  }
  export type LedgerEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | LedgerTransactionDefaultArgs<ExtArgs>
    account?: boolean | LedgerAccountDefaultArgs<ExtArgs>
  }

  export type $LedgerEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LedgerEntry"
    objects: {
      transaction: Prisma.$LedgerTransactionPayload<ExtArgs>
      account: Prisma.$LedgerAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      txId: string
      accountId: string
      direction: $Enums.LedgerDirection
      amountCents: bigint
      currency: string
      createdAt: Date
    }, ExtArgs["result"]["ledgerEntry"]>
    composites: {}
  }

  type LedgerEntryGetPayload<S extends boolean | null | undefined | LedgerEntryDefaultArgs> = $Result.GetResult<Prisma.$LedgerEntryPayload, S>

  type LedgerEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LedgerEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LedgerEntryCountAggregateInputType | true
    }

  export interface LedgerEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LedgerEntry'], meta: { name: 'LedgerEntry' } }
    /**
     * Find zero or one LedgerEntry that matches the filter.
     * @param {LedgerEntryFindUniqueArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerEntryFindUniqueArgs>(args: SelectSubset<T, LedgerEntryFindUniqueArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LedgerEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LedgerEntryFindUniqueOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LedgerEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerEntryFindFirstArgs>(args?: SelectSubset<T, LedgerEntryFindFirstArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LedgerEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LedgerEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany()
     * 
     * // Get first 10 LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerEntryFindManyArgs>(args?: SelectSubset<T, LedgerEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LedgerEntry.
     * @param {LedgerEntryCreateArgs} args - Arguments to create a LedgerEntry.
     * @example
     * // Create one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.create({
     *   data: {
     *     // ... data to create a LedgerEntry
     *   }
     * })
     * 
     */
    create<T extends LedgerEntryCreateArgs>(args: SelectSubset<T, LedgerEntryCreateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LedgerEntries.
     * @param {LedgerEntryCreateManyArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerEntryCreateManyArgs>(args?: SelectSubset<T, LedgerEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LedgerEntries and returns the data saved in the database.
     * @param {LedgerEntryCreateManyAndReturnArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LedgerEntries and only return the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LedgerEntry.
     * @param {LedgerEntryDeleteArgs} args - Arguments to delete one LedgerEntry.
     * @example
     * // Delete one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.delete({
     *   where: {
     *     // ... filter to delete one LedgerEntry
     *   }
     * })
     * 
     */
    delete<T extends LedgerEntryDeleteArgs>(args: SelectSubset<T, LedgerEntryDeleteArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LedgerEntry.
     * @param {LedgerEntryUpdateArgs} args - Arguments to update one LedgerEntry.
     * @example
     * // Update one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerEntryUpdateArgs>(args: SelectSubset<T, LedgerEntryUpdateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LedgerEntries.
     * @param {LedgerEntryDeleteManyArgs} args - Arguments to filter LedgerEntries to delete.
     * @example
     * // Delete a few LedgerEntries
     * const { count } = await prisma.ledgerEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerEntryDeleteManyArgs>(args?: SelectSubset<T, LedgerEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerEntryUpdateManyArgs>(args: SelectSubset<T, LedgerEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LedgerEntry.
     * @param {LedgerEntryUpsertArgs} args - Arguments to update or create a LedgerEntry.
     * @example
     * // Update or create a LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.upsert({
     *   create: {
     *     // ... data to create a LedgerEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LedgerEntry we want to update
     *   }
     * })
     */
    upsert<T extends LedgerEntryUpsertArgs>(args: SelectSubset<T, LedgerEntryUpsertArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryCountArgs} args - Arguments to filter LedgerEntries to count.
     * @example
     * // Count the number of LedgerEntries
     * const count = await prisma.ledgerEntry.count({
     *   where: {
     *     // ... the filter for the LedgerEntries we want to count
     *   }
     * })
    **/
    count<T extends LedgerEntryCountArgs>(
      args?: Subset<T, LedgerEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerEntryAggregateArgs>(args: Subset<T, LedgerEntryAggregateArgs>): Prisma.PrismaPromise<GetLedgerEntryAggregateType<T>>

    /**
     * Group by LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerEntryGroupByArgs['orderBy'] }
        : { orderBy?: LedgerEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LedgerEntry model
   */
  readonly fields: LedgerEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LedgerEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends LedgerTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LedgerTransactionDefaultArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends LedgerAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LedgerAccountDefaultArgs<ExtArgs>>): Prisma__LedgerAccountClient<$Result.GetResult<Prisma.$LedgerAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LedgerEntry model
   */ 
  interface LedgerEntryFieldRefs {
    readonly id: FieldRef<"LedgerEntry", 'String'>
    readonly txId: FieldRef<"LedgerEntry", 'String'>
    readonly accountId: FieldRef<"LedgerEntry", 'String'>
    readonly direction: FieldRef<"LedgerEntry", 'LedgerDirection'>
    readonly amountCents: FieldRef<"LedgerEntry", 'BigInt'>
    readonly currency: FieldRef<"LedgerEntry", 'String'>
    readonly createdAt: FieldRef<"LedgerEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LedgerEntry findUnique
   */
  export type LedgerEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findUniqueOrThrow
   */
  export type LedgerEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findFirst
   */
  export type LedgerEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findFirstOrThrow
   */
  export type LedgerEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findMany
   */
  export type LedgerEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntries to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry create
   */
  export type LedgerEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LedgerEntry.
     */
    data: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
  }

  /**
   * LedgerEntry createMany
   */
  export type LedgerEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerEntry createManyAndReturn
   */
  export type LedgerEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LedgerEntry update
   */
  export type LedgerEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LedgerEntry.
     */
    data: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
    /**
     * Choose, which LedgerEntry to update.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry updateMany
   */
  export type LedgerEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LedgerEntries.
     */
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which LedgerEntries to update
     */
    where?: LedgerEntryWhereInput
  }

  /**
   * LedgerEntry upsert
   */
  export type LedgerEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LedgerEntry to update in case it exists.
     */
    where: LedgerEntryWhereUniqueInput
    /**
     * In case the LedgerEntry found by the `where` argument doesn't exist, create a new LedgerEntry with this data.
     */
    create: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
    /**
     * In case the LedgerEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
  }

  /**
   * LedgerEntry delete
   */
  export type LedgerEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter which LedgerEntry to delete.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry deleteMany
   */
  export type LedgerEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntries to delete
     */
    where?: LedgerEntryWhereInput
  }

  /**
   * LedgerEntry without action
   */
  export type LedgerEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
  }


  /**
   * Model CommissionCapMonthly
   */

  export type AggregateCommissionCapMonthly = {
    _count: CommissionCapMonthlyCountAggregateOutputType | null
    _avg: CommissionCapMonthlyAvgAggregateOutputType | null
    _sum: CommissionCapMonthlySumAggregateOutputType | null
    _min: CommissionCapMonthlyMinAggregateOutputType | null
    _max: CommissionCapMonthlyMaxAggregateOutputType | null
  }

  export type CommissionCapMonthlyAvgAggregateOutputType = {
    capCents: number | null
    appliedCents: number | null
  }

  export type CommissionCapMonthlySumAggregateOutputType = {
    capCents: bigint | null
    appliedCents: bigint | null
  }

  export type CommissionCapMonthlyMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    yearMonth: string | null
    currency: string | null
    capCents: bigint | null
    appliedCents: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommissionCapMonthlyMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    yearMonth: string | null
    currency: string | null
    capCents: bigint | null
    appliedCents: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommissionCapMonthlyCountAggregateOutputType = {
    id: number
    creatorId: number
    yearMonth: number
    currency: number
    capCents: number
    appliedCents: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommissionCapMonthlyAvgAggregateInputType = {
    capCents?: true
    appliedCents?: true
  }

  export type CommissionCapMonthlySumAggregateInputType = {
    capCents?: true
    appliedCents?: true
  }

  export type CommissionCapMonthlyMinAggregateInputType = {
    id?: true
    creatorId?: true
    yearMonth?: true
    currency?: true
    capCents?: true
    appliedCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommissionCapMonthlyMaxAggregateInputType = {
    id?: true
    creatorId?: true
    yearMonth?: true
    currency?: true
    capCents?: true
    appliedCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommissionCapMonthlyCountAggregateInputType = {
    id?: true
    creatorId?: true
    yearMonth?: true
    currency?: true
    capCents?: true
    appliedCents?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommissionCapMonthlyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionCapMonthly to aggregate.
     */
    where?: CommissionCapMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionCapMonthlies to fetch.
     */
    orderBy?: CommissionCapMonthlyOrderByWithRelationInput | CommissionCapMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommissionCapMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionCapMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionCapMonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommissionCapMonthlies
    **/
    _count?: true | CommissionCapMonthlyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommissionCapMonthlyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommissionCapMonthlySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommissionCapMonthlyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommissionCapMonthlyMaxAggregateInputType
  }

  export type GetCommissionCapMonthlyAggregateType<T extends CommissionCapMonthlyAggregateArgs> = {
        [P in keyof T & keyof AggregateCommissionCapMonthly]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommissionCapMonthly[P]>
      : GetScalarType<T[P], AggregateCommissionCapMonthly[P]>
  }




  export type CommissionCapMonthlyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionCapMonthlyWhereInput
    orderBy?: CommissionCapMonthlyOrderByWithAggregationInput | CommissionCapMonthlyOrderByWithAggregationInput[]
    by: CommissionCapMonthlyScalarFieldEnum[] | CommissionCapMonthlyScalarFieldEnum
    having?: CommissionCapMonthlyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommissionCapMonthlyCountAggregateInputType | true
    _avg?: CommissionCapMonthlyAvgAggregateInputType
    _sum?: CommissionCapMonthlySumAggregateInputType
    _min?: CommissionCapMonthlyMinAggregateInputType
    _max?: CommissionCapMonthlyMaxAggregateInputType
  }

  export type CommissionCapMonthlyGroupByOutputType = {
    id: string
    creatorId: string
    yearMonth: string
    currency: string
    capCents: bigint
    appliedCents: bigint
    createdAt: Date
    updatedAt: Date
    _count: CommissionCapMonthlyCountAggregateOutputType | null
    _avg: CommissionCapMonthlyAvgAggregateOutputType | null
    _sum: CommissionCapMonthlySumAggregateOutputType | null
    _min: CommissionCapMonthlyMinAggregateOutputType | null
    _max: CommissionCapMonthlyMaxAggregateOutputType | null
  }

  type GetCommissionCapMonthlyGroupByPayload<T extends CommissionCapMonthlyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommissionCapMonthlyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommissionCapMonthlyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommissionCapMonthlyGroupByOutputType[P]>
            : GetScalarType<T[P], CommissionCapMonthlyGroupByOutputType[P]>
        }
      >
    >


  export type CommissionCapMonthlySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    yearMonth?: boolean
    currency?: boolean
    capCents?: boolean
    appliedCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["commissionCapMonthly"]>

  export type CommissionCapMonthlySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    yearMonth?: boolean
    currency?: boolean
    capCents?: boolean
    appliedCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["commissionCapMonthly"]>

  export type CommissionCapMonthlySelectScalar = {
    id?: boolean
    creatorId?: boolean
    yearMonth?: boolean
    currency?: boolean
    capCents?: boolean
    appliedCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CommissionCapMonthlyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommissionCapMonthly"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      yearMonth: string
      currency: string
      capCents: bigint
      appliedCents: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commissionCapMonthly"]>
    composites: {}
  }

  type CommissionCapMonthlyGetPayload<S extends boolean | null | undefined | CommissionCapMonthlyDefaultArgs> = $Result.GetResult<Prisma.$CommissionCapMonthlyPayload, S>

  type CommissionCapMonthlyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommissionCapMonthlyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommissionCapMonthlyCountAggregateInputType | true
    }

  export interface CommissionCapMonthlyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommissionCapMonthly'], meta: { name: 'CommissionCapMonthly' } }
    /**
     * Find zero or one CommissionCapMonthly that matches the filter.
     * @param {CommissionCapMonthlyFindUniqueArgs} args - Arguments to find a CommissionCapMonthly
     * @example
     * // Get one CommissionCapMonthly
     * const commissionCapMonthly = await prisma.commissionCapMonthly.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommissionCapMonthlyFindUniqueArgs>(args: SelectSubset<T, CommissionCapMonthlyFindUniqueArgs<ExtArgs>>): Prisma__CommissionCapMonthlyClient<$Result.GetResult<Prisma.$CommissionCapMonthlyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommissionCapMonthly that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommissionCapMonthlyFindUniqueOrThrowArgs} args - Arguments to find a CommissionCapMonthly
     * @example
     * // Get one CommissionCapMonthly
     * const commissionCapMonthly = await prisma.commissionCapMonthly.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommissionCapMonthlyFindUniqueOrThrowArgs>(args: SelectSubset<T, CommissionCapMonthlyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommissionCapMonthlyClient<$Result.GetResult<Prisma.$CommissionCapMonthlyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommissionCapMonthly that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionCapMonthlyFindFirstArgs} args - Arguments to find a CommissionCapMonthly
     * @example
     * // Get one CommissionCapMonthly
     * const commissionCapMonthly = await prisma.commissionCapMonthly.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommissionCapMonthlyFindFirstArgs>(args?: SelectSubset<T, CommissionCapMonthlyFindFirstArgs<ExtArgs>>): Prisma__CommissionCapMonthlyClient<$Result.GetResult<Prisma.$CommissionCapMonthlyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommissionCapMonthly that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionCapMonthlyFindFirstOrThrowArgs} args - Arguments to find a CommissionCapMonthly
     * @example
     * // Get one CommissionCapMonthly
     * const commissionCapMonthly = await prisma.commissionCapMonthly.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommissionCapMonthlyFindFirstOrThrowArgs>(args?: SelectSubset<T, CommissionCapMonthlyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommissionCapMonthlyClient<$Result.GetResult<Prisma.$CommissionCapMonthlyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommissionCapMonthlies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionCapMonthlyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommissionCapMonthlies
     * const commissionCapMonthlies = await prisma.commissionCapMonthly.findMany()
     * 
     * // Get first 10 CommissionCapMonthlies
     * const commissionCapMonthlies = await prisma.commissionCapMonthly.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commissionCapMonthlyWithIdOnly = await prisma.commissionCapMonthly.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommissionCapMonthlyFindManyArgs>(args?: SelectSubset<T, CommissionCapMonthlyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionCapMonthlyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommissionCapMonthly.
     * @param {CommissionCapMonthlyCreateArgs} args - Arguments to create a CommissionCapMonthly.
     * @example
     * // Create one CommissionCapMonthly
     * const CommissionCapMonthly = await prisma.commissionCapMonthly.create({
     *   data: {
     *     // ... data to create a CommissionCapMonthly
     *   }
     * })
     * 
     */
    create<T extends CommissionCapMonthlyCreateArgs>(args: SelectSubset<T, CommissionCapMonthlyCreateArgs<ExtArgs>>): Prisma__CommissionCapMonthlyClient<$Result.GetResult<Prisma.$CommissionCapMonthlyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommissionCapMonthlies.
     * @param {CommissionCapMonthlyCreateManyArgs} args - Arguments to create many CommissionCapMonthlies.
     * @example
     * // Create many CommissionCapMonthlies
     * const commissionCapMonthly = await prisma.commissionCapMonthly.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommissionCapMonthlyCreateManyArgs>(args?: SelectSubset<T, CommissionCapMonthlyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommissionCapMonthlies and returns the data saved in the database.
     * @param {CommissionCapMonthlyCreateManyAndReturnArgs} args - Arguments to create many CommissionCapMonthlies.
     * @example
     * // Create many CommissionCapMonthlies
     * const commissionCapMonthly = await prisma.commissionCapMonthly.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommissionCapMonthlies and only return the `id`
     * const commissionCapMonthlyWithIdOnly = await prisma.commissionCapMonthly.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommissionCapMonthlyCreateManyAndReturnArgs>(args?: SelectSubset<T, CommissionCapMonthlyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionCapMonthlyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommissionCapMonthly.
     * @param {CommissionCapMonthlyDeleteArgs} args - Arguments to delete one CommissionCapMonthly.
     * @example
     * // Delete one CommissionCapMonthly
     * const CommissionCapMonthly = await prisma.commissionCapMonthly.delete({
     *   where: {
     *     // ... filter to delete one CommissionCapMonthly
     *   }
     * })
     * 
     */
    delete<T extends CommissionCapMonthlyDeleteArgs>(args: SelectSubset<T, CommissionCapMonthlyDeleteArgs<ExtArgs>>): Prisma__CommissionCapMonthlyClient<$Result.GetResult<Prisma.$CommissionCapMonthlyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommissionCapMonthly.
     * @param {CommissionCapMonthlyUpdateArgs} args - Arguments to update one CommissionCapMonthly.
     * @example
     * // Update one CommissionCapMonthly
     * const commissionCapMonthly = await prisma.commissionCapMonthly.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommissionCapMonthlyUpdateArgs>(args: SelectSubset<T, CommissionCapMonthlyUpdateArgs<ExtArgs>>): Prisma__CommissionCapMonthlyClient<$Result.GetResult<Prisma.$CommissionCapMonthlyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommissionCapMonthlies.
     * @param {CommissionCapMonthlyDeleteManyArgs} args - Arguments to filter CommissionCapMonthlies to delete.
     * @example
     * // Delete a few CommissionCapMonthlies
     * const { count } = await prisma.commissionCapMonthly.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommissionCapMonthlyDeleteManyArgs>(args?: SelectSubset<T, CommissionCapMonthlyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommissionCapMonthlies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionCapMonthlyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommissionCapMonthlies
     * const commissionCapMonthly = await prisma.commissionCapMonthly.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommissionCapMonthlyUpdateManyArgs>(args: SelectSubset<T, CommissionCapMonthlyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommissionCapMonthly.
     * @param {CommissionCapMonthlyUpsertArgs} args - Arguments to update or create a CommissionCapMonthly.
     * @example
     * // Update or create a CommissionCapMonthly
     * const commissionCapMonthly = await prisma.commissionCapMonthly.upsert({
     *   create: {
     *     // ... data to create a CommissionCapMonthly
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommissionCapMonthly we want to update
     *   }
     * })
     */
    upsert<T extends CommissionCapMonthlyUpsertArgs>(args: SelectSubset<T, CommissionCapMonthlyUpsertArgs<ExtArgs>>): Prisma__CommissionCapMonthlyClient<$Result.GetResult<Prisma.$CommissionCapMonthlyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommissionCapMonthlies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionCapMonthlyCountArgs} args - Arguments to filter CommissionCapMonthlies to count.
     * @example
     * // Count the number of CommissionCapMonthlies
     * const count = await prisma.commissionCapMonthly.count({
     *   where: {
     *     // ... the filter for the CommissionCapMonthlies we want to count
     *   }
     * })
    **/
    count<T extends CommissionCapMonthlyCountArgs>(
      args?: Subset<T, CommissionCapMonthlyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommissionCapMonthlyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommissionCapMonthly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionCapMonthlyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommissionCapMonthlyAggregateArgs>(args: Subset<T, CommissionCapMonthlyAggregateArgs>): Prisma.PrismaPromise<GetCommissionCapMonthlyAggregateType<T>>

    /**
     * Group by CommissionCapMonthly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionCapMonthlyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommissionCapMonthlyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommissionCapMonthlyGroupByArgs['orderBy'] }
        : { orderBy?: CommissionCapMonthlyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommissionCapMonthlyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommissionCapMonthlyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommissionCapMonthly model
   */
  readonly fields: CommissionCapMonthlyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommissionCapMonthly.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommissionCapMonthlyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommissionCapMonthly model
   */ 
  interface CommissionCapMonthlyFieldRefs {
    readonly id: FieldRef<"CommissionCapMonthly", 'String'>
    readonly creatorId: FieldRef<"CommissionCapMonthly", 'String'>
    readonly yearMonth: FieldRef<"CommissionCapMonthly", 'String'>
    readonly currency: FieldRef<"CommissionCapMonthly", 'String'>
    readonly capCents: FieldRef<"CommissionCapMonthly", 'BigInt'>
    readonly appliedCents: FieldRef<"CommissionCapMonthly", 'BigInt'>
    readonly createdAt: FieldRef<"CommissionCapMonthly", 'DateTime'>
    readonly updatedAt: FieldRef<"CommissionCapMonthly", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommissionCapMonthly findUnique
   */
  export type CommissionCapMonthlyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionCapMonthly
     */
    select?: CommissionCapMonthlySelect<ExtArgs> | null
    /**
     * Filter, which CommissionCapMonthly to fetch.
     */
    where: CommissionCapMonthlyWhereUniqueInput
  }

  /**
   * CommissionCapMonthly findUniqueOrThrow
   */
  export type CommissionCapMonthlyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionCapMonthly
     */
    select?: CommissionCapMonthlySelect<ExtArgs> | null
    /**
     * Filter, which CommissionCapMonthly to fetch.
     */
    where: CommissionCapMonthlyWhereUniqueInput
  }

  /**
   * CommissionCapMonthly findFirst
   */
  export type CommissionCapMonthlyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionCapMonthly
     */
    select?: CommissionCapMonthlySelect<ExtArgs> | null
    /**
     * Filter, which CommissionCapMonthly to fetch.
     */
    where?: CommissionCapMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionCapMonthlies to fetch.
     */
    orderBy?: CommissionCapMonthlyOrderByWithRelationInput | CommissionCapMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionCapMonthlies.
     */
    cursor?: CommissionCapMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionCapMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionCapMonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionCapMonthlies.
     */
    distinct?: CommissionCapMonthlyScalarFieldEnum | CommissionCapMonthlyScalarFieldEnum[]
  }

  /**
   * CommissionCapMonthly findFirstOrThrow
   */
  export type CommissionCapMonthlyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionCapMonthly
     */
    select?: CommissionCapMonthlySelect<ExtArgs> | null
    /**
     * Filter, which CommissionCapMonthly to fetch.
     */
    where?: CommissionCapMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionCapMonthlies to fetch.
     */
    orderBy?: CommissionCapMonthlyOrderByWithRelationInput | CommissionCapMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionCapMonthlies.
     */
    cursor?: CommissionCapMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionCapMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionCapMonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionCapMonthlies.
     */
    distinct?: CommissionCapMonthlyScalarFieldEnum | CommissionCapMonthlyScalarFieldEnum[]
  }

  /**
   * CommissionCapMonthly findMany
   */
  export type CommissionCapMonthlyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionCapMonthly
     */
    select?: CommissionCapMonthlySelect<ExtArgs> | null
    /**
     * Filter, which CommissionCapMonthlies to fetch.
     */
    where?: CommissionCapMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionCapMonthlies to fetch.
     */
    orderBy?: CommissionCapMonthlyOrderByWithRelationInput | CommissionCapMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommissionCapMonthlies.
     */
    cursor?: CommissionCapMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionCapMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionCapMonthlies.
     */
    skip?: number
    distinct?: CommissionCapMonthlyScalarFieldEnum | CommissionCapMonthlyScalarFieldEnum[]
  }

  /**
   * CommissionCapMonthly create
   */
  export type CommissionCapMonthlyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionCapMonthly
     */
    select?: CommissionCapMonthlySelect<ExtArgs> | null
    /**
     * The data needed to create a CommissionCapMonthly.
     */
    data: XOR<CommissionCapMonthlyCreateInput, CommissionCapMonthlyUncheckedCreateInput>
  }

  /**
   * CommissionCapMonthly createMany
   */
  export type CommissionCapMonthlyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommissionCapMonthlies.
     */
    data: CommissionCapMonthlyCreateManyInput | CommissionCapMonthlyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommissionCapMonthly createManyAndReturn
   */
  export type CommissionCapMonthlyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionCapMonthly
     */
    select?: CommissionCapMonthlySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommissionCapMonthlies.
     */
    data: CommissionCapMonthlyCreateManyInput | CommissionCapMonthlyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommissionCapMonthly update
   */
  export type CommissionCapMonthlyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionCapMonthly
     */
    select?: CommissionCapMonthlySelect<ExtArgs> | null
    /**
     * The data needed to update a CommissionCapMonthly.
     */
    data: XOR<CommissionCapMonthlyUpdateInput, CommissionCapMonthlyUncheckedUpdateInput>
    /**
     * Choose, which CommissionCapMonthly to update.
     */
    where: CommissionCapMonthlyWhereUniqueInput
  }

  /**
   * CommissionCapMonthly updateMany
   */
  export type CommissionCapMonthlyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommissionCapMonthlies.
     */
    data: XOR<CommissionCapMonthlyUpdateManyMutationInput, CommissionCapMonthlyUncheckedUpdateManyInput>
    /**
     * Filter which CommissionCapMonthlies to update
     */
    where?: CommissionCapMonthlyWhereInput
  }

  /**
   * CommissionCapMonthly upsert
   */
  export type CommissionCapMonthlyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionCapMonthly
     */
    select?: CommissionCapMonthlySelect<ExtArgs> | null
    /**
     * The filter to search for the CommissionCapMonthly to update in case it exists.
     */
    where: CommissionCapMonthlyWhereUniqueInput
    /**
     * In case the CommissionCapMonthly found by the `where` argument doesn't exist, create a new CommissionCapMonthly with this data.
     */
    create: XOR<CommissionCapMonthlyCreateInput, CommissionCapMonthlyUncheckedCreateInput>
    /**
     * In case the CommissionCapMonthly was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommissionCapMonthlyUpdateInput, CommissionCapMonthlyUncheckedUpdateInput>
  }

  /**
   * CommissionCapMonthly delete
   */
  export type CommissionCapMonthlyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionCapMonthly
     */
    select?: CommissionCapMonthlySelect<ExtArgs> | null
    /**
     * Filter which CommissionCapMonthly to delete.
     */
    where: CommissionCapMonthlyWhereUniqueInput
  }

  /**
   * CommissionCapMonthly deleteMany
   */
  export type CommissionCapMonthlyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionCapMonthlies to delete
     */
    where?: CommissionCapMonthlyWhereInput
  }

  /**
   * CommissionCapMonthly without action
   */
  export type CommissionCapMonthlyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionCapMonthly
     */
    select?: CommissionCapMonthlySelect<ExtArgs> | null
  }


  /**
   * Model ExternalEarningsSource
   */

  export type AggregateExternalEarningsSource = {
    _count: ExternalEarningsSourceCountAggregateOutputType | null
    _min: ExternalEarningsSourceMinAggregateOutputType | null
    _max: ExternalEarningsSourceMaxAggregateOutputType | null
  }

  export type ExternalEarningsSourceMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    platform: $Enums.ExternalPlatform | null
    externalHandle: string | null
    currency: string | null
    connectedAt: Date | null
    active: boolean | null
    lastSync: Date | null
  }

  export type ExternalEarningsSourceMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    platform: $Enums.ExternalPlatform | null
    externalHandle: string | null
    currency: string | null
    connectedAt: Date | null
    active: boolean | null
    lastSync: Date | null
  }

  export type ExternalEarningsSourceCountAggregateOutputType = {
    id: number
    creatorId: number
    platform: number
    externalHandle: number
    currency: number
    connectedAt: number
    active: number
    lastSync: number
    metadata: number
    _all: number
  }


  export type ExternalEarningsSourceMinAggregateInputType = {
    id?: true
    creatorId?: true
    platform?: true
    externalHandle?: true
    currency?: true
    connectedAt?: true
    active?: true
    lastSync?: true
  }

  export type ExternalEarningsSourceMaxAggregateInputType = {
    id?: true
    creatorId?: true
    platform?: true
    externalHandle?: true
    currency?: true
    connectedAt?: true
    active?: true
    lastSync?: true
  }

  export type ExternalEarningsSourceCountAggregateInputType = {
    id?: true
    creatorId?: true
    platform?: true
    externalHandle?: true
    currency?: true
    connectedAt?: true
    active?: true
    lastSync?: true
    metadata?: true
    _all?: true
  }

  export type ExternalEarningsSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalEarningsSource to aggregate.
     */
    where?: ExternalEarningsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalEarningsSources to fetch.
     */
    orderBy?: ExternalEarningsSourceOrderByWithRelationInput | ExternalEarningsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalEarningsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalEarningsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalEarningsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalEarningsSources
    **/
    _count?: true | ExternalEarningsSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalEarningsSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalEarningsSourceMaxAggregateInputType
  }

  export type GetExternalEarningsSourceAggregateType<T extends ExternalEarningsSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalEarningsSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalEarningsSource[P]>
      : GetScalarType<T[P], AggregateExternalEarningsSource[P]>
  }




  export type ExternalEarningsSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalEarningsSourceWhereInput
    orderBy?: ExternalEarningsSourceOrderByWithAggregationInput | ExternalEarningsSourceOrderByWithAggregationInput[]
    by: ExternalEarningsSourceScalarFieldEnum[] | ExternalEarningsSourceScalarFieldEnum
    having?: ExternalEarningsSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalEarningsSourceCountAggregateInputType | true
    _min?: ExternalEarningsSourceMinAggregateInputType
    _max?: ExternalEarningsSourceMaxAggregateInputType
  }

  export type ExternalEarningsSourceGroupByOutputType = {
    id: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    externalHandle: string
    currency: string
    connectedAt: Date
    active: boolean
    lastSync: Date | null
    metadata: JsonValue | null
    _count: ExternalEarningsSourceCountAggregateOutputType | null
    _min: ExternalEarningsSourceMinAggregateOutputType | null
    _max: ExternalEarningsSourceMaxAggregateOutputType | null
  }

  type GetExternalEarningsSourceGroupByPayload<T extends ExternalEarningsSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalEarningsSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalEarningsSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalEarningsSourceGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalEarningsSourceGroupByOutputType[P]>
        }
      >
    >


  export type ExternalEarningsSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    platform?: boolean
    externalHandle?: boolean
    currency?: boolean
    connectedAt?: boolean
    active?: boolean
    lastSync?: boolean
    metadata?: boolean
    imports?: boolean | ExternalEarningsSource$importsArgs<ExtArgs>
    earnings?: boolean | ExternalEarningsSource$earningsArgs<ExtArgs>
    _count?: boolean | ExternalEarningsSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalEarningsSource"]>

  export type ExternalEarningsSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    platform?: boolean
    externalHandle?: boolean
    currency?: boolean
    connectedAt?: boolean
    active?: boolean
    lastSync?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["externalEarningsSource"]>

  export type ExternalEarningsSourceSelectScalar = {
    id?: boolean
    creatorId?: boolean
    platform?: boolean
    externalHandle?: boolean
    currency?: boolean
    connectedAt?: boolean
    active?: boolean
    lastSync?: boolean
    metadata?: boolean
  }

  export type ExternalEarningsSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    imports?: boolean | ExternalEarningsSource$importsArgs<ExtArgs>
    earnings?: boolean | ExternalEarningsSource$earningsArgs<ExtArgs>
    _count?: boolean | ExternalEarningsSourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExternalEarningsSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExternalEarningsSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalEarningsSource"
    objects: {
      imports: Prisma.$ExternalEarningsImportPayload<ExtArgs>[]
      earnings: Prisma.$NormalizedEarningPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      platform: $Enums.ExternalPlatform
      externalHandle: string
      currency: string
      connectedAt: Date
      active: boolean
      lastSync: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["externalEarningsSource"]>
    composites: {}
  }

  type ExternalEarningsSourceGetPayload<S extends boolean | null | undefined | ExternalEarningsSourceDefaultArgs> = $Result.GetResult<Prisma.$ExternalEarningsSourcePayload, S>

  type ExternalEarningsSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExternalEarningsSourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExternalEarningsSourceCountAggregateInputType | true
    }

  export interface ExternalEarningsSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalEarningsSource'], meta: { name: 'ExternalEarningsSource' } }
    /**
     * Find zero or one ExternalEarningsSource that matches the filter.
     * @param {ExternalEarningsSourceFindUniqueArgs} args - Arguments to find a ExternalEarningsSource
     * @example
     * // Get one ExternalEarningsSource
     * const externalEarningsSource = await prisma.externalEarningsSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalEarningsSourceFindUniqueArgs>(args: SelectSubset<T, ExternalEarningsSourceFindUniqueArgs<ExtArgs>>): Prisma__ExternalEarningsSourceClient<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExternalEarningsSource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExternalEarningsSourceFindUniqueOrThrowArgs} args - Arguments to find a ExternalEarningsSource
     * @example
     * // Get one ExternalEarningsSource
     * const externalEarningsSource = await prisma.externalEarningsSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalEarningsSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalEarningsSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalEarningsSourceClient<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExternalEarningsSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsSourceFindFirstArgs} args - Arguments to find a ExternalEarningsSource
     * @example
     * // Get one ExternalEarningsSource
     * const externalEarningsSource = await prisma.externalEarningsSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalEarningsSourceFindFirstArgs>(args?: SelectSubset<T, ExternalEarningsSourceFindFirstArgs<ExtArgs>>): Prisma__ExternalEarningsSourceClient<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExternalEarningsSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsSourceFindFirstOrThrowArgs} args - Arguments to find a ExternalEarningsSource
     * @example
     * // Get one ExternalEarningsSource
     * const externalEarningsSource = await prisma.externalEarningsSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalEarningsSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalEarningsSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalEarningsSourceClient<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExternalEarningsSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalEarningsSources
     * const externalEarningsSources = await prisma.externalEarningsSource.findMany()
     * 
     * // Get first 10 ExternalEarningsSources
     * const externalEarningsSources = await prisma.externalEarningsSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalEarningsSourceWithIdOnly = await prisma.externalEarningsSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalEarningsSourceFindManyArgs>(args?: SelectSubset<T, ExternalEarningsSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExternalEarningsSource.
     * @param {ExternalEarningsSourceCreateArgs} args - Arguments to create a ExternalEarningsSource.
     * @example
     * // Create one ExternalEarningsSource
     * const ExternalEarningsSource = await prisma.externalEarningsSource.create({
     *   data: {
     *     // ... data to create a ExternalEarningsSource
     *   }
     * })
     * 
     */
    create<T extends ExternalEarningsSourceCreateArgs>(args: SelectSubset<T, ExternalEarningsSourceCreateArgs<ExtArgs>>): Prisma__ExternalEarningsSourceClient<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExternalEarningsSources.
     * @param {ExternalEarningsSourceCreateManyArgs} args - Arguments to create many ExternalEarningsSources.
     * @example
     * // Create many ExternalEarningsSources
     * const externalEarningsSource = await prisma.externalEarningsSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalEarningsSourceCreateManyArgs>(args?: SelectSubset<T, ExternalEarningsSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExternalEarningsSources and returns the data saved in the database.
     * @param {ExternalEarningsSourceCreateManyAndReturnArgs} args - Arguments to create many ExternalEarningsSources.
     * @example
     * // Create many ExternalEarningsSources
     * const externalEarningsSource = await prisma.externalEarningsSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExternalEarningsSources and only return the `id`
     * const externalEarningsSourceWithIdOnly = await prisma.externalEarningsSource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExternalEarningsSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ExternalEarningsSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExternalEarningsSource.
     * @param {ExternalEarningsSourceDeleteArgs} args - Arguments to delete one ExternalEarningsSource.
     * @example
     * // Delete one ExternalEarningsSource
     * const ExternalEarningsSource = await prisma.externalEarningsSource.delete({
     *   where: {
     *     // ... filter to delete one ExternalEarningsSource
     *   }
     * })
     * 
     */
    delete<T extends ExternalEarningsSourceDeleteArgs>(args: SelectSubset<T, ExternalEarningsSourceDeleteArgs<ExtArgs>>): Prisma__ExternalEarningsSourceClient<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExternalEarningsSource.
     * @param {ExternalEarningsSourceUpdateArgs} args - Arguments to update one ExternalEarningsSource.
     * @example
     * // Update one ExternalEarningsSource
     * const externalEarningsSource = await prisma.externalEarningsSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalEarningsSourceUpdateArgs>(args: SelectSubset<T, ExternalEarningsSourceUpdateArgs<ExtArgs>>): Prisma__ExternalEarningsSourceClient<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExternalEarningsSources.
     * @param {ExternalEarningsSourceDeleteManyArgs} args - Arguments to filter ExternalEarningsSources to delete.
     * @example
     * // Delete a few ExternalEarningsSources
     * const { count } = await prisma.externalEarningsSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalEarningsSourceDeleteManyArgs>(args?: SelectSubset<T, ExternalEarningsSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalEarningsSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalEarningsSources
     * const externalEarningsSource = await prisma.externalEarningsSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalEarningsSourceUpdateManyArgs>(args: SelectSubset<T, ExternalEarningsSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExternalEarningsSource.
     * @param {ExternalEarningsSourceUpsertArgs} args - Arguments to update or create a ExternalEarningsSource.
     * @example
     * // Update or create a ExternalEarningsSource
     * const externalEarningsSource = await prisma.externalEarningsSource.upsert({
     *   create: {
     *     // ... data to create a ExternalEarningsSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalEarningsSource we want to update
     *   }
     * })
     */
    upsert<T extends ExternalEarningsSourceUpsertArgs>(args: SelectSubset<T, ExternalEarningsSourceUpsertArgs<ExtArgs>>): Prisma__ExternalEarningsSourceClient<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExternalEarningsSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsSourceCountArgs} args - Arguments to filter ExternalEarningsSources to count.
     * @example
     * // Count the number of ExternalEarningsSources
     * const count = await prisma.externalEarningsSource.count({
     *   where: {
     *     // ... the filter for the ExternalEarningsSources we want to count
     *   }
     * })
    **/
    count<T extends ExternalEarningsSourceCountArgs>(
      args?: Subset<T, ExternalEarningsSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalEarningsSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalEarningsSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalEarningsSourceAggregateArgs>(args: Subset<T, ExternalEarningsSourceAggregateArgs>): Prisma.PrismaPromise<GetExternalEarningsSourceAggregateType<T>>

    /**
     * Group by ExternalEarningsSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalEarningsSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalEarningsSourceGroupByArgs['orderBy'] }
        : { orderBy?: ExternalEarningsSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalEarningsSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalEarningsSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalEarningsSource model
   */
  readonly fields: ExternalEarningsSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalEarningsSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalEarningsSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    imports<T extends ExternalEarningsSource$importsArgs<ExtArgs> = {}>(args?: Subset<T, ExternalEarningsSource$importsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalEarningsImportPayload<ExtArgs>, T, "findMany"> | Null>
    earnings<T extends ExternalEarningsSource$earningsArgs<ExtArgs> = {}>(args?: Subset<T, ExternalEarningsSource$earningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NormalizedEarningPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalEarningsSource model
   */ 
  interface ExternalEarningsSourceFieldRefs {
    readonly id: FieldRef<"ExternalEarningsSource", 'String'>
    readonly creatorId: FieldRef<"ExternalEarningsSource", 'String'>
    readonly platform: FieldRef<"ExternalEarningsSource", 'ExternalPlatform'>
    readonly externalHandle: FieldRef<"ExternalEarningsSource", 'String'>
    readonly currency: FieldRef<"ExternalEarningsSource", 'String'>
    readonly connectedAt: FieldRef<"ExternalEarningsSource", 'DateTime'>
    readonly active: FieldRef<"ExternalEarningsSource", 'Boolean'>
    readonly lastSync: FieldRef<"ExternalEarningsSource", 'DateTime'>
    readonly metadata: FieldRef<"ExternalEarningsSource", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ExternalEarningsSource findUnique
   */
  export type ExternalEarningsSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSource
     */
    select?: ExternalEarningsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsSourceInclude<ExtArgs> | null
    /**
     * Filter, which ExternalEarningsSource to fetch.
     */
    where: ExternalEarningsSourceWhereUniqueInput
  }

  /**
   * ExternalEarningsSource findUniqueOrThrow
   */
  export type ExternalEarningsSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSource
     */
    select?: ExternalEarningsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsSourceInclude<ExtArgs> | null
    /**
     * Filter, which ExternalEarningsSource to fetch.
     */
    where: ExternalEarningsSourceWhereUniqueInput
  }

  /**
   * ExternalEarningsSource findFirst
   */
  export type ExternalEarningsSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSource
     */
    select?: ExternalEarningsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsSourceInclude<ExtArgs> | null
    /**
     * Filter, which ExternalEarningsSource to fetch.
     */
    where?: ExternalEarningsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalEarningsSources to fetch.
     */
    orderBy?: ExternalEarningsSourceOrderByWithRelationInput | ExternalEarningsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalEarningsSources.
     */
    cursor?: ExternalEarningsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalEarningsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalEarningsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalEarningsSources.
     */
    distinct?: ExternalEarningsSourceScalarFieldEnum | ExternalEarningsSourceScalarFieldEnum[]
  }

  /**
   * ExternalEarningsSource findFirstOrThrow
   */
  export type ExternalEarningsSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSource
     */
    select?: ExternalEarningsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsSourceInclude<ExtArgs> | null
    /**
     * Filter, which ExternalEarningsSource to fetch.
     */
    where?: ExternalEarningsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalEarningsSources to fetch.
     */
    orderBy?: ExternalEarningsSourceOrderByWithRelationInput | ExternalEarningsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalEarningsSources.
     */
    cursor?: ExternalEarningsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalEarningsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalEarningsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalEarningsSources.
     */
    distinct?: ExternalEarningsSourceScalarFieldEnum | ExternalEarningsSourceScalarFieldEnum[]
  }

  /**
   * ExternalEarningsSource findMany
   */
  export type ExternalEarningsSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSource
     */
    select?: ExternalEarningsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsSourceInclude<ExtArgs> | null
    /**
     * Filter, which ExternalEarningsSources to fetch.
     */
    where?: ExternalEarningsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalEarningsSources to fetch.
     */
    orderBy?: ExternalEarningsSourceOrderByWithRelationInput | ExternalEarningsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalEarningsSources.
     */
    cursor?: ExternalEarningsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalEarningsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalEarningsSources.
     */
    skip?: number
    distinct?: ExternalEarningsSourceScalarFieldEnum | ExternalEarningsSourceScalarFieldEnum[]
  }

  /**
   * ExternalEarningsSource create
   */
  export type ExternalEarningsSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSource
     */
    select?: ExternalEarningsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a ExternalEarningsSource.
     */
    data: XOR<ExternalEarningsSourceCreateInput, ExternalEarningsSourceUncheckedCreateInput>
  }

  /**
   * ExternalEarningsSource createMany
   */
  export type ExternalEarningsSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalEarningsSources.
     */
    data: ExternalEarningsSourceCreateManyInput | ExternalEarningsSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalEarningsSource createManyAndReturn
   */
  export type ExternalEarningsSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSource
     */
    select?: ExternalEarningsSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExternalEarningsSources.
     */
    data: ExternalEarningsSourceCreateManyInput | ExternalEarningsSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalEarningsSource update
   */
  export type ExternalEarningsSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSource
     */
    select?: ExternalEarningsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a ExternalEarningsSource.
     */
    data: XOR<ExternalEarningsSourceUpdateInput, ExternalEarningsSourceUncheckedUpdateInput>
    /**
     * Choose, which ExternalEarningsSource to update.
     */
    where: ExternalEarningsSourceWhereUniqueInput
  }

  /**
   * ExternalEarningsSource updateMany
   */
  export type ExternalEarningsSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalEarningsSources.
     */
    data: XOR<ExternalEarningsSourceUpdateManyMutationInput, ExternalEarningsSourceUncheckedUpdateManyInput>
    /**
     * Filter which ExternalEarningsSources to update
     */
    where?: ExternalEarningsSourceWhereInput
  }

  /**
   * ExternalEarningsSource upsert
   */
  export type ExternalEarningsSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSource
     */
    select?: ExternalEarningsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the ExternalEarningsSource to update in case it exists.
     */
    where: ExternalEarningsSourceWhereUniqueInput
    /**
     * In case the ExternalEarningsSource found by the `where` argument doesn't exist, create a new ExternalEarningsSource with this data.
     */
    create: XOR<ExternalEarningsSourceCreateInput, ExternalEarningsSourceUncheckedCreateInput>
    /**
     * In case the ExternalEarningsSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalEarningsSourceUpdateInput, ExternalEarningsSourceUncheckedUpdateInput>
  }

  /**
   * ExternalEarningsSource delete
   */
  export type ExternalEarningsSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSource
     */
    select?: ExternalEarningsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsSourceInclude<ExtArgs> | null
    /**
     * Filter which ExternalEarningsSource to delete.
     */
    where: ExternalEarningsSourceWhereUniqueInput
  }

  /**
   * ExternalEarningsSource deleteMany
   */
  export type ExternalEarningsSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalEarningsSources to delete
     */
    where?: ExternalEarningsSourceWhereInput
  }

  /**
   * ExternalEarningsSource.imports
   */
  export type ExternalEarningsSource$importsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportInclude<ExtArgs> | null
    where?: ExternalEarningsImportWhereInput
    orderBy?: ExternalEarningsImportOrderByWithRelationInput | ExternalEarningsImportOrderByWithRelationInput[]
    cursor?: ExternalEarningsImportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExternalEarningsImportScalarFieldEnum | ExternalEarningsImportScalarFieldEnum[]
  }

  /**
   * ExternalEarningsSource.earnings
   */
  export type ExternalEarningsSource$earningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningInclude<ExtArgs> | null
    where?: NormalizedEarningWhereInput
    orderBy?: NormalizedEarningOrderByWithRelationInput | NormalizedEarningOrderByWithRelationInput[]
    cursor?: NormalizedEarningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NormalizedEarningScalarFieldEnum | NormalizedEarningScalarFieldEnum[]
  }

  /**
   * ExternalEarningsSource without action
   */
  export type ExternalEarningsSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsSource
     */
    select?: ExternalEarningsSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsSourceInclude<ExtArgs> | null
  }


  /**
   * Model ExternalEarningsImport
   */

  export type AggregateExternalEarningsImport = {
    _count: ExternalEarningsImportCountAggregateOutputType | null
    _min: ExternalEarningsImportMinAggregateOutputType | null
    _max: ExternalEarningsImportMaxAggregateOutputType | null
  }

  export type ExternalEarningsImportMinAggregateOutputType = {
    id: string | null
    sourceId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    rawHash: string | null
    processedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type ExternalEarningsImportMaxAggregateOutputType = {
    id: string | null
    sourceId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    rawHash: string | null
    processedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type ExternalEarningsImportCountAggregateOutputType = {
    id: number
    sourceId: number
    periodStart: number
    periodEnd: number
    rawHash: number
    rawJson: number
    processedAt: number
    errorMessage: number
    createdAt: number
    _all: number
  }


  export type ExternalEarningsImportMinAggregateInputType = {
    id?: true
    sourceId?: true
    periodStart?: true
    periodEnd?: true
    rawHash?: true
    processedAt?: true
    errorMessage?: true
    createdAt?: true
  }

  export type ExternalEarningsImportMaxAggregateInputType = {
    id?: true
    sourceId?: true
    periodStart?: true
    periodEnd?: true
    rawHash?: true
    processedAt?: true
    errorMessage?: true
    createdAt?: true
  }

  export type ExternalEarningsImportCountAggregateInputType = {
    id?: true
    sourceId?: true
    periodStart?: true
    periodEnd?: true
    rawHash?: true
    rawJson?: true
    processedAt?: true
    errorMessage?: true
    createdAt?: true
    _all?: true
  }

  export type ExternalEarningsImportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalEarningsImport to aggregate.
     */
    where?: ExternalEarningsImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalEarningsImports to fetch.
     */
    orderBy?: ExternalEarningsImportOrderByWithRelationInput | ExternalEarningsImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalEarningsImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalEarningsImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalEarningsImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalEarningsImports
    **/
    _count?: true | ExternalEarningsImportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalEarningsImportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalEarningsImportMaxAggregateInputType
  }

  export type GetExternalEarningsImportAggregateType<T extends ExternalEarningsImportAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalEarningsImport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalEarningsImport[P]>
      : GetScalarType<T[P], AggregateExternalEarningsImport[P]>
  }




  export type ExternalEarningsImportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalEarningsImportWhereInput
    orderBy?: ExternalEarningsImportOrderByWithAggregationInput | ExternalEarningsImportOrderByWithAggregationInput[]
    by: ExternalEarningsImportScalarFieldEnum[] | ExternalEarningsImportScalarFieldEnum
    having?: ExternalEarningsImportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalEarningsImportCountAggregateInputType | true
    _min?: ExternalEarningsImportMinAggregateInputType
    _max?: ExternalEarningsImportMaxAggregateInputType
  }

  export type ExternalEarningsImportGroupByOutputType = {
    id: string
    sourceId: string
    periodStart: Date
    periodEnd: Date
    rawHash: string
    rawJson: JsonValue
    processedAt: Date | null
    errorMessage: string | null
    createdAt: Date
    _count: ExternalEarningsImportCountAggregateOutputType | null
    _min: ExternalEarningsImportMinAggregateOutputType | null
    _max: ExternalEarningsImportMaxAggregateOutputType | null
  }

  type GetExternalEarningsImportGroupByPayload<T extends ExternalEarningsImportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalEarningsImportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalEarningsImportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalEarningsImportGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalEarningsImportGroupByOutputType[P]>
        }
      >
    >


  export type ExternalEarningsImportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    rawHash?: boolean
    rawJson?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    source?: boolean | ExternalEarningsSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalEarningsImport"]>

  export type ExternalEarningsImportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    rawHash?: boolean
    rawJson?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    source?: boolean | ExternalEarningsSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalEarningsImport"]>

  export type ExternalEarningsImportSelectScalar = {
    id?: boolean
    sourceId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    rawHash?: boolean
    rawJson?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }

  export type ExternalEarningsImportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | ExternalEarningsSourceDefaultArgs<ExtArgs>
  }
  export type ExternalEarningsImportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | ExternalEarningsSourceDefaultArgs<ExtArgs>
  }

  export type $ExternalEarningsImportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalEarningsImport"
    objects: {
      source: Prisma.$ExternalEarningsSourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceId: string
      periodStart: Date
      periodEnd: Date
      rawHash: string
      rawJson: Prisma.JsonValue
      processedAt: Date | null
      errorMessage: string | null
      createdAt: Date
    }, ExtArgs["result"]["externalEarningsImport"]>
    composites: {}
  }

  type ExternalEarningsImportGetPayload<S extends boolean | null | undefined | ExternalEarningsImportDefaultArgs> = $Result.GetResult<Prisma.$ExternalEarningsImportPayload, S>

  type ExternalEarningsImportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExternalEarningsImportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExternalEarningsImportCountAggregateInputType | true
    }

  export interface ExternalEarningsImportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalEarningsImport'], meta: { name: 'ExternalEarningsImport' } }
    /**
     * Find zero or one ExternalEarningsImport that matches the filter.
     * @param {ExternalEarningsImportFindUniqueArgs} args - Arguments to find a ExternalEarningsImport
     * @example
     * // Get one ExternalEarningsImport
     * const externalEarningsImport = await prisma.externalEarningsImport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalEarningsImportFindUniqueArgs>(args: SelectSubset<T, ExternalEarningsImportFindUniqueArgs<ExtArgs>>): Prisma__ExternalEarningsImportClient<$Result.GetResult<Prisma.$ExternalEarningsImportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExternalEarningsImport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExternalEarningsImportFindUniqueOrThrowArgs} args - Arguments to find a ExternalEarningsImport
     * @example
     * // Get one ExternalEarningsImport
     * const externalEarningsImport = await prisma.externalEarningsImport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalEarningsImportFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalEarningsImportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalEarningsImportClient<$Result.GetResult<Prisma.$ExternalEarningsImportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExternalEarningsImport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsImportFindFirstArgs} args - Arguments to find a ExternalEarningsImport
     * @example
     * // Get one ExternalEarningsImport
     * const externalEarningsImport = await prisma.externalEarningsImport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalEarningsImportFindFirstArgs>(args?: SelectSubset<T, ExternalEarningsImportFindFirstArgs<ExtArgs>>): Prisma__ExternalEarningsImportClient<$Result.GetResult<Prisma.$ExternalEarningsImportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExternalEarningsImport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsImportFindFirstOrThrowArgs} args - Arguments to find a ExternalEarningsImport
     * @example
     * // Get one ExternalEarningsImport
     * const externalEarningsImport = await prisma.externalEarningsImport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalEarningsImportFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalEarningsImportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalEarningsImportClient<$Result.GetResult<Prisma.$ExternalEarningsImportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExternalEarningsImports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsImportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalEarningsImports
     * const externalEarningsImports = await prisma.externalEarningsImport.findMany()
     * 
     * // Get first 10 ExternalEarningsImports
     * const externalEarningsImports = await prisma.externalEarningsImport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalEarningsImportWithIdOnly = await prisma.externalEarningsImport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalEarningsImportFindManyArgs>(args?: SelectSubset<T, ExternalEarningsImportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalEarningsImportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExternalEarningsImport.
     * @param {ExternalEarningsImportCreateArgs} args - Arguments to create a ExternalEarningsImport.
     * @example
     * // Create one ExternalEarningsImport
     * const ExternalEarningsImport = await prisma.externalEarningsImport.create({
     *   data: {
     *     // ... data to create a ExternalEarningsImport
     *   }
     * })
     * 
     */
    create<T extends ExternalEarningsImportCreateArgs>(args: SelectSubset<T, ExternalEarningsImportCreateArgs<ExtArgs>>): Prisma__ExternalEarningsImportClient<$Result.GetResult<Prisma.$ExternalEarningsImportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExternalEarningsImports.
     * @param {ExternalEarningsImportCreateManyArgs} args - Arguments to create many ExternalEarningsImports.
     * @example
     * // Create many ExternalEarningsImports
     * const externalEarningsImport = await prisma.externalEarningsImport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalEarningsImportCreateManyArgs>(args?: SelectSubset<T, ExternalEarningsImportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExternalEarningsImports and returns the data saved in the database.
     * @param {ExternalEarningsImportCreateManyAndReturnArgs} args - Arguments to create many ExternalEarningsImports.
     * @example
     * // Create many ExternalEarningsImports
     * const externalEarningsImport = await prisma.externalEarningsImport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExternalEarningsImports and only return the `id`
     * const externalEarningsImportWithIdOnly = await prisma.externalEarningsImport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExternalEarningsImportCreateManyAndReturnArgs>(args?: SelectSubset<T, ExternalEarningsImportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalEarningsImportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExternalEarningsImport.
     * @param {ExternalEarningsImportDeleteArgs} args - Arguments to delete one ExternalEarningsImport.
     * @example
     * // Delete one ExternalEarningsImport
     * const ExternalEarningsImport = await prisma.externalEarningsImport.delete({
     *   where: {
     *     // ... filter to delete one ExternalEarningsImport
     *   }
     * })
     * 
     */
    delete<T extends ExternalEarningsImportDeleteArgs>(args: SelectSubset<T, ExternalEarningsImportDeleteArgs<ExtArgs>>): Prisma__ExternalEarningsImportClient<$Result.GetResult<Prisma.$ExternalEarningsImportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExternalEarningsImport.
     * @param {ExternalEarningsImportUpdateArgs} args - Arguments to update one ExternalEarningsImport.
     * @example
     * // Update one ExternalEarningsImport
     * const externalEarningsImport = await prisma.externalEarningsImport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalEarningsImportUpdateArgs>(args: SelectSubset<T, ExternalEarningsImportUpdateArgs<ExtArgs>>): Prisma__ExternalEarningsImportClient<$Result.GetResult<Prisma.$ExternalEarningsImportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExternalEarningsImports.
     * @param {ExternalEarningsImportDeleteManyArgs} args - Arguments to filter ExternalEarningsImports to delete.
     * @example
     * // Delete a few ExternalEarningsImports
     * const { count } = await prisma.externalEarningsImport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalEarningsImportDeleteManyArgs>(args?: SelectSubset<T, ExternalEarningsImportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalEarningsImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsImportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalEarningsImports
     * const externalEarningsImport = await prisma.externalEarningsImport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalEarningsImportUpdateManyArgs>(args: SelectSubset<T, ExternalEarningsImportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExternalEarningsImport.
     * @param {ExternalEarningsImportUpsertArgs} args - Arguments to update or create a ExternalEarningsImport.
     * @example
     * // Update or create a ExternalEarningsImport
     * const externalEarningsImport = await prisma.externalEarningsImport.upsert({
     *   create: {
     *     // ... data to create a ExternalEarningsImport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalEarningsImport we want to update
     *   }
     * })
     */
    upsert<T extends ExternalEarningsImportUpsertArgs>(args: SelectSubset<T, ExternalEarningsImportUpsertArgs<ExtArgs>>): Prisma__ExternalEarningsImportClient<$Result.GetResult<Prisma.$ExternalEarningsImportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExternalEarningsImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsImportCountArgs} args - Arguments to filter ExternalEarningsImports to count.
     * @example
     * // Count the number of ExternalEarningsImports
     * const count = await prisma.externalEarningsImport.count({
     *   where: {
     *     // ... the filter for the ExternalEarningsImports we want to count
     *   }
     * })
    **/
    count<T extends ExternalEarningsImportCountArgs>(
      args?: Subset<T, ExternalEarningsImportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalEarningsImportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalEarningsImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsImportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalEarningsImportAggregateArgs>(args: Subset<T, ExternalEarningsImportAggregateArgs>): Prisma.PrismaPromise<GetExternalEarningsImportAggregateType<T>>

    /**
     * Group by ExternalEarningsImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalEarningsImportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalEarningsImportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalEarningsImportGroupByArgs['orderBy'] }
        : { orderBy?: ExternalEarningsImportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalEarningsImportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalEarningsImportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalEarningsImport model
   */
  readonly fields: ExternalEarningsImportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalEarningsImport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalEarningsImportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    source<T extends ExternalEarningsSourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExternalEarningsSourceDefaultArgs<ExtArgs>>): Prisma__ExternalEarningsSourceClient<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalEarningsImport model
   */ 
  interface ExternalEarningsImportFieldRefs {
    readonly id: FieldRef<"ExternalEarningsImport", 'String'>
    readonly sourceId: FieldRef<"ExternalEarningsImport", 'String'>
    readonly periodStart: FieldRef<"ExternalEarningsImport", 'DateTime'>
    readonly periodEnd: FieldRef<"ExternalEarningsImport", 'DateTime'>
    readonly rawHash: FieldRef<"ExternalEarningsImport", 'String'>
    readonly rawJson: FieldRef<"ExternalEarningsImport", 'Json'>
    readonly processedAt: FieldRef<"ExternalEarningsImport", 'DateTime'>
    readonly errorMessage: FieldRef<"ExternalEarningsImport", 'String'>
    readonly createdAt: FieldRef<"ExternalEarningsImport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExternalEarningsImport findUnique
   */
  export type ExternalEarningsImportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportInclude<ExtArgs> | null
    /**
     * Filter, which ExternalEarningsImport to fetch.
     */
    where: ExternalEarningsImportWhereUniqueInput
  }

  /**
   * ExternalEarningsImport findUniqueOrThrow
   */
  export type ExternalEarningsImportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportInclude<ExtArgs> | null
    /**
     * Filter, which ExternalEarningsImport to fetch.
     */
    where: ExternalEarningsImportWhereUniqueInput
  }

  /**
   * ExternalEarningsImport findFirst
   */
  export type ExternalEarningsImportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportInclude<ExtArgs> | null
    /**
     * Filter, which ExternalEarningsImport to fetch.
     */
    where?: ExternalEarningsImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalEarningsImports to fetch.
     */
    orderBy?: ExternalEarningsImportOrderByWithRelationInput | ExternalEarningsImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalEarningsImports.
     */
    cursor?: ExternalEarningsImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalEarningsImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalEarningsImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalEarningsImports.
     */
    distinct?: ExternalEarningsImportScalarFieldEnum | ExternalEarningsImportScalarFieldEnum[]
  }

  /**
   * ExternalEarningsImport findFirstOrThrow
   */
  export type ExternalEarningsImportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportInclude<ExtArgs> | null
    /**
     * Filter, which ExternalEarningsImport to fetch.
     */
    where?: ExternalEarningsImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalEarningsImports to fetch.
     */
    orderBy?: ExternalEarningsImportOrderByWithRelationInput | ExternalEarningsImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalEarningsImports.
     */
    cursor?: ExternalEarningsImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalEarningsImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalEarningsImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalEarningsImports.
     */
    distinct?: ExternalEarningsImportScalarFieldEnum | ExternalEarningsImportScalarFieldEnum[]
  }

  /**
   * ExternalEarningsImport findMany
   */
  export type ExternalEarningsImportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportInclude<ExtArgs> | null
    /**
     * Filter, which ExternalEarningsImports to fetch.
     */
    where?: ExternalEarningsImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalEarningsImports to fetch.
     */
    orderBy?: ExternalEarningsImportOrderByWithRelationInput | ExternalEarningsImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalEarningsImports.
     */
    cursor?: ExternalEarningsImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalEarningsImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalEarningsImports.
     */
    skip?: number
    distinct?: ExternalEarningsImportScalarFieldEnum | ExternalEarningsImportScalarFieldEnum[]
  }

  /**
   * ExternalEarningsImport create
   */
  export type ExternalEarningsImportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportInclude<ExtArgs> | null
    /**
     * The data needed to create a ExternalEarningsImport.
     */
    data: XOR<ExternalEarningsImportCreateInput, ExternalEarningsImportUncheckedCreateInput>
  }

  /**
   * ExternalEarningsImport createMany
   */
  export type ExternalEarningsImportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalEarningsImports.
     */
    data: ExternalEarningsImportCreateManyInput | ExternalEarningsImportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalEarningsImport createManyAndReturn
   */
  export type ExternalEarningsImportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExternalEarningsImports.
     */
    data: ExternalEarningsImportCreateManyInput | ExternalEarningsImportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalEarningsImport update
   */
  export type ExternalEarningsImportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportInclude<ExtArgs> | null
    /**
     * The data needed to update a ExternalEarningsImport.
     */
    data: XOR<ExternalEarningsImportUpdateInput, ExternalEarningsImportUncheckedUpdateInput>
    /**
     * Choose, which ExternalEarningsImport to update.
     */
    where: ExternalEarningsImportWhereUniqueInput
  }

  /**
   * ExternalEarningsImport updateMany
   */
  export type ExternalEarningsImportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalEarningsImports.
     */
    data: XOR<ExternalEarningsImportUpdateManyMutationInput, ExternalEarningsImportUncheckedUpdateManyInput>
    /**
     * Filter which ExternalEarningsImports to update
     */
    where?: ExternalEarningsImportWhereInput
  }

  /**
   * ExternalEarningsImport upsert
   */
  export type ExternalEarningsImportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportInclude<ExtArgs> | null
    /**
     * The filter to search for the ExternalEarningsImport to update in case it exists.
     */
    where: ExternalEarningsImportWhereUniqueInput
    /**
     * In case the ExternalEarningsImport found by the `where` argument doesn't exist, create a new ExternalEarningsImport with this data.
     */
    create: XOR<ExternalEarningsImportCreateInput, ExternalEarningsImportUncheckedCreateInput>
    /**
     * In case the ExternalEarningsImport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalEarningsImportUpdateInput, ExternalEarningsImportUncheckedUpdateInput>
  }

  /**
   * ExternalEarningsImport delete
   */
  export type ExternalEarningsImportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportInclude<ExtArgs> | null
    /**
     * Filter which ExternalEarningsImport to delete.
     */
    where: ExternalEarningsImportWhereUniqueInput
  }

  /**
   * ExternalEarningsImport deleteMany
   */
  export type ExternalEarningsImportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalEarningsImports to delete
     */
    where?: ExternalEarningsImportWhereInput
  }

  /**
   * ExternalEarningsImport without action
   */
  export type ExternalEarningsImportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalEarningsImport
     */
    select?: ExternalEarningsImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalEarningsImportInclude<ExtArgs> | null
  }


  /**
   * Model NormalizedEarning
   */

  export type AggregateNormalizedEarning = {
    _count: NormalizedEarningCountAggregateOutputType | null
    _avg: NormalizedEarningAvgAggregateOutputType | null
    _sum: NormalizedEarningSumAggregateOutputType | null
    _min: NormalizedEarningMinAggregateOutputType | null
    _max: NormalizedEarningMaxAggregateOutputType | null
  }

  export type NormalizedEarningAvgAggregateOutputType = {
    grossCents: number | null
    feesCents: number | null
    netCents: number | null
  }

  export type NormalizedEarningSumAggregateOutputType = {
    grossCents: bigint | null
    feesCents: bigint | null
    netCents: bigint | null
  }

  export type NormalizedEarningMinAggregateOutputType = {
    id: string | null
    sourceId: string | null
    occurredAt: Date | null
    currency: string | null
    grossCents: bigint | null
    feesCents: bigint | null
    netCents: bigint | null
    payoutId: string | null
    extRef: string | null
    createdAt: Date | null
  }

  export type NormalizedEarningMaxAggregateOutputType = {
    id: string | null
    sourceId: string | null
    occurredAt: Date | null
    currency: string | null
    grossCents: bigint | null
    feesCents: bigint | null
    netCents: bigint | null
    payoutId: string | null
    extRef: string | null
    createdAt: Date | null
  }

  export type NormalizedEarningCountAggregateOutputType = {
    id: number
    sourceId: number
    occurredAt: number
    currency: number
    grossCents: number
    feesCents: number
    netCents: number
    payoutId: number
    extRef: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type NormalizedEarningAvgAggregateInputType = {
    grossCents?: true
    feesCents?: true
    netCents?: true
  }

  export type NormalizedEarningSumAggregateInputType = {
    grossCents?: true
    feesCents?: true
    netCents?: true
  }

  export type NormalizedEarningMinAggregateInputType = {
    id?: true
    sourceId?: true
    occurredAt?: true
    currency?: true
    grossCents?: true
    feesCents?: true
    netCents?: true
    payoutId?: true
    extRef?: true
    createdAt?: true
  }

  export type NormalizedEarningMaxAggregateInputType = {
    id?: true
    sourceId?: true
    occurredAt?: true
    currency?: true
    grossCents?: true
    feesCents?: true
    netCents?: true
    payoutId?: true
    extRef?: true
    createdAt?: true
  }

  export type NormalizedEarningCountAggregateInputType = {
    id?: true
    sourceId?: true
    occurredAt?: true
    currency?: true
    grossCents?: true
    feesCents?: true
    netCents?: true
    payoutId?: true
    extRef?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type NormalizedEarningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NormalizedEarning to aggregate.
     */
    where?: NormalizedEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NormalizedEarnings to fetch.
     */
    orderBy?: NormalizedEarningOrderByWithRelationInput | NormalizedEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NormalizedEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NormalizedEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NormalizedEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NormalizedEarnings
    **/
    _count?: true | NormalizedEarningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NormalizedEarningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NormalizedEarningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NormalizedEarningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NormalizedEarningMaxAggregateInputType
  }

  export type GetNormalizedEarningAggregateType<T extends NormalizedEarningAggregateArgs> = {
        [P in keyof T & keyof AggregateNormalizedEarning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNormalizedEarning[P]>
      : GetScalarType<T[P], AggregateNormalizedEarning[P]>
  }




  export type NormalizedEarningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NormalizedEarningWhereInput
    orderBy?: NormalizedEarningOrderByWithAggregationInput | NormalizedEarningOrderByWithAggregationInput[]
    by: NormalizedEarningScalarFieldEnum[] | NormalizedEarningScalarFieldEnum
    having?: NormalizedEarningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NormalizedEarningCountAggregateInputType | true
    _avg?: NormalizedEarningAvgAggregateInputType
    _sum?: NormalizedEarningSumAggregateInputType
    _min?: NormalizedEarningMinAggregateInputType
    _max?: NormalizedEarningMaxAggregateInputType
  }

  export type NormalizedEarningGroupByOutputType = {
    id: string
    sourceId: string
    occurredAt: Date
    currency: string
    grossCents: bigint
    feesCents: bigint
    netCents: bigint
    payoutId: string | null
    extRef: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: NormalizedEarningCountAggregateOutputType | null
    _avg: NormalizedEarningAvgAggregateOutputType | null
    _sum: NormalizedEarningSumAggregateOutputType | null
    _min: NormalizedEarningMinAggregateOutputType | null
    _max: NormalizedEarningMaxAggregateOutputType | null
  }

  type GetNormalizedEarningGroupByPayload<T extends NormalizedEarningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NormalizedEarningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NormalizedEarningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NormalizedEarningGroupByOutputType[P]>
            : GetScalarType<T[P], NormalizedEarningGroupByOutputType[P]>
        }
      >
    >


  export type NormalizedEarningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    occurredAt?: boolean
    currency?: boolean
    grossCents?: boolean
    feesCents?: boolean
    netCents?: boolean
    payoutId?: boolean
    extRef?: boolean
    metadata?: boolean
    createdAt?: boolean
    source?: boolean | ExternalEarningsSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["normalizedEarning"]>

  export type NormalizedEarningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    occurredAt?: boolean
    currency?: boolean
    grossCents?: boolean
    feesCents?: boolean
    netCents?: boolean
    payoutId?: boolean
    extRef?: boolean
    metadata?: boolean
    createdAt?: boolean
    source?: boolean | ExternalEarningsSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["normalizedEarning"]>

  export type NormalizedEarningSelectScalar = {
    id?: boolean
    sourceId?: boolean
    occurredAt?: boolean
    currency?: boolean
    grossCents?: boolean
    feesCents?: boolean
    netCents?: boolean
    payoutId?: boolean
    extRef?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type NormalizedEarningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | ExternalEarningsSourceDefaultArgs<ExtArgs>
  }
  export type NormalizedEarningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | ExternalEarningsSourceDefaultArgs<ExtArgs>
  }

  export type $NormalizedEarningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NormalizedEarning"
    objects: {
      source: Prisma.$ExternalEarningsSourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceId: string
      occurredAt: Date
      currency: string
      grossCents: bigint
      feesCents: bigint
      netCents: bigint
      payoutId: string | null
      extRef: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["normalizedEarning"]>
    composites: {}
  }

  type NormalizedEarningGetPayload<S extends boolean | null | undefined | NormalizedEarningDefaultArgs> = $Result.GetResult<Prisma.$NormalizedEarningPayload, S>

  type NormalizedEarningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NormalizedEarningFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NormalizedEarningCountAggregateInputType | true
    }

  export interface NormalizedEarningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NormalizedEarning'], meta: { name: 'NormalizedEarning' } }
    /**
     * Find zero or one NormalizedEarning that matches the filter.
     * @param {NormalizedEarningFindUniqueArgs} args - Arguments to find a NormalizedEarning
     * @example
     * // Get one NormalizedEarning
     * const normalizedEarning = await prisma.normalizedEarning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NormalizedEarningFindUniqueArgs>(args: SelectSubset<T, NormalizedEarningFindUniqueArgs<ExtArgs>>): Prisma__NormalizedEarningClient<$Result.GetResult<Prisma.$NormalizedEarningPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NormalizedEarning that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NormalizedEarningFindUniqueOrThrowArgs} args - Arguments to find a NormalizedEarning
     * @example
     * // Get one NormalizedEarning
     * const normalizedEarning = await prisma.normalizedEarning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NormalizedEarningFindUniqueOrThrowArgs>(args: SelectSubset<T, NormalizedEarningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NormalizedEarningClient<$Result.GetResult<Prisma.$NormalizedEarningPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NormalizedEarning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedEarningFindFirstArgs} args - Arguments to find a NormalizedEarning
     * @example
     * // Get one NormalizedEarning
     * const normalizedEarning = await prisma.normalizedEarning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NormalizedEarningFindFirstArgs>(args?: SelectSubset<T, NormalizedEarningFindFirstArgs<ExtArgs>>): Prisma__NormalizedEarningClient<$Result.GetResult<Prisma.$NormalizedEarningPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NormalizedEarning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedEarningFindFirstOrThrowArgs} args - Arguments to find a NormalizedEarning
     * @example
     * // Get one NormalizedEarning
     * const normalizedEarning = await prisma.normalizedEarning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NormalizedEarningFindFirstOrThrowArgs>(args?: SelectSubset<T, NormalizedEarningFindFirstOrThrowArgs<ExtArgs>>): Prisma__NormalizedEarningClient<$Result.GetResult<Prisma.$NormalizedEarningPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NormalizedEarnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedEarningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NormalizedEarnings
     * const normalizedEarnings = await prisma.normalizedEarning.findMany()
     * 
     * // Get first 10 NormalizedEarnings
     * const normalizedEarnings = await prisma.normalizedEarning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const normalizedEarningWithIdOnly = await prisma.normalizedEarning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NormalizedEarningFindManyArgs>(args?: SelectSubset<T, NormalizedEarningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NormalizedEarningPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NormalizedEarning.
     * @param {NormalizedEarningCreateArgs} args - Arguments to create a NormalizedEarning.
     * @example
     * // Create one NormalizedEarning
     * const NormalizedEarning = await prisma.normalizedEarning.create({
     *   data: {
     *     // ... data to create a NormalizedEarning
     *   }
     * })
     * 
     */
    create<T extends NormalizedEarningCreateArgs>(args: SelectSubset<T, NormalizedEarningCreateArgs<ExtArgs>>): Prisma__NormalizedEarningClient<$Result.GetResult<Prisma.$NormalizedEarningPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NormalizedEarnings.
     * @param {NormalizedEarningCreateManyArgs} args - Arguments to create many NormalizedEarnings.
     * @example
     * // Create many NormalizedEarnings
     * const normalizedEarning = await prisma.normalizedEarning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NormalizedEarningCreateManyArgs>(args?: SelectSubset<T, NormalizedEarningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NormalizedEarnings and returns the data saved in the database.
     * @param {NormalizedEarningCreateManyAndReturnArgs} args - Arguments to create many NormalizedEarnings.
     * @example
     * // Create many NormalizedEarnings
     * const normalizedEarning = await prisma.normalizedEarning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NormalizedEarnings and only return the `id`
     * const normalizedEarningWithIdOnly = await prisma.normalizedEarning.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NormalizedEarningCreateManyAndReturnArgs>(args?: SelectSubset<T, NormalizedEarningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NormalizedEarningPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NormalizedEarning.
     * @param {NormalizedEarningDeleteArgs} args - Arguments to delete one NormalizedEarning.
     * @example
     * // Delete one NormalizedEarning
     * const NormalizedEarning = await prisma.normalizedEarning.delete({
     *   where: {
     *     // ... filter to delete one NormalizedEarning
     *   }
     * })
     * 
     */
    delete<T extends NormalizedEarningDeleteArgs>(args: SelectSubset<T, NormalizedEarningDeleteArgs<ExtArgs>>): Prisma__NormalizedEarningClient<$Result.GetResult<Prisma.$NormalizedEarningPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NormalizedEarning.
     * @param {NormalizedEarningUpdateArgs} args - Arguments to update one NormalizedEarning.
     * @example
     * // Update one NormalizedEarning
     * const normalizedEarning = await prisma.normalizedEarning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NormalizedEarningUpdateArgs>(args: SelectSubset<T, NormalizedEarningUpdateArgs<ExtArgs>>): Prisma__NormalizedEarningClient<$Result.GetResult<Prisma.$NormalizedEarningPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NormalizedEarnings.
     * @param {NormalizedEarningDeleteManyArgs} args - Arguments to filter NormalizedEarnings to delete.
     * @example
     * // Delete a few NormalizedEarnings
     * const { count } = await prisma.normalizedEarning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NormalizedEarningDeleteManyArgs>(args?: SelectSubset<T, NormalizedEarningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NormalizedEarnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedEarningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NormalizedEarnings
     * const normalizedEarning = await prisma.normalizedEarning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NormalizedEarningUpdateManyArgs>(args: SelectSubset<T, NormalizedEarningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NormalizedEarning.
     * @param {NormalizedEarningUpsertArgs} args - Arguments to update or create a NormalizedEarning.
     * @example
     * // Update or create a NormalizedEarning
     * const normalizedEarning = await prisma.normalizedEarning.upsert({
     *   create: {
     *     // ... data to create a NormalizedEarning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NormalizedEarning we want to update
     *   }
     * })
     */
    upsert<T extends NormalizedEarningUpsertArgs>(args: SelectSubset<T, NormalizedEarningUpsertArgs<ExtArgs>>): Prisma__NormalizedEarningClient<$Result.GetResult<Prisma.$NormalizedEarningPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NormalizedEarnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedEarningCountArgs} args - Arguments to filter NormalizedEarnings to count.
     * @example
     * // Count the number of NormalizedEarnings
     * const count = await prisma.normalizedEarning.count({
     *   where: {
     *     // ... the filter for the NormalizedEarnings we want to count
     *   }
     * })
    **/
    count<T extends NormalizedEarningCountArgs>(
      args?: Subset<T, NormalizedEarningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NormalizedEarningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NormalizedEarning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedEarningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NormalizedEarningAggregateArgs>(args: Subset<T, NormalizedEarningAggregateArgs>): Prisma.PrismaPromise<GetNormalizedEarningAggregateType<T>>

    /**
     * Group by NormalizedEarning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalizedEarningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NormalizedEarningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NormalizedEarningGroupByArgs['orderBy'] }
        : { orderBy?: NormalizedEarningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NormalizedEarningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNormalizedEarningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NormalizedEarning model
   */
  readonly fields: NormalizedEarningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NormalizedEarning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NormalizedEarningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    source<T extends ExternalEarningsSourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExternalEarningsSourceDefaultArgs<ExtArgs>>): Prisma__ExternalEarningsSourceClient<$Result.GetResult<Prisma.$ExternalEarningsSourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NormalizedEarning model
   */ 
  interface NormalizedEarningFieldRefs {
    readonly id: FieldRef<"NormalizedEarning", 'String'>
    readonly sourceId: FieldRef<"NormalizedEarning", 'String'>
    readonly occurredAt: FieldRef<"NormalizedEarning", 'DateTime'>
    readonly currency: FieldRef<"NormalizedEarning", 'String'>
    readonly grossCents: FieldRef<"NormalizedEarning", 'BigInt'>
    readonly feesCents: FieldRef<"NormalizedEarning", 'BigInt'>
    readonly netCents: FieldRef<"NormalizedEarning", 'BigInt'>
    readonly payoutId: FieldRef<"NormalizedEarning", 'String'>
    readonly extRef: FieldRef<"NormalizedEarning", 'String'>
    readonly metadata: FieldRef<"NormalizedEarning", 'Json'>
    readonly createdAt: FieldRef<"NormalizedEarning", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NormalizedEarning findUnique
   */
  export type NormalizedEarningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningInclude<ExtArgs> | null
    /**
     * Filter, which NormalizedEarning to fetch.
     */
    where: NormalizedEarningWhereUniqueInput
  }

  /**
   * NormalizedEarning findUniqueOrThrow
   */
  export type NormalizedEarningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningInclude<ExtArgs> | null
    /**
     * Filter, which NormalizedEarning to fetch.
     */
    where: NormalizedEarningWhereUniqueInput
  }

  /**
   * NormalizedEarning findFirst
   */
  export type NormalizedEarningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningInclude<ExtArgs> | null
    /**
     * Filter, which NormalizedEarning to fetch.
     */
    where?: NormalizedEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NormalizedEarnings to fetch.
     */
    orderBy?: NormalizedEarningOrderByWithRelationInput | NormalizedEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NormalizedEarnings.
     */
    cursor?: NormalizedEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NormalizedEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NormalizedEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NormalizedEarnings.
     */
    distinct?: NormalizedEarningScalarFieldEnum | NormalizedEarningScalarFieldEnum[]
  }

  /**
   * NormalizedEarning findFirstOrThrow
   */
  export type NormalizedEarningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningInclude<ExtArgs> | null
    /**
     * Filter, which NormalizedEarning to fetch.
     */
    where?: NormalizedEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NormalizedEarnings to fetch.
     */
    orderBy?: NormalizedEarningOrderByWithRelationInput | NormalizedEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NormalizedEarnings.
     */
    cursor?: NormalizedEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NormalizedEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NormalizedEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NormalizedEarnings.
     */
    distinct?: NormalizedEarningScalarFieldEnum | NormalizedEarningScalarFieldEnum[]
  }

  /**
   * NormalizedEarning findMany
   */
  export type NormalizedEarningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningInclude<ExtArgs> | null
    /**
     * Filter, which NormalizedEarnings to fetch.
     */
    where?: NormalizedEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NormalizedEarnings to fetch.
     */
    orderBy?: NormalizedEarningOrderByWithRelationInput | NormalizedEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NormalizedEarnings.
     */
    cursor?: NormalizedEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NormalizedEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NormalizedEarnings.
     */
    skip?: number
    distinct?: NormalizedEarningScalarFieldEnum | NormalizedEarningScalarFieldEnum[]
  }

  /**
   * NormalizedEarning create
   */
  export type NormalizedEarningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningInclude<ExtArgs> | null
    /**
     * The data needed to create a NormalizedEarning.
     */
    data: XOR<NormalizedEarningCreateInput, NormalizedEarningUncheckedCreateInput>
  }

  /**
   * NormalizedEarning createMany
   */
  export type NormalizedEarningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NormalizedEarnings.
     */
    data: NormalizedEarningCreateManyInput | NormalizedEarningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NormalizedEarning createManyAndReturn
   */
  export type NormalizedEarningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NormalizedEarnings.
     */
    data: NormalizedEarningCreateManyInput | NormalizedEarningCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NormalizedEarning update
   */
  export type NormalizedEarningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningInclude<ExtArgs> | null
    /**
     * The data needed to update a NormalizedEarning.
     */
    data: XOR<NormalizedEarningUpdateInput, NormalizedEarningUncheckedUpdateInput>
    /**
     * Choose, which NormalizedEarning to update.
     */
    where: NormalizedEarningWhereUniqueInput
  }

  /**
   * NormalizedEarning updateMany
   */
  export type NormalizedEarningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NormalizedEarnings.
     */
    data: XOR<NormalizedEarningUpdateManyMutationInput, NormalizedEarningUncheckedUpdateManyInput>
    /**
     * Filter which NormalizedEarnings to update
     */
    where?: NormalizedEarningWhereInput
  }

  /**
   * NormalizedEarning upsert
   */
  export type NormalizedEarningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningInclude<ExtArgs> | null
    /**
     * The filter to search for the NormalizedEarning to update in case it exists.
     */
    where: NormalizedEarningWhereUniqueInput
    /**
     * In case the NormalizedEarning found by the `where` argument doesn't exist, create a new NormalizedEarning with this data.
     */
    create: XOR<NormalizedEarningCreateInput, NormalizedEarningUncheckedCreateInput>
    /**
     * In case the NormalizedEarning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NormalizedEarningUpdateInput, NormalizedEarningUncheckedUpdateInput>
  }

  /**
   * NormalizedEarning delete
   */
  export type NormalizedEarningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningInclude<ExtArgs> | null
    /**
     * Filter which NormalizedEarning to delete.
     */
    where: NormalizedEarningWhereUniqueInput
  }

  /**
   * NormalizedEarning deleteMany
   */
  export type NormalizedEarningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NormalizedEarnings to delete
     */
    where?: NormalizedEarningWhereInput
  }

  /**
   * NormalizedEarning without action
   */
  export type NormalizedEarningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NormalizedEarning
     */
    select?: NormalizedEarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NormalizedEarningInclude<ExtArgs> | null
  }


  /**
   * Model CommissionStatement
   */

  export type AggregateCommissionStatement = {
    _count: CommissionStatementCountAggregateOutputType | null
    _avg: CommissionStatementAvgAggregateOutputType | null
    _sum: CommissionStatementSumAggregateOutputType | null
    _min: CommissionStatementMinAggregateOutputType | null
    _max: CommissionStatementMaxAggregateOutputType | null
  }

  export type CommissionStatementAvgAggregateOutputType = {
    baseNetCents: number | null
    rateBps: number | null
    commissionCents: number | null
    capAppliedCents: number | null
    finalCents: number | null
  }

  export type CommissionStatementSumAggregateOutputType = {
    baseNetCents: bigint | null
    rateBps: number | null
    commissionCents: bigint | null
    capAppliedCents: bigint | null
    finalCents: bigint | null
  }

  export type CommissionStatementMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    platform: $Enums.ExternalPlatform | null
    yearMonth: string | null
    currency: string | null
    baseNetCents: bigint | null
    rateBps: number | null
    commissionCents: bigint | null
    capAppliedCents: bigint | null
    finalCents: bigint | null
    closedAt: Date | null
    invoicedAt: Date | null
    stripeInvoiceId: string | null
    paidAt: Date | null
    writeOffAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommissionStatementMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    platform: $Enums.ExternalPlatform | null
    yearMonth: string | null
    currency: string | null
    baseNetCents: bigint | null
    rateBps: number | null
    commissionCents: bigint | null
    capAppliedCents: bigint | null
    finalCents: bigint | null
    closedAt: Date | null
    invoicedAt: Date | null
    stripeInvoiceId: string | null
    paidAt: Date | null
    writeOffAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommissionStatementCountAggregateOutputType = {
    id: number
    creatorId: number
    platform: number
    yearMonth: number
    currency: number
    baseNetCents: number
    rateBps: number
    commissionCents: number
    capAppliedCents: number
    finalCents: number
    closedAt: number
    invoicedAt: number
    stripeInvoiceId: number
    paidAt: number
    writeOffAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommissionStatementAvgAggregateInputType = {
    baseNetCents?: true
    rateBps?: true
    commissionCents?: true
    capAppliedCents?: true
    finalCents?: true
  }

  export type CommissionStatementSumAggregateInputType = {
    baseNetCents?: true
    rateBps?: true
    commissionCents?: true
    capAppliedCents?: true
    finalCents?: true
  }

  export type CommissionStatementMinAggregateInputType = {
    id?: true
    creatorId?: true
    platform?: true
    yearMonth?: true
    currency?: true
    baseNetCents?: true
    rateBps?: true
    commissionCents?: true
    capAppliedCents?: true
    finalCents?: true
    closedAt?: true
    invoicedAt?: true
    stripeInvoiceId?: true
    paidAt?: true
    writeOffAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommissionStatementMaxAggregateInputType = {
    id?: true
    creatorId?: true
    platform?: true
    yearMonth?: true
    currency?: true
    baseNetCents?: true
    rateBps?: true
    commissionCents?: true
    capAppliedCents?: true
    finalCents?: true
    closedAt?: true
    invoicedAt?: true
    stripeInvoiceId?: true
    paidAt?: true
    writeOffAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommissionStatementCountAggregateInputType = {
    id?: true
    creatorId?: true
    platform?: true
    yearMonth?: true
    currency?: true
    baseNetCents?: true
    rateBps?: true
    commissionCents?: true
    capAppliedCents?: true
    finalCents?: true
    closedAt?: true
    invoicedAt?: true
    stripeInvoiceId?: true
    paidAt?: true
    writeOffAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommissionStatementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionStatement to aggregate.
     */
    where?: CommissionStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionStatements to fetch.
     */
    orderBy?: CommissionStatementOrderByWithRelationInput | CommissionStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommissionStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommissionStatements
    **/
    _count?: true | CommissionStatementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommissionStatementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommissionStatementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommissionStatementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommissionStatementMaxAggregateInputType
  }

  export type GetCommissionStatementAggregateType<T extends CommissionStatementAggregateArgs> = {
        [P in keyof T & keyof AggregateCommissionStatement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommissionStatement[P]>
      : GetScalarType<T[P], AggregateCommissionStatement[P]>
  }




  export type CommissionStatementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionStatementWhereInput
    orderBy?: CommissionStatementOrderByWithAggregationInput | CommissionStatementOrderByWithAggregationInput[]
    by: CommissionStatementScalarFieldEnum[] | CommissionStatementScalarFieldEnum
    having?: CommissionStatementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommissionStatementCountAggregateInputType | true
    _avg?: CommissionStatementAvgAggregateInputType
    _sum?: CommissionStatementSumAggregateInputType
    _min?: CommissionStatementMinAggregateInputType
    _max?: CommissionStatementMaxAggregateInputType
  }

  export type CommissionStatementGroupByOutputType = {
    id: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    yearMonth: string
    currency: string
    baseNetCents: bigint
    rateBps: number
    commissionCents: bigint
    capAppliedCents: bigint
    finalCents: bigint
    closedAt: Date | null
    invoicedAt: Date | null
    stripeInvoiceId: string | null
    paidAt: Date | null
    writeOffAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CommissionStatementCountAggregateOutputType | null
    _avg: CommissionStatementAvgAggregateOutputType | null
    _sum: CommissionStatementSumAggregateOutputType | null
    _min: CommissionStatementMinAggregateOutputType | null
    _max: CommissionStatementMaxAggregateOutputType | null
  }

  type GetCommissionStatementGroupByPayload<T extends CommissionStatementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommissionStatementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommissionStatementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommissionStatementGroupByOutputType[P]>
            : GetScalarType<T[P], CommissionStatementGroupByOutputType[P]>
        }
      >
    >


  export type CommissionStatementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    platform?: boolean
    yearMonth?: boolean
    currency?: boolean
    baseNetCents?: boolean
    rateBps?: boolean
    commissionCents?: boolean
    capAppliedCents?: boolean
    finalCents?: boolean
    closedAt?: boolean
    invoicedAt?: boolean
    stripeInvoiceId?: boolean
    paidAt?: boolean
    writeOffAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["commissionStatement"]>

  export type CommissionStatementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    platform?: boolean
    yearMonth?: boolean
    currency?: boolean
    baseNetCents?: boolean
    rateBps?: boolean
    commissionCents?: boolean
    capAppliedCents?: boolean
    finalCents?: boolean
    closedAt?: boolean
    invoicedAt?: boolean
    stripeInvoiceId?: boolean
    paidAt?: boolean
    writeOffAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["commissionStatement"]>

  export type CommissionStatementSelectScalar = {
    id?: boolean
    creatorId?: boolean
    platform?: boolean
    yearMonth?: boolean
    currency?: boolean
    baseNetCents?: boolean
    rateBps?: boolean
    commissionCents?: boolean
    capAppliedCents?: boolean
    finalCents?: boolean
    closedAt?: boolean
    invoicedAt?: boolean
    stripeInvoiceId?: boolean
    paidAt?: boolean
    writeOffAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CommissionStatementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommissionStatement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      platform: $Enums.ExternalPlatform
      yearMonth: string
      currency: string
      baseNetCents: bigint
      rateBps: number
      commissionCents: bigint
      capAppliedCents: bigint
      finalCents: bigint
      closedAt: Date | null
      invoicedAt: Date | null
      stripeInvoiceId: string | null
      paidAt: Date | null
      writeOffAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commissionStatement"]>
    composites: {}
  }

  type CommissionStatementGetPayload<S extends boolean | null | undefined | CommissionStatementDefaultArgs> = $Result.GetResult<Prisma.$CommissionStatementPayload, S>

  type CommissionStatementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommissionStatementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommissionStatementCountAggregateInputType | true
    }

  export interface CommissionStatementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommissionStatement'], meta: { name: 'CommissionStatement' } }
    /**
     * Find zero or one CommissionStatement that matches the filter.
     * @param {CommissionStatementFindUniqueArgs} args - Arguments to find a CommissionStatement
     * @example
     * // Get one CommissionStatement
     * const commissionStatement = await prisma.commissionStatement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommissionStatementFindUniqueArgs>(args: SelectSubset<T, CommissionStatementFindUniqueArgs<ExtArgs>>): Prisma__CommissionStatementClient<$Result.GetResult<Prisma.$CommissionStatementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommissionStatement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommissionStatementFindUniqueOrThrowArgs} args - Arguments to find a CommissionStatement
     * @example
     * // Get one CommissionStatement
     * const commissionStatement = await prisma.commissionStatement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommissionStatementFindUniqueOrThrowArgs>(args: SelectSubset<T, CommissionStatementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommissionStatementClient<$Result.GetResult<Prisma.$CommissionStatementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommissionStatement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionStatementFindFirstArgs} args - Arguments to find a CommissionStatement
     * @example
     * // Get one CommissionStatement
     * const commissionStatement = await prisma.commissionStatement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommissionStatementFindFirstArgs>(args?: SelectSubset<T, CommissionStatementFindFirstArgs<ExtArgs>>): Prisma__CommissionStatementClient<$Result.GetResult<Prisma.$CommissionStatementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommissionStatement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionStatementFindFirstOrThrowArgs} args - Arguments to find a CommissionStatement
     * @example
     * // Get one CommissionStatement
     * const commissionStatement = await prisma.commissionStatement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommissionStatementFindFirstOrThrowArgs>(args?: SelectSubset<T, CommissionStatementFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommissionStatementClient<$Result.GetResult<Prisma.$CommissionStatementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommissionStatements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionStatementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommissionStatements
     * const commissionStatements = await prisma.commissionStatement.findMany()
     * 
     * // Get first 10 CommissionStatements
     * const commissionStatements = await prisma.commissionStatement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commissionStatementWithIdOnly = await prisma.commissionStatement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommissionStatementFindManyArgs>(args?: SelectSubset<T, CommissionStatementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionStatementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommissionStatement.
     * @param {CommissionStatementCreateArgs} args - Arguments to create a CommissionStatement.
     * @example
     * // Create one CommissionStatement
     * const CommissionStatement = await prisma.commissionStatement.create({
     *   data: {
     *     // ... data to create a CommissionStatement
     *   }
     * })
     * 
     */
    create<T extends CommissionStatementCreateArgs>(args: SelectSubset<T, CommissionStatementCreateArgs<ExtArgs>>): Prisma__CommissionStatementClient<$Result.GetResult<Prisma.$CommissionStatementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommissionStatements.
     * @param {CommissionStatementCreateManyArgs} args - Arguments to create many CommissionStatements.
     * @example
     * // Create many CommissionStatements
     * const commissionStatement = await prisma.commissionStatement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommissionStatementCreateManyArgs>(args?: SelectSubset<T, CommissionStatementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommissionStatements and returns the data saved in the database.
     * @param {CommissionStatementCreateManyAndReturnArgs} args - Arguments to create many CommissionStatements.
     * @example
     * // Create many CommissionStatements
     * const commissionStatement = await prisma.commissionStatement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommissionStatements and only return the `id`
     * const commissionStatementWithIdOnly = await prisma.commissionStatement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommissionStatementCreateManyAndReturnArgs>(args?: SelectSubset<T, CommissionStatementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionStatementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommissionStatement.
     * @param {CommissionStatementDeleteArgs} args - Arguments to delete one CommissionStatement.
     * @example
     * // Delete one CommissionStatement
     * const CommissionStatement = await prisma.commissionStatement.delete({
     *   where: {
     *     // ... filter to delete one CommissionStatement
     *   }
     * })
     * 
     */
    delete<T extends CommissionStatementDeleteArgs>(args: SelectSubset<T, CommissionStatementDeleteArgs<ExtArgs>>): Prisma__CommissionStatementClient<$Result.GetResult<Prisma.$CommissionStatementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommissionStatement.
     * @param {CommissionStatementUpdateArgs} args - Arguments to update one CommissionStatement.
     * @example
     * // Update one CommissionStatement
     * const commissionStatement = await prisma.commissionStatement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommissionStatementUpdateArgs>(args: SelectSubset<T, CommissionStatementUpdateArgs<ExtArgs>>): Prisma__CommissionStatementClient<$Result.GetResult<Prisma.$CommissionStatementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommissionStatements.
     * @param {CommissionStatementDeleteManyArgs} args - Arguments to filter CommissionStatements to delete.
     * @example
     * // Delete a few CommissionStatements
     * const { count } = await prisma.commissionStatement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommissionStatementDeleteManyArgs>(args?: SelectSubset<T, CommissionStatementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommissionStatements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionStatementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommissionStatements
     * const commissionStatement = await prisma.commissionStatement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommissionStatementUpdateManyArgs>(args: SelectSubset<T, CommissionStatementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommissionStatement.
     * @param {CommissionStatementUpsertArgs} args - Arguments to update or create a CommissionStatement.
     * @example
     * // Update or create a CommissionStatement
     * const commissionStatement = await prisma.commissionStatement.upsert({
     *   create: {
     *     // ... data to create a CommissionStatement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommissionStatement we want to update
     *   }
     * })
     */
    upsert<T extends CommissionStatementUpsertArgs>(args: SelectSubset<T, CommissionStatementUpsertArgs<ExtArgs>>): Prisma__CommissionStatementClient<$Result.GetResult<Prisma.$CommissionStatementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommissionStatements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionStatementCountArgs} args - Arguments to filter CommissionStatements to count.
     * @example
     * // Count the number of CommissionStatements
     * const count = await prisma.commissionStatement.count({
     *   where: {
     *     // ... the filter for the CommissionStatements we want to count
     *   }
     * })
    **/
    count<T extends CommissionStatementCountArgs>(
      args?: Subset<T, CommissionStatementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommissionStatementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommissionStatement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionStatementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommissionStatementAggregateArgs>(args: Subset<T, CommissionStatementAggregateArgs>): Prisma.PrismaPromise<GetCommissionStatementAggregateType<T>>

    /**
     * Group by CommissionStatement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionStatementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommissionStatementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommissionStatementGroupByArgs['orderBy'] }
        : { orderBy?: CommissionStatementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommissionStatementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommissionStatementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommissionStatement model
   */
  readonly fields: CommissionStatementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommissionStatement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommissionStatementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommissionStatement model
   */ 
  interface CommissionStatementFieldRefs {
    readonly id: FieldRef<"CommissionStatement", 'String'>
    readonly creatorId: FieldRef<"CommissionStatement", 'String'>
    readonly platform: FieldRef<"CommissionStatement", 'ExternalPlatform'>
    readonly yearMonth: FieldRef<"CommissionStatement", 'String'>
    readonly currency: FieldRef<"CommissionStatement", 'String'>
    readonly baseNetCents: FieldRef<"CommissionStatement", 'BigInt'>
    readonly rateBps: FieldRef<"CommissionStatement", 'Int'>
    readonly commissionCents: FieldRef<"CommissionStatement", 'BigInt'>
    readonly capAppliedCents: FieldRef<"CommissionStatement", 'BigInt'>
    readonly finalCents: FieldRef<"CommissionStatement", 'BigInt'>
    readonly closedAt: FieldRef<"CommissionStatement", 'DateTime'>
    readonly invoicedAt: FieldRef<"CommissionStatement", 'DateTime'>
    readonly stripeInvoiceId: FieldRef<"CommissionStatement", 'String'>
    readonly paidAt: FieldRef<"CommissionStatement", 'DateTime'>
    readonly writeOffAt: FieldRef<"CommissionStatement", 'DateTime'>
    readonly createdAt: FieldRef<"CommissionStatement", 'DateTime'>
    readonly updatedAt: FieldRef<"CommissionStatement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommissionStatement findUnique
   */
  export type CommissionStatementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionStatement
     */
    select?: CommissionStatementSelect<ExtArgs> | null
    /**
     * Filter, which CommissionStatement to fetch.
     */
    where: CommissionStatementWhereUniqueInput
  }

  /**
   * CommissionStatement findUniqueOrThrow
   */
  export type CommissionStatementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionStatement
     */
    select?: CommissionStatementSelect<ExtArgs> | null
    /**
     * Filter, which CommissionStatement to fetch.
     */
    where: CommissionStatementWhereUniqueInput
  }

  /**
   * CommissionStatement findFirst
   */
  export type CommissionStatementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionStatement
     */
    select?: CommissionStatementSelect<ExtArgs> | null
    /**
     * Filter, which CommissionStatement to fetch.
     */
    where?: CommissionStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionStatements to fetch.
     */
    orderBy?: CommissionStatementOrderByWithRelationInput | CommissionStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionStatements.
     */
    cursor?: CommissionStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionStatements.
     */
    distinct?: CommissionStatementScalarFieldEnum | CommissionStatementScalarFieldEnum[]
  }

  /**
   * CommissionStatement findFirstOrThrow
   */
  export type CommissionStatementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionStatement
     */
    select?: CommissionStatementSelect<ExtArgs> | null
    /**
     * Filter, which CommissionStatement to fetch.
     */
    where?: CommissionStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionStatements to fetch.
     */
    orderBy?: CommissionStatementOrderByWithRelationInput | CommissionStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionStatements.
     */
    cursor?: CommissionStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionStatements.
     */
    distinct?: CommissionStatementScalarFieldEnum | CommissionStatementScalarFieldEnum[]
  }

  /**
   * CommissionStatement findMany
   */
  export type CommissionStatementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionStatement
     */
    select?: CommissionStatementSelect<ExtArgs> | null
    /**
     * Filter, which CommissionStatements to fetch.
     */
    where?: CommissionStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionStatements to fetch.
     */
    orderBy?: CommissionStatementOrderByWithRelationInput | CommissionStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommissionStatements.
     */
    cursor?: CommissionStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionStatements.
     */
    skip?: number
    distinct?: CommissionStatementScalarFieldEnum | CommissionStatementScalarFieldEnum[]
  }

  /**
   * CommissionStatement create
   */
  export type CommissionStatementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionStatement
     */
    select?: CommissionStatementSelect<ExtArgs> | null
    /**
     * The data needed to create a CommissionStatement.
     */
    data: XOR<CommissionStatementCreateInput, CommissionStatementUncheckedCreateInput>
  }

  /**
   * CommissionStatement createMany
   */
  export type CommissionStatementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommissionStatements.
     */
    data: CommissionStatementCreateManyInput | CommissionStatementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommissionStatement createManyAndReturn
   */
  export type CommissionStatementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionStatement
     */
    select?: CommissionStatementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommissionStatements.
     */
    data: CommissionStatementCreateManyInput | CommissionStatementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommissionStatement update
   */
  export type CommissionStatementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionStatement
     */
    select?: CommissionStatementSelect<ExtArgs> | null
    /**
     * The data needed to update a CommissionStatement.
     */
    data: XOR<CommissionStatementUpdateInput, CommissionStatementUncheckedUpdateInput>
    /**
     * Choose, which CommissionStatement to update.
     */
    where: CommissionStatementWhereUniqueInput
  }

  /**
   * CommissionStatement updateMany
   */
  export type CommissionStatementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommissionStatements.
     */
    data: XOR<CommissionStatementUpdateManyMutationInput, CommissionStatementUncheckedUpdateManyInput>
    /**
     * Filter which CommissionStatements to update
     */
    where?: CommissionStatementWhereInput
  }

  /**
   * CommissionStatement upsert
   */
  export type CommissionStatementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionStatement
     */
    select?: CommissionStatementSelect<ExtArgs> | null
    /**
     * The filter to search for the CommissionStatement to update in case it exists.
     */
    where: CommissionStatementWhereUniqueInput
    /**
     * In case the CommissionStatement found by the `where` argument doesn't exist, create a new CommissionStatement with this data.
     */
    create: XOR<CommissionStatementCreateInput, CommissionStatementUncheckedCreateInput>
    /**
     * In case the CommissionStatement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommissionStatementUpdateInput, CommissionStatementUncheckedUpdateInput>
  }

  /**
   * CommissionStatement delete
   */
  export type CommissionStatementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionStatement
     */
    select?: CommissionStatementSelect<ExtArgs> | null
    /**
     * Filter which CommissionStatement to delete.
     */
    where: CommissionStatementWhereUniqueInput
  }

  /**
   * CommissionStatement deleteMany
   */
  export type CommissionStatementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionStatements to delete
     */
    where?: CommissionStatementWhereInput
  }

  /**
   * CommissionStatement without action
   */
  export type CommissionStatementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionStatement
     */
    select?: CommissionStatementSelect<ExtArgs> | null
  }


  /**
   * Model DunningState
   */

  export type AggregateDunningState = {
    _count: DunningStateCountAggregateOutputType | null
    _avg: DunningStateAvgAggregateOutputType | null
    _sum: DunningStateSumAggregateOutputType | null
    _min: DunningStateMinAggregateOutputType | null
    _max: DunningStateMaxAggregateOutputType | null
  }

  export type DunningStateAvgAggregateOutputType = {
    attemptCount: number | null
  }

  export type DunningStateSumAggregateOutputType = {
    attemptCount: number | null
  }

  export type DunningStateMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    creatorId: string | null
    attemptCount: number | null
    status: $Enums.DunningStatus | null
    lastAttempt: Date | null
    nextAttempt: Date | null
    recoveredAt: Date | null
    writeOffAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DunningStateMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    creatorId: string | null
    attemptCount: number | null
    status: $Enums.DunningStatus | null
    lastAttempt: Date | null
    nextAttempt: Date | null
    recoveredAt: Date | null
    writeOffAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DunningStateCountAggregateOutputType = {
    id: number
    invoiceId: number
    creatorId: number
    attemptCount: number
    status: number
    lastAttempt: number
    nextAttempt: number
    recoveredAt: number
    writeOffAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DunningStateAvgAggregateInputType = {
    attemptCount?: true
  }

  export type DunningStateSumAggregateInputType = {
    attemptCount?: true
  }

  export type DunningStateMinAggregateInputType = {
    id?: true
    invoiceId?: true
    creatorId?: true
    attemptCount?: true
    status?: true
    lastAttempt?: true
    nextAttempt?: true
    recoveredAt?: true
    writeOffAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DunningStateMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    creatorId?: true
    attemptCount?: true
    status?: true
    lastAttempt?: true
    nextAttempt?: true
    recoveredAt?: true
    writeOffAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DunningStateCountAggregateInputType = {
    id?: true
    invoiceId?: true
    creatorId?: true
    attemptCount?: true
    status?: true
    lastAttempt?: true
    nextAttempt?: true
    recoveredAt?: true
    writeOffAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DunningStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DunningState to aggregate.
     */
    where?: DunningStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DunningStates to fetch.
     */
    orderBy?: DunningStateOrderByWithRelationInput | DunningStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DunningStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DunningStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DunningStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DunningStates
    **/
    _count?: true | DunningStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DunningStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DunningStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DunningStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DunningStateMaxAggregateInputType
  }

  export type GetDunningStateAggregateType<T extends DunningStateAggregateArgs> = {
        [P in keyof T & keyof AggregateDunningState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDunningState[P]>
      : GetScalarType<T[P], AggregateDunningState[P]>
  }




  export type DunningStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DunningStateWhereInput
    orderBy?: DunningStateOrderByWithAggregationInput | DunningStateOrderByWithAggregationInput[]
    by: DunningStateScalarFieldEnum[] | DunningStateScalarFieldEnum
    having?: DunningStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DunningStateCountAggregateInputType | true
    _avg?: DunningStateAvgAggregateInputType
    _sum?: DunningStateSumAggregateInputType
    _min?: DunningStateMinAggregateInputType
    _max?: DunningStateMaxAggregateInputType
  }

  export type DunningStateGroupByOutputType = {
    id: string
    invoiceId: string
    creatorId: string
    attemptCount: number
    status: $Enums.DunningStatus
    lastAttempt: Date | null
    nextAttempt: Date | null
    recoveredAt: Date | null
    writeOffAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DunningStateCountAggregateOutputType | null
    _avg: DunningStateAvgAggregateOutputType | null
    _sum: DunningStateSumAggregateOutputType | null
    _min: DunningStateMinAggregateOutputType | null
    _max: DunningStateMaxAggregateOutputType | null
  }

  type GetDunningStateGroupByPayload<T extends DunningStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DunningStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DunningStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DunningStateGroupByOutputType[P]>
            : GetScalarType<T[P], DunningStateGroupByOutputType[P]>
        }
      >
    >


  export type DunningStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    creatorId?: boolean
    attemptCount?: boolean
    status?: boolean
    lastAttempt?: boolean
    nextAttempt?: boolean
    recoveredAt?: boolean
    writeOffAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dunningState"]>

  export type DunningStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    creatorId?: boolean
    attemptCount?: boolean
    status?: boolean
    lastAttempt?: boolean
    nextAttempt?: boolean
    recoveredAt?: boolean
    writeOffAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dunningState"]>

  export type DunningStateSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    creatorId?: boolean
    attemptCount?: boolean
    status?: boolean
    lastAttempt?: boolean
    nextAttempt?: boolean
    recoveredAt?: boolean
    writeOffAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $DunningStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DunningState"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      creatorId: string
      attemptCount: number
      status: $Enums.DunningStatus
      lastAttempt: Date | null
      nextAttempt: Date | null
      recoveredAt: Date | null
      writeOffAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dunningState"]>
    composites: {}
  }

  type DunningStateGetPayload<S extends boolean | null | undefined | DunningStateDefaultArgs> = $Result.GetResult<Prisma.$DunningStatePayload, S>

  type DunningStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DunningStateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DunningStateCountAggregateInputType | true
    }

  export interface DunningStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DunningState'], meta: { name: 'DunningState' } }
    /**
     * Find zero or one DunningState that matches the filter.
     * @param {DunningStateFindUniqueArgs} args - Arguments to find a DunningState
     * @example
     * // Get one DunningState
     * const dunningState = await prisma.dunningState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DunningStateFindUniqueArgs>(args: SelectSubset<T, DunningStateFindUniqueArgs<ExtArgs>>): Prisma__DunningStateClient<$Result.GetResult<Prisma.$DunningStatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DunningState that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DunningStateFindUniqueOrThrowArgs} args - Arguments to find a DunningState
     * @example
     * // Get one DunningState
     * const dunningState = await prisma.dunningState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DunningStateFindUniqueOrThrowArgs>(args: SelectSubset<T, DunningStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DunningStateClient<$Result.GetResult<Prisma.$DunningStatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DunningState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DunningStateFindFirstArgs} args - Arguments to find a DunningState
     * @example
     * // Get one DunningState
     * const dunningState = await prisma.dunningState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DunningStateFindFirstArgs>(args?: SelectSubset<T, DunningStateFindFirstArgs<ExtArgs>>): Prisma__DunningStateClient<$Result.GetResult<Prisma.$DunningStatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DunningState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DunningStateFindFirstOrThrowArgs} args - Arguments to find a DunningState
     * @example
     * // Get one DunningState
     * const dunningState = await prisma.dunningState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DunningStateFindFirstOrThrowArgs>(args?: SelectSubset<T, DunningStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__DunningStateClient<$Result.GetResult<Prisma.$DunningStatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DunningStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DunningStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DunningStates
     * const dunningStates = await prisma.dunningState.findMany()
     * 
     * // Get first 10 DunningStates
     * const dunningStates = await prisma.dunningState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dunningStateWithIdOnly = await prisma.dunningState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DunningStateFindManyArgs>(args?: SelectSubset<T, DunningStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DunningStatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DunningState.
     * @param {DunningStateCreateArgs} args - Arguments to create a DunningState.
     * @example
     * // Create one DunningState
     * const DunningState = await prisma.dunningState.create({
     *   data: {
     *     // ... data to create a DunningState
     *   }
     * })
     * 
     */
    create<T extends DunningStateCreateArgs>(args: SelectSubset<T, DunningStateCreateArgs<ExtArgs>>): Prisma__DunningStateClient<$Result.GetResult<Prisma.$DunningStatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DunningStates.
     * @param {DunningStateCreateManyArgs} args - Arguments to create many DunningStates.
     * @example
     * // Create many DunningStates
     * const dunningState = await prisma.dunningState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DunningStateCreateManyArgs>(args?: SelectSubset<T, DunningStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DunningStates and returns the data saved in the database.
     * @param {DunningStateCreateManyAndReturnArgs} args - Arguments to create many DunningStates.
     * @example
     * // Create many DunningStates
     * const dunningState = await prisma.dunningState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DunningStates and only return the `id`
     * const dunningStateWithIdOnly = await prisma.dunningState.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DunningStateCreateManyAndReturnArgs>(args?: SelectSubset<T, DunningStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DunningStatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DunningState.
     * @param {DunningStateDeleteArgs} args - Arguments to delete one DunningState.
     * @example
     * // Delete one DunningState
     * const DunningState = await prisma.dunningState.delete({
     *   where: {
     *     // ... filter to delete one DunningState
     *   }
     * })
     * 
     */
    delete<T extends DunningStateDeleteArgs>(args: SelectSubset<T, DunningStateDeleteArgs<ExtArgs>>): Prisma__DunningStateClient<$Result.GetResult<Prisma.$DunningStatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DunningState.
     * @param {DunningStateUpdateArgs} args - Arguments to update one DunningState.
     * @example
     * // Update one DunningState
     * const dunningState = await prisma.dunningState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DunningStateUpdateArgs>(args: SelectSubset<T, DunningStateUpdateArgs<ExtArgs>>): Prisma__DunningStateClient<$Result.GetResult<Prisma.$DunningStatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DunningStates.
     * @param {DunningStateDeleteManyArgs} args - Arguments to filter DunningStates to delete.
     * @example
     * // Delete a few DunningStates
     * const { count } = await prisma.dunningState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DunningStateDeleteManyArgs>(args?: SelectSubset<T, DunningStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DunningStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DunningStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DunningStates
     * const dunningState = await prisma.dunningState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DunningStateUpdateManyArgs>(args: SelectSubset<T, DunningStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DunningState.
     * @param {DunningStateUpsertArgs} args - Arguments to update or create a DunningState.
     * @example
     * // Update or create a DunningState
     * const dunningState = await prisma.dunningState.upsert({
     *   create: {
     *     // ... data to create a DunningState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DunningState we want to update
     *   }
     * })
     */
    upsert<T extends DunningStateUpsertArgs>(args: SelectSubset<T, DunningStateUpsertArgs<ExtArgs>>): Prisma__DunningStateClient<$Result.GetResult<Prisma.$DunningStatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DunningStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DunningStateCountArgs} args - Arguments to filter DunningStates to count.
     * @example
     * // Count the number of DunningStates
     * const count = await prisma.dunningState.count({
     *   where: {
     *     // ... the filter for the DunningStates we want to count
     *   }
     * })
    **/
    count<T extends DunningStateCountArgs>(
      args?: Subset<T, DunningStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DunningStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DunningState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DunningStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DunningStateAggregateArgs>(args: Subset<T, DunningStateAggregateArgs>): Prisma.PrismaPromise<GetDunningStateAggregateType<T>>

    /**
     * Group by DunningState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DunningStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DunningStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DunningStateGroupByArgs['orderBy'] }
        : { orderBy?: DunningStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DunningStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDunningStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DunningState model
   */
  readonly fields: DunningStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DunningState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DunningStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DunningState model
   */ 
  interface DunningStateFieldRefs {
    readonly id: FieldRef<"DunningState", 'String'>
    readonly invoiceId: FieldRef<"DunningState", 'String'>
    readonly creatorId: FieldRef<"DunningState", 'String'>
    readonly attemptCount: FieldRef<"DunningState", 'Int'>
    readonly status: FieldRef<"DunningState", 'DunningStatus'>
    readonly lastAttempt: FieldRef<"DunningState", 'DateTime'>
    readonly nextAttempt: FieldRef<"DunningState", 'DateTime'>
    readonly recoveredAt: FieldRef<"DunningState", 'DateTime'>
    readonly writeOffAt: FieldRef<"DunningState", 'DateTime'>
    readonly metadata: FieldRef<"DunningState", 'Json'>
    readonly createdAt: FieldRef<"DunningState", 'DateTime'>
    readonly updatedAt: FieldRef<"DunningState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DunningState findUnique
   */
  export type DunningStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DunningState
     */
    select?: DunningStateSelect<ExtArgs> | null
    /**
     * Filter, which DunningState to fetch.
     */
    where: DunningStateWhereUniqueInput
  }

  /**
   * DunningState findUniqueOrThrow
   */
  export type DunningStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DunningState
     */
    select?: DunningStateSelect<ExtArgs> | null
    /**
     * Filter, which DunningState to fetch.
     */
    where: DunningStateWhereUniqueInput
  }

  /**
   * DunningState findFirst
   */
  export type DunningStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DunningState
     */
    select?: DunningStateSelect<ExtArgs> | null
    /**
     * Filter, which DunningState to fetch.
     */
    where?: DunningStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DunningStates to fetch.
     */
    orderBy?: DunningStateOrderByWithRelationInput | DunningStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DunningStates.
     */
    cursor?: DunningStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DunningStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DunningStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DunningStates.
     */
    distinct?: DunningStateScalarFieldEnum | DunningStateScalarFieldEnum[]
  }

  /**
   * DunningState findFirstOrThrow
   */
  export type DunningStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DunningState
     */
    select?: DunningStateSelect<ExtArgs> | null
    /**
     * Filter, which DunningState to fetch.
     */
    where?: DunningStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DunningStates to fetch.
     */
    orderBy?: DunningStateOrderByWithRelationInput | DunningStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DunningStates.
     */
    cursor?: DunningStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DunningStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DunningStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DunningStates.
     */
    distinct?: DunningStateScalarFieldEnum | DunningStateScalarFieldEnum[]
  }

  /**
   * DunningState findMany
   */
  export type DunningStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DunningState
     */
    select?: DunningStateSelect<ExtArgs> | null
    /**
     * Filter, which DunningStates to fetch.
     */
    where?: DunningStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DunningStates to fetch.
     */
    orderBy?: DunningStateOrderByWithRelationInput | DunningStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DunningStates.
     */
    cursor?: DunningStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DunningStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DunningStates.
     */
    skip?: number
    distinct?: DunningStateScalarFieldEnum | DunningStateScalarFieldEnum[]
  }

  /**
   * DunningState create
   */
  export type DunningStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DunningState
     */
    select?: DunningStateSelect<ExtArgs> | null
    /**
     * The data needed to create a DunningState.
     */
    data: XOR<DunningStateCreateInput, DunningStateUncheckedCreateInput>
  }

  /**
   * DunningState createMany
   */
  export type DunningStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DunningStates.
     */
    data: DunningStateCreateManyInput | DunningStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DunningState createManyAndReturn
   */
  export type DunningStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DunningState
     */
    select?: DunningStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DunningStates.
     */
    data: DunningStateCreateManyInput | DunningStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DunningState update
   */
  export type DunningStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DunningState
     */
    select?: DunningStateSelect<ExtArgs> | null
    /**
     * The data needed to update a DunningState.
     */
    data: XOR<DunningStateUpdateInput, DunningStateUncheckedUpdateInput>
    /**
     * Choose, which DunningState to update.
     */
    where: DunningStateWhereUniqueInput
  }

  /**
   * DunningState updateMany
   */
  export type DunningStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DunningStates.
     */
    data: XOR<DunningStateUpdateManyMutationInput, DunningStateUncheckedUpdateManyInput>
    /**
     * Filter which DunningStates to update
     */
    where?: DunningStateWhereInput
  }

  /**
   * DunningState upsert
   */
  export type DunningStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DunningState
     */
    select?: DunningStateSelect<ExtArgs> | null
    /**
     * The filter to search for the DunningState to update in case it exists.
     */
    where: DunningStateWhereUniqueInput
    /**
     * In case the DunningState found by the `where` argument doesn't exist, create a new DunningState with this data.
     */
    create: XOR<DunningStateCreateInput, DunningStateUncheckedCreateInput>
    /**
     * In case the DunningState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DunningStateUpdateInput, DunningStateUncheckedUpdateInput>
  }

  /**
   * DunningState delete
   */
  export type DunningStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DunningState
     */
    select?: DunningStateSelect<ExtArgs> | null
    /**
     * Filter which DunningState to delete.
     */
    where: DunningStateWhereUniqueInput
  }

  /**
   * DunningState deleteMany
   */
  export type DunningStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DunningStates to delete
     */
    where?: DunningStateWhereInput
  }

  /**
   * DunningState without action
   */
  export type DunningStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DunningState
     */
    select?: DunningStateSelect<ExtArgs> | null
  }


  /**
   * Model PaymentAttempt
   */

  export type AggregatePaymentAttempt = {
    _count: PaymentAttemptCountAggregateOutputType | null
    _avg: PaymentAttemptAvgAggregateOutputType | null
    _sum: PaymentAttemptSumAggregateOutputType | null
    _min: PaymentAttemptMinAggregateOutputType | null
    _max: PaymentAttemptMaxAggregateOutputType | null
  }

  export type PaymentAttemptAvgAggregateOutputType = {
    attemptNumber: number | null
    amount: number | null
  }

  export type PaymentAttemptSumAggregateOutputType = {
    attemptNumber: number | null
    amount: bigint | null
  }

  export type PaymentAttemptMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    attemptNumber: number | null
    status: string | null
    errorCode: string | null
    errorMessage: string | null
    paymentMethodId: string | null
    amount: bigint | null
    currency: string | null
    createdAt: Date | null
  }

  export type PaymentAttemptMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    attemptNumber: number | null
    status: string | null
    errorCode: string | null
    errorMessage: string | null
    paymentMethodId: string | null
    amount: bigint | null
    currency: string | null
    createdAt: Date | null
  }

  export type PaymentAttemptCountAggregateOutputType = {
    id: number
    invoiceId: number
    attemptNumber: number
    status: number
    errorCode: number
    errorMessage: number
    paymentMethodId: number
    amount: number
    currency: number
    createdAt: number
    _all: number
  }


  export type PaymentAttemptAvgAggregateInputType = {
    attemptNumber?: true
    amount?: true
  }

  export type PaymentAttemptSumAggregateInputType = {
    attemptNumber?: true
    amount?: true
  }

  export type PaymentAttemptMinAggregateInputType = {
    id?: true
    invoiceId?: true
    attemptNumber?: true
    status?: true
    errorCode?: true
    errorMessage?: true
    paymentMethodId?: true
    amount?: true
    currency?: true
    createdAt?: true
  }

  export type PaymentAttemptMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    attemptNumber?: true
    status?: true
    errorCode?: true
    errorMessage?: true
    paymentMethodId?: true
    amount?: true
    currency?: true
    createdAt?: true
  }

  export type PaymentAttemptCountAggregateInputType = {
    id?: true
    invoiceId?: true
    attemptNumber?: true
    status?: true
    errorCode?: true
    errorMessage?: true
    paymentMethodId?: true
    amount?: true
    currency?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAttempt to aggregate.
     */
    where?: PaymentAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAttempts to fetch.
     */
    orderBy?: PaymentAttemptOrderByWithRelationInput | PaymentAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentAttempts
    **/
    _count?: true | PaymentAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentAttemptMaxAggregateInputType
  }

  export type GetPaymentAttemptAggregateType<T extends PaymentAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentAttempt[P]>
      : GetScalarType<T[P], AggregatePaymentAttempt[P]>
  }




  export type PaymentAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAttemptWhereInput
    orderBy?: PaymentAttemptOrderByWithAggregationInput | PaymentAttemptOrderByWithAggregationInput[]
    by: PaymentAttemptScalarFieldEnum[] | PaymentAttemptScalarFieldEnum
    having?: PaymentAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentAttemptCountAggregateInputType | true
    _avg?: PaymentAttemptAvgAggregateInputType
    _sum?: PaymentAttemptSumAggregateInputType
    _min?: PaymentAttemptMinAggregateInputType
    _max?: PaymentAttemptMaxAggregateInputType
  }

  export type PaymentAttemptGroupByOutputType = {
    id: string
    invoiceId: string
    attemptNumber: number
    status: string
    errorCode: string | null
    errorMessage: string | null
    paymentMethodId: string | null
    amount: bigint
    currency: string
    createdAt: Date
    _count: PaymentAttemptCountAggregateOutputType | null
    _avg: PaymentAttemptAvgAggregateOutputType | null
    _sum: PaymentAttemptSumAggregateOutputType | null
    _min: PaymentAttemptMinAggregateOutputType | null
    _max: PaymentAttemptMaxAggregateOutputType | null
  }

  type GetPaymentAttemptGroupByPayload<T extends PaymentAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentAttemptGroupByOutputType[P]>
        }
      >
    >


  export type PaymentAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    attemptNumber?: boolean
    status?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    currency?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paymentAttempt"]>

  export type PaymentAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    attemptNumber?: boolean
    status?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    currency?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paymentAttempt"]>

  export type PaymentAttemptSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    attemptNumber?: boolean
    status?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    currency?: boolean
    createdAt?: boolean
  }


  export type $PaymentAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentAttempt"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      attemptNumber: number
      status: string
      errorCode: string | null
      errorMessage: string | null
      paymentMethodId: string | null
      amount: bigint
      currency: string
      createdAt: Date
    }, ExtArgs["result"]["paymentAttempt"]>
    composites: {}
  }

  type PaymentAttemptGetPayload<S extends boolean | null | undefined | PaymentAttemptDefaultArgs> = $Result.GetResult<Prisma.$PaymentAttemptPayload, S>

  type PaymentAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentAttemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentAttemptCountAggregateInputType | true
    }

  export interface PaymentAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentAttempt'], meta: { name: 'PaymentAttempt' } }
    /**
     * Find zero or one PaymentAttempt that matches the filter.
     * @param {PaymentAttemptFindUniqueArgs} args - Arguments to find a PaymentAttempt
     * @example
     * // Get one PaymentAttempt
     * const paymentAttempt = await prisma.paymentAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentAttemptFindUniqueArgs>(args: SelectSubset<T, PaymentAttemptFindUniqueArgs<ExtArgs>>): Prisma__PaymentAttemptClient<$Result.GetResult<Prisma.$PaymentAttemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentAttempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentAttemptFindUniqueOrThrowArgs} args - Arguments to find a PaymentAttempt
     * @example
     * // Get one PaymentAttempt
     * const paymentAttempt = await prisma.paymentAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentAttemptClient<$Result.GetResult<Prisma.$PaymentAttemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAttemptFindFirstArgs} args - Arguments to find a PaymentAttempt
     * @example
     * // Get one PaymentAttempt
     * const paymentAttempt = await prisma.paymentAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentAttemptFindFirstArgs>(args?: SelectSubset<T, PaymentAttemptFindFirstArgs<ExtArgs>>): Prisma__PaymentAttemptClient<$Result.GetResult<Prisma.$PaymentAttemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAttemptFindFirstOrThrowArgs} args - Arguments to find a PaymentAttempt
     * @example
     * // Get one PaymentAttempt
     * const paymentAttempt = await prisma.paymentAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentAttemptClient<$Result.GetResult<Prisma.$PaymentAttemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentAttempts
     * const paymentAttempts = await prisma.paymentAttempt.findMany()
     * 
     * // Get first 10 PaymentAttempts
     * const paymentAttempts = await prisma.paymentAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentAttemptWithIdOnly = await prisma.paymentAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentAttemptFindManyArgs>(args?: SelectSubset<T, PaymentAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAttemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentAttempt.
     * @param {PaymentAttemptCreateArgs} args - Arguments to create a PaymentAttempt.
     * @example
     * // Create one PaymentAttempt
     * const PaymentAttempt = await prisma.paymentAttempt.create({
     *   data: {
     *     // ... data to create a PaymentAttempt
     *   }
     * })
     * 
     */
    create<T extends PaymentAttemptCreateArgs>(args: SelectSubset<T, PaymentAttemptCreateArgs<ExtArgs>>): Prisma__PaymentAttemptClient<$Result.GetResult<Prisma.$PaymentAttemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentAttempts.
     * @param {PaymentAttemptCreateManyArgs} args - Arguments to create many PaymentAttempts.
     * @example
     * // Create many PaymentAttempts
     * const paymentAttempt = await prisma.paymentAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentAttemptCreateManyArgs>(args?: SelectSubset<T, PaymentAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentAttempts and returns the data saved in the database.
     * @param {PaymentAttemptCreateManyAndReturnArgs} args - Arguments to create many PaymentAttempts.
     * @example
     * // Create many PaymentAttempts
     * const paymentAttempt = await prisma.paymentAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentAttempts and only return the `id`
     * const paymentAttemptWithIdOnly = await prisma.paymentAttempt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAttemptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentAttempt.
     * @param {PaymentAttemptDeleteArgs} args - Arguments to delete one PaymentAttempt.
     * @example
     * // Delete one PaymentAttempt
     * const PaymentAttempt = await prisma.paymentAttempt.delete({
     *   where: {
     *     // ... filter to delete one PaymentAttempt
     *   }
     * })
     * 
     */
    delete<T extends PaymentAttemptDeleteArgs>(args: SelectSubset<T, PaymentAttemptDeleteArgs<ExtArgs>>): Prisma__PaymentAttemptClient<$Result.GetResult<Prisma.$PaymentAttemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentAttempt.
     * @param {PaymentAttemptUpdateArgs} args - Arguments to update one PaymentAttempt.
     * @example
     * // Update one PaymentAttempt
     * const paymentAttempt = await prisma.paymentAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentAttemptUpdateArgs>(args: SelectSubset<T, PaymentAttemptUpdateArgs<ExtArgs>>): Prisma__PaymentAttemptClient<$Result.GetResult<Prisma.$PaymentAttemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentAttempts.
     * @param {PaymentAttemptDeleteManyArgs} args - Arguments to filter PaymentAttempts to delete.
     * @example
     * // Delete a few PaymentAttempts
     * const { count } = await prisma.paymentAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentAttemptDeleteManyArgs>(args?: SelectSubset<T, PaymentAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentAttempts
     * const paymentAttempt = await prisma.paymentAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentAttemptUpdateManyArgs>(args: SelectSubset<T, PaymentAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentAttempt.
     * @param {PaymentAttemptUpsertArgs} args - Arguments to update or create a PaymentAttempt.
     * @example
     * // Update or create a PaymentAttempt
     * const paymentAttempt = await prisma.paymentAttempt.upsert({
     *   create: {
     *     // ... data to create a PaymentAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentAttempt we want to update
     *   }
     * })
     */
    upsert<T extends PaymentAttemptUpsertArgs>(args: SelectSubset<T, PaymentAttemptUpsertArgs<ExtArgs>>): Prisma__PaymentAttemptClient<$Result.GetResult<Prisma.$PaymentAttemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAttemptCountArgs} args - Arguments to filter PaymentAttempts to count.
     * @example
     * // Count the number of PaymentAttempts
     * const count = await prisma.paymentAttempt.count({
     *   where: {
     *     // ... the filter for the PaymentAttempts we want to count
     *   }
     * })
    **/
    count<T extends PaymentAttemptCountArgs>(
      args?: Subset<T, PaymentAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAttemptAggregateArgs>(args: Subset<T, PaymentAttemptAggregateArgs>): Prisma.PrismaPromise<GetPaymentAttemptAggregateType<T>>

    /**
     * Group by PaymentAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentAttemptGroupByArgs['orderBy'] }
        : { orderBy?: PaymentAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentAttempt model
   */
  readonly fields: PaymentAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentAttempt model
   */ 
  interface PaymentAttemptFieldRefs {
    readonly id: FieldRef<"PaymentAttempt", 'String'>
    readonly invoiceId: FieldRef<"PaymentAttempt", 'String'>
    readonly attemptNumber: FieldRef<"PaymentAttempt", 'Int'>
    readonly status: FieldRef<"PaymentAttempt", 'String'>
    readonly errorCode: FieldRef<"PaymentAttempt", 'String'>
    readonly errorMessage: FieldRef<"PaymentAttempt", 'String'>
    readonly paymentMethodId: FieldRef<"PaymentAttempt", 'String'>
    readonly amount: FieldRef<"PaymentAttempt", 'BigInt'>
    readonly currency: FieldRef<"PaymentAttempt", 'String'>
    readonly createdAt: FieldRef<"PaymentAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentAttempt findUnique
   */
  export type PaymentAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAttempt
     */
    select?: PaymentAttemptSelect<ExtArgs> | null
    /**
     * Filter, which PaymentAttempt to fetch.
     */
    where: PaymentAttemptWhereUniqueInput
  }

  /**
   * PaymentAttempt findUniqueOrThrow
   */
  export type PaymentAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAttempt
     */
    select?: PaymentAttemptSelect<ExtArgs> | null
    /**
     * Filter, which PaymentAttempt to fetch.
     */
    where: PaymentAttemptWhereUniqueInput
  }

  /**
   * PaymentAttempt findFirst
   */
  export type PaymentAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAttempt
     */
    select?: PaymentAttemptSelect<ExtArgs> | null
    /**
     * Filter, which PaymentAttempt to fetch.
     */
    where?: PaymentAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAttempts to fetch.
     */
    orderBy?: PaymentAttemptOrderByWithRelationInput | PaymentAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAttempts.
     */
    cursor?: PaymentAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAttempts.
     */
    distinct?: PaymentAttemptScalarFieldEnum | PaymentAttemptScalarFieldEnum[]
  }

  /**
   * PaymentAttempt findFirstOrThrow
   */
  export type PaymentAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAttempt
     */
    select?: PaymentAttemptSelect<ExtArgs> | null
    /**
     * Filter, which PaymentAttempt to fetch.
     */
    where?: PaymentAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAttempts to fetch.
     */
    orderBy?: PaymentAttemptOrderByWithRelationInput | PaymentAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAttempts.
     */
    cursor?: PaymentAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAttempts.
     */
    distinct?: PaymentAttemptScalarFieldEnum | PaymentAttemptScalarFieldEnum[]
  }

  /**
   * PaymentAttempt findMany
   */
  export type PaymentAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAttempt
     */
    select?: PaymentAttemptSelect<ExtArgs> | null
    /**
     * Filter, which PaymentAttempts to fetch.
     */
    where?: PaymentAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAttempts to fetch.
     */
    orderBy?: PaymentAttemptOrderByWithRelationInput | PaymentAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentAttempts.
     */
    cursor?: PaymentAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAttempts.
     */
    skip?: number
    distinct?: PaymentAttemptScalarFieldEnum | PaymentAttemptScalarFieldEnum[]
  }

  /**
   * PaymentAttempt create
   */
  export type PaymentAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAttempt
     */
    select?: PaymentAttemptSelect<ExtArgs> | null
    /**
     * The data needed to create a PaymentAttempt.
     */
    data: XOR<PaymentAttemptCreateInput, PaymentAttemptUncheckedCreateInput>
  }

  /**
   * PaymentAttempt createMany
   */
  export type PaymentAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentAttempts.
     */
    data: PaymentAttemptCreateManyInput | PaymentAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentAttempt createManyAndReturn
   */
  export type PaymentAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAttempt
     */
    select?: PaymentAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentAttempts.
     */
    data: PaymentAttemptCreateManyInput | PaymentAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentAttempt update
   */
  export type PaymentAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAttempt
     */
    select?: PaymentAttemptSelect<ExtArgs> | null
    /**
     * The data needed to update a PaymentAttempt.
     */
    data: XOR<PaymentAttemptUpdateInput, PaymentAttemptUncheckedUpdateInput>
    /**
     * Choose, which PaymentAttempt to update.
     */
    where: PaymentAttemptWhereUniqueInput
  }

  /**
   * PaymentAttempt updateMany
   */
  export type PaymentAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentAttempts.
     */
    data: XOR<PaymentAttemptUpdateManyMutationInput, PaymentAttemptUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAttempts to update
     */
    where?: PaymentAttemptWhereInput
  }

  /**
   * PaymentAttempt upsert
   */
  export type PaymentAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAttempt
     */
    select?: PaymentAttemptSelect<ExtArgs> | null
    /**
     * The filter to search for the PaymentAttempt to update in case it exists.
     */
    where: PaymentAttemptWhereUniqueInput
    /**
     * In case the PaymentAttempt found by the `where` argument doesn't exist, create a new PaymentAttempt with this data.
     */
    create: XOR<PaymentAttemptCreateInput, PaymentAttemptUncheckedCreateInput>
    /**
     * In case the PaymentAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentAttemptUpdateInput, PaymentAttemptUncheckedUpdateInput>
  }

  /**
   * PaymentAttempt delete
   */
  export type PaymentAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAttempt
     */
    select?: PaymentAttemptSelect<ExtArgs> | null
    /**
     * Filter which PaymentAttempt to delete.
     */
    where: PaymentAttemptWhereUniqueInput
  }

  /**
   * PaymentAttempt deleteMany
   */
  export type PaymentAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAttempts to delete
     */
    where?: PaymentAttemptWhereInput
  }

  /**
   * PaymentAttempt without action
   */
  export type PaymentAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAttempt
     */
    select?: PaymentAttemptSelect<ExtArgs> | null
  }


  /**
   * Model Automation
   */

  export type AggregateAutomation = {
    _count: AutomationCountAggregateOutputType | null
    _avg: AutomationAvgAggregateOutputType | null
    _sum: AutomationSumAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  export type AutomationAvgAggregateOutputType = {
    runCount: number | null
  }

  export type AutomationSumAggregateOutputType = {
    runCount: number | null
  }

  export type AutomationMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    name: string | null
    triggerType: $Enums.AutomationTrigger | null
    status: $Enums.AutomationStatus | null
    lastRun: Date | null
    runCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    name: string | null
    triggerType: $Enums.AutomationTrigger | null
    status: $Enums.AutomationStatus | null
    lastRun: Date | null
    runCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationCountAggregateOutputType = {
    id: number
    creatorId: number
    name: number
    triggerType: number
    conditions: number
    actions: number
    status: number
    lastRun: number
    runCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutomationAvgAggregateInputType = {
    runCount?: true
  }

  export type AutomationSumAggregateInputType = {
    runCount?: true
  }

  export type AutomationMinAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    triggerType?: true
    status?: true
    lastRun?: true
    runCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationMaxAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    triggerType?: true
    status?: true
    lastRun?: true
    runCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationCountAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    triggerType?: true
    conditions?: true
    actions?: true
    status?: true
    lastRun?: true
    runCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutomationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automation to aggregate.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Automations
    **/
    _count?: true | AutomationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationMaxAggregateInputType
  }

  export type GetAutomationAggregateType<T extends AutomationAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomation[P]>
      : GetScalarType<T[P], AggregateAutomation[P]>
  }




  export type AutomationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithAggregationInput | AutomationOrderByWithAggregationInput[]
    by: AutomationScalarFieldEnum[] | AutomationScalarFieldEnum
    having?: AutomationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationCountAggregateInputType | true
    _avg?: AutomationAvgAggregateInputType
    _sum?: AutomationSumAggregateInputType
    _min?: AutomationMinAggregateInputType
    _max?: AutomationMaxAggregateInputType
  }

  export type AutomationGroupByOutputType = {
    id: string
    creatorId: string
    name: string
    triggerType: $Enums.AutomationTrigger
    conditions: JsonValue | null
    actions: JsonValue
    status: $Enums.AutomationStatus
    lastRun: Date | null
    runCount: number
    createdAt: Date
    updatedAt: Date
    _count: AutomationCountAggregateOutputType | null
    _avg: AutomationAvgAggregateOutputType | null
    _sum: AutomationSumAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  type GetAutomationGroupByPayload<T extends AutomationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationGroupByOutputType[P]>
        }
      >
    >


  export type AutomationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    name?: boolean
    triggerType?: boolean
    conditions?: boolean
    actions?: boolean
    status?: boolean
    lastRun?: boolean
    runCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    name?: boolean
    triggerType?: boolean
    conditions?: boolean
    actions?: boolean
    status?: boolean
    lastRun?: boolean
    runCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectScalar = {
    id?: boolean
    creatorId?: boolean
    name?: boolean
    triggerType?: boolean
    conditions?: boolean
    actions?: boolean
    status?: boolean
    lastRun?: boolean
    runCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $AutomationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Automation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      name: string
      triggerType: $Enums.AutomationTrigger
      conditions: Prisma.JsonValue | null
      actions: Prisma.JsonValue
      status: $Enums.AutomationStatus
      lastRun: Date | null
      runCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["automation"]>
    composites: {}
  }

  type AutomationGetPayload<S extends boolean | null | undefined | AutomationDefaultArgs> = $Result.GetResult<Prisma.$AutomationPayload, S>

  type AutomationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutomationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomationCountAggregateInputType | true
    }

  export interface AutomationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Automation'], meta: { name: 'Automation' } }
    /**
     * Find zero or one Automation that matches the filter.
     * @param {AutomationFindUniqueArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationFindUniqueArgs>(args: SelectSubset<T, AutomationFindUniqueArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Automation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutomationFindUniqueOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Automation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationFindFirstArgs>(args?: SelectSubset<T, AutomationFindFirstArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Automation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Automations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Automations
     * const automations = await prisma.automation.findMany()
     * 
     * // Get first 10 Automations
     * const automations = await prisma.automation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationWithIdOnly = await prisma.automation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationFindManyArgs>(args?: SelectSubset<T, AutomationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Automation.
     * @param {AutomationCreateArgs} args - Arguments to create a Automation.
     * @example
     * // Create one Automation
     * const Automation = await prisma.automation.create({
     *   data: {
     *     // ... data to create a Automation
     *   }
     * })
     * 
     */
    create<T extends AutomationCreateArgs>(args: SelectSubset<T, AutomationCreateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Automations.
     * @param {AutomationCreateManyArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationCreateManyArgs>(args?: SelectSubset<T, AutomationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Automations and returns the data saved in the database.
     * @param {AutomationCreateManyAndReturnArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Automations and only return the `id`
     * const automationWithIdOnly = await prisma.automation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Automation.
     * @param {AutomationDeleteArgs} args - Arguments to delete one Automation.
     * @example
     * // Delete one Automation
     * const Automation = await prisma.automation.delete({
     *   where: {
     *     // ... filter to delete one Automation
     *   }
     * })
     * 
     */
    delete<T extends AutomationDeleteArgs>(args: SelectSubset<T, AutomationDeleteArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Automation.
     * @param {AutomationUpdateArgs} args - Arguments to update one Automation.
     * @example
     * // Update one Automation
     * const automation = await prisma.automation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationUpdateArgs>(args: SelectSubset<T, AutomationUpdateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Automations.
     * @param {AutomationDeleteManyArgs} args - Arguments to filter Automations to delete.
     * @example
     * // Delete a few Automations
     * const { count } = await prisma.automation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationDeleteManyArgs>(args?: SelectSubset<T, AutomationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Automations
     * const automation = await prisma.automation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationUpdateManyArgs>(args: SelectSubset<T, AutomationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Automation.
     * @param {AutomationUpsertArgs} args - Arguments to update or create a Automation.
     * @example
     * // Update or create a Automation
     * const automation = await prisma.automation.upsert({
     *   create: {
     *     // ... data to create a Automation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Automation we want to update
     *   }
     * })
     */
    upsert<T extends AutomationUpsertArgs>(args: SelectSubset<T, AutomationUpsertArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationCountArgs} args - Arguments to filter Automations to count.
     * @example
     * // Count the number of Automations
     * const count = await prisma.automation.count({
     *   where: {
     *     // ... the filter for the Automations we want to count
     *   }
     * })
    **/
    count<T extends AutomationCountArgs>(
      args?: Subset<T, AutomationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationAggregateArgs>(args: Subset<T, AutomationAggregateArgs>): Prisma.PrismaPromise<GetAutomationAggregateType<T>>

    /**
     * Group by Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationGroupByArgs['orderBy'] }
        : { orderBy?: AutomationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Automation model
   */
  readonly fields: AutomationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Automation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Automation model
   */ 
  interface AutomationFieldRefs {
    readonly id: FieldRef<"Automation", 'String'>
    readonly creatorId: FieldRef<"Automation", 'String'>
    readonly name: FieldRef<"Automation", 'String'>
    readonly triggerType: FieldRef<"Automation", 'AutomationTrigger'>
    readonly conditions: FieldRef<"Automation", 'Json'>
    readonly actions: FieldRef<"Automation", 'Json'>
    readonly status: FieldRef<"Automation", 'AutomationStatus'>
    readonly lastRun: FieldRef<"Automation", 'DateTime'>
    readonly runCount: FieldRef<"Automation", 'Int'>
    readonly createdAt: FieldRef<"Automation", 'DateTime'>
    readonly updatedAt: FieldRef<"Automation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Automation findUnique
   */
  export type AutomationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findUniqueOrThrow
   */
  export type AutomationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findFirst
   */
  export type AutomationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findFirstOrThrow
   */
  export type AutomationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findMany
   */
  export type AutomationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation create
   */
  export type AutomationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * The data needed to create a Automation.
     */
    data: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
  }

  /**
   * Automation createMany
   */
  export type AutomationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Automation createManyAndReturn
   */
  export type AutomationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Automation update
   */
  export type AutomationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * The data needed to update a Automation.
     */
    data: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
    /**
     * Choose, which Automation to update.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation updateMany
   */
  export type AutomationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Automations.
     */
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyInput>
    /**
     * Filter which Automations to update
     */
    where?: AutomationWhereInput
  }

  /**
   * Automation upsert
   */
  export type AutomationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * The filter to search for the Automation to update in case it exists.
     */
    where: AutomationWhereUniqueInput
    /**
     * In case the Automation found by the `where` argument doesn't exist, create a new Automation with this data.
     */
    create: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
    /**
     * In case the Automation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
  }

  /**
   * Automation delete
   */
  export type AutomationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Filter which Automation to delete.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation deleteMany
   */
  export type AutomationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automations to delete
     */
    where?: AutomationWhereInput
  }

  /**
   * Automation without action
   */
  export type AutomationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
  }


  /**
   * Model BackupLog
   */

  export type AggregateBackupLog = {
    _count: BackupLogCountAggregateOutputType | null
    _avg: BackupLogAvgAggregateOutputType | null
    _sum: BackupLogSumAggregateOutputType | null
    _min: BackupLogMinAggregateOutputType | null
    _max: BackupLogMaxAggregateOutputType | null
  }

  export type BackupLogAvgAggregateOutputType = {
    duration: number | null
  }

  export type BackupLogSumAggregateOutputType = {
    duration: number | null
  }

  export type BackupLogMinAggregateOutputType = {
    id: string | null
    status: string | null
    duration: number | null
    error: string | null
    createdAt: Date | null
  }

  export type BackupLogMaxAggregateOutputType = {
    id: string | null
    status: string | null
    duration: number | null
    error: string | null
    createdAt: Date | null
  }

  export type BackupLogCountAggregateOutputType = {
    id: number
    status: number
    duration: number
    error: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type BackupLogAvgAggregateInputType = {
    duration?: true
  }

  export type BackupLogSumAggregateInputType = {
    duration?: true
  }

  export type BackupLogMinAggregateInputType = {
    id?: true
    status?: true
    duration?: true
    error?: true
    createdAt?: true
  }

  export type BackupLogMaxAggregateInputType = {
    id?: true
    status?: true
    duration?: true
    error?: true
    createdAt?: true
  }

  export type BackupLogCountAggregateInputType = {
    id?: true
    status?: true
    duration?: true
    error?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type BackupLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackupLog to aggregate.
     */
    where?: BackupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupLogs to fetch.
     */
    orderBy?: BackupLogOrderByWithRelationInput | BackupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BackupLogs
    **/
    _count?: true | BackupLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BackupLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BackupLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackupLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackupLogMaxAggregateInputType
  }

  export type GetBackupLogAggregateType<T extends BackupLogAggregateArgs> = {
        [P in keyof T & keyof AggregateBackupLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackupLog[P]>
      : GetScalarType<T[P], AggregateBackupLog[P]>
  }




  export type BackupLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackupLogWhereInput
    orderBy?: BackupLogOrderByWithAggregationInput | BackupLogOrderByWithAggregationInput[]
    by: BackupLogScalarFieldEnum[] | BackupLogScalarFieldEnum
    having?: BackupLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackupLogCountAggregateInputType | true
    _avg?: BackupLogAvgAggregateInputType
    _sum?: BackupLogSumAggregateInputType
    _min?: BackupLogMinAggregateInputType
    _max?: BackupLogMaxAggregateInputType
  }

  export type BackupLogGroupByOutputType = {
    id: string
    status: string
    duration: number | null
    error: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: BackupLogCountAggregateOutputType | null
    _avg: BackupLogAvgAggregateOutputType | null
    _sum: BackupLogSumAggregateOutputType | null
    _min: BackupLogMinAggregateOutputType | null
    _max: BackupLogMaxAggregateOutputType | null
  }

  type GetBackupLogGroupByPayload<T extends BackupLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackupLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackupLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackupLogGroupByOutputType[P]>
            : GetScalarType<T[P], BackupLogGroupByOutputType[P]>
        }
      >
    >


  export type BackupLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    duration?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["backupLog"]>

  export type BackupLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    duration?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["backupLog"]>

  export type BackupLogSelectScalar = {
    id?: boolean
    status?: boolean
    duration?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
  }


  export type $BackupLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BackupLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      duration: number | null
      error: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["backupLog"]>
    composites: {}
  }

  type BackupLogGetPayload<S extends boolean | null | undefined | BackupLogDefaultArgs> = $Result.GetResult<Prisma.$BackupLogPayload, S>

  type BackupLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BackupLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BackupLogCountAggregateInputType | true
    }

  export interface BackupLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BackupLog'], meta: { name: 'BackupLog' } }
    /**
     * Find zero or one BackupLog that matches the filter.
     * @param {BackupLogFindUniqueArgs} args - Arguments to find a BackupLog
     * @example
     * // Get one BackupLog
     * const backupLog = await prisma.backupLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackupLogFindUniqueArgs>(args: SelectSubset<T, BackupLogFindUniqueArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BackupLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BackupLogFindUniqueOrThrowArgs} args - Arguments to find a BackupLog
     * @example
     * // Get one BackupLog
     * const backupLog = await prisma.backupLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackupLogFindUniqueOrThrowArgs>(args: SelectSubset<T, BackupLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BackupLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogFindFirstArgs} args - Arguments to find a BackupLog
     * @example
     * // Get one BackupLog
     * const backupLog = await prisma.backupLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackupLogFindFirstArgs>(args?: SelectSubset<T, BackupLogFindFirstArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BackupLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogFindFirstOrThrowArgs} args - Arguments to find a BackupLog
     * @example
     * // Get one BackupLog
     * const backupLog = await prisma.backupLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackupLogFindFirstOrThrowArgs>(args?: SelectSubset<T, BackupLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BackupLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BackupLogs
     * const backupLogs = await prisma.backupLog.findMany()
     * 
     * // Get first 10 BackupLogs
     * const backupLogs = await prisma.backupLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backupLogWithIdOnly = await prisma.backupLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BackupLogFindManyArgs>(args?: SelectSubset<T, BackupLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BackupLog.
     * @param {BackupLogCreateArgs} args - Arguments to create a BackupLog.
     * @example
     * // Create one BackupLog
     * const BackupLog = await prisma.backupLog.create({
     *   data: {
     *     // ... data to create a BackupLog
     *   }
     * })
     * 
     */
    create<T extends BackupLogCreateArgs>(args: SelectSubset<T, BackupLogCreateArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BackupLogs.
     * @param {BackupLogCreateManyArgs} args - Arguments to create many BackupLogs.
     * @example
     * // Create many BackupLogs
     * const backupLog = await prisma.backupLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackupLogCreateManyArgs>(args?: SelectSubset<T, BackupLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BackupLogs and returns the data saved in the database.
     * @param {BackupLogCreateManyAndReturnArgs} args - Arguments to create many BackupLogs.
     * @example
     * // Create many BackupLogs
     * const backupLog = await prisma.backupLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BackupLogs and only return the `id`
     * const backupLogWithIdOnly = await prisma.backupLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BackupLogCreateManyAndReturnArgs>(args?: SelectSubset<T, BackupLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BackupLog.
     * @param {BackupLogDeleteArgs} args - Arguments to delete one BackupLog.
     * @example
     * // Delete one BackupLog
     * const BackupLog = await prisma.backupLog.delete({
     *   where: {
     *     // ... filter to delete one BackupLog
     *   }
     * })
     * 
     */
    delete<T extends BackupLogDeleteArgs>(args: SelectSubset<T, BackupLogDeleteArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BackupLog.
     * @param {BackupLogUpdateArgs} args - Arguments to update one BackupLog.
     * @example
     * // Update one BackupLog
     * const backupLog = await prisma.backupLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackupLogUpdateArgs>(args: SelectSubset<T, BackupLogUpdateArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BackupLogs.
     * @param {BackupLogDeleteManyArgs} args - Arguments to filter BackupLogs to delete.
     * @example
     * // Delete a few BackupLogs
     * const { count } = await prisma.backupLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackupLogDeleteManyArgs>(args?: SelectSubset<T, BackupLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BackupLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BackupLogs
     * const backupLog = await prisma.backupLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackupLogUpdateManyArgs>(args: SelectSubset<T, BackupLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BackupLog.
     * @param {BackupLogUpsertArgs} args - Arguments to update or create a BackupLog.
     * @example
     * // Update or create a BackupLog
     * const backupLog = await prisma.backupLog.upsert({
     *   create: {
     *     // ... data to create a BackupLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BackupLog we want to update
     *   }
     * })
     */
    upsert<T extends BackupLogUpsertArgs>(args: SelectSubset<T, BackupLogUpsertArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BackupLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogCountArgs} args - Arguments to filter BackupLogs to count.
     * @example
     * // Count the number of BackupLogs
     * const count = await prisma.backupLog.count({
     *   where: {
     *     // ... the filter for the BackupLogs we want to count
     *   }
     * })
    **/
    count<T extends BackupLogCountArgs>(
      args?: Subset<T, BackupLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackupLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BackupLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackupLogAggregateArgs>(args: Subset<T, BackupLogAggregateArgs>): Prisma.PrismaPromise<GetBackupLogAggregateType<T>>

    /**
     * Group by BackupLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackupLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackupLogGroupByArgs['orderBy'] }
        : { orderBy?: BackupLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackupLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackupLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BackupLog model
   */
  readonly fields: BackupLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BackupLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackupLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BackupLog model
   */ 
  interface BackupLogFieldRefs {
    readonly id: FieldRef<"BackupLog", 'String'>
    readonly status: FieldRef<"BackupLog", 'String'>
    readonly duration: FieldRef<"BackupLog", 'Int'>
    readonly error: FieldRef<"BackupLog", 'String'>
    readonly metadata: FieldRef<"BackupLog", 'Json'>
    readonly createdAt: FieldRef<"BackupLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BackupLog findUnique
   */
  export type BackupLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Filter, which BackupLog to fetch.
     */
    where: BackupLogWhereUniqueInput
  }

  /**
   * BackupLog findUniqueOrThrow
   */
  export type BackupLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Filter, which BackupLog to fetch.
     */
    where: BackupLogWhereUniqueInput
  }

  /**
   * BackupLog findFirst
   */
  export type BackupLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Filter, which BackupLog to fetch.
     */
    where?: BackupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupLogs to fetch.
     */
    orderBy?: BackupLogOrderByWithRelationInput | BackupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackupLogs.
     */
    cursor?: BackupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackupLogs.
     */
    distinct?: BackupLogScalarFieldEnum | BackupLogScalarFieldEnum[]
  }

  /**
   * BackupLog findFirstOrThrow
   */
  export type BackupLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Filter, which BackupLog to fetch.
     */
    where?: BackupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupLogs to fetch.
     */
    orderBy?: BackupLogOrderByWithRelationInput | BackupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackupLogs.
     */
    cursor?: BackupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackupLogs.
     */
    distinct?: BackupLogScalarFieldEnum | BackupLogScalarFieldEnum[]
  }

  /**
   * BackupLog findMany
   */
  export type BackupLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Filter, which BackupLogs to fetch.
     */
    where?: BackupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupLogs to fetch.
     */
    orderBy?: BackupLogOrderByWithRelationInput | BackupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BackupLogs.
     */
    cursor?: BackupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupLogs.
     */
    skip?: number
    distinct?: BackupLogScalarFieldEnum | BackupLogScalarFieldEnum[]
  }

  /**
   * BackupLog create
   */
  export type BackupLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * The data needed to create a BackupLog.
     */
    data: XOR<BackupLogCreateInput, BackupLogUncheckedCreateInput>
  }

  /**
   * BackupLog createMany
   */
  export type BackupLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BackupLogs.
     */
    data: BackupLogCreateManyInput | BackupLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackupLog createManyAndReturn
   */
  export type BackupLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BackupLogs.
     */
    data: BackupLogCreateManyInput | BackupLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackupLog update
   */
  export type BackupLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * The data needed to update a BackupLog.
     */
    data: XOR<BackupLogUpdateInput, BackupLogUncheckedUpdateInput>
    /**
     * Choose, which BackupLog to update.
     */
    where: BackupLogWhereUniqueInput
  }

  /**
   * BackupLog updateMany
   */
  export type BackupLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BackupLogs.
     */
    data: XOR<BackupLogUpdateManyMutationInput, BackupLogUncheckedUpdateManyInput>
    /**
     * Filter which BackupLogs to update
     */
    where?: BackupLogWhereInput
  }

  /**
   * BackupLog upsert
   */
  export type BackupLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * The filter to search for the BackupLog to update in case it exists.
     */
    where: BackupLogWhereUniqueInput
    /**
     * In case the BackupLog found by the `where` argument doesn't exist, create a new BackupLog with this data.
     */
    create: XOR<BackupLogCreateInput, BackupLogUncheckedCreateInput>
    /**
     * In case the BackupLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackupLogUpdateInput, BackupLogUncheckedUpdateInput>
  }

  /**
   * BackupLog delete
   */
  export type BackupLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Filter which BackupLog to delete.
     */
    where: BackupLogWhereUniqueInput
  }

  /**
   * BackupLog deleteMany
   */
  export type BackupLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackupLogs to delete
     */
    where?: BackupLogWhereInput
  }

  /**
   * BackupLog without action
   */
  export type BackupLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
  }


  /**
   * Model BackupValidation
   */

  export type AggregateBackupValidation = {
    _count: BackupValidationCountAggregateOutputType | null
    _min: BackupValidationMinAggregateOutputType | null
    _max: BackupValidationMaxAggregateOutputType | null
  }

  export type BackupValidationMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type BackupValidationMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type BackupValidationCountAggregateOutputType = {
    id: number
    timestamp: number
    results: number
    summary: number
    status: number
    createdAt: number
    _all: number
  }


  export type BackupValidationMinAggregateInputType = {
    id?: true
    timestamp?: true
    status?: true
    createdAt?: true
  }

  export type BackupValidationMaxAggregateInputType = {
    id?: true
    timestamp?: true
    status?: true
    createdAt?: true
  }

  export type BackupValidationCountAggregateInputType = {
    id?: true
    timestamp?: true
    results?: true
    summary?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type BackupValidationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackupValidation to aggregate.
     */
    where?: BackupValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupValidations to fetch.
     */
    orderBy?: BackupValidationOrderByWithRelationInput | BackupValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackupValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BackupValidations
    **/
    _count?: true | BackupValidationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackupValidationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackupValidationMaxAggregateInputType
  }

  export type GetBackupValidationAggregateType<T extends BackupValidationAggregateArgs> = {
        [P in keyof T & keyof AggregateBackupValidation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackupValidation[P]>
      : GetScalarType<T[P], AggregateBackupValidation[P]>
  }




  export type BackupValidationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackupValidationWhereInput
    orderBy?: BackupValidationOrderByWithAggregationInput | BackupValidationOrderByWithAggregationInput[]
    by: BackupValidationScalarFieldEnum[] | BackupValidationScalarFieldEnum
    having?: BackupValidationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackupValidationCountAggregateInputType | true
    _min?: BackupValidationMinAggregateInputType
    _max?: BackupValidationMaxAggregateInputType
  }

  export type BackupValidationGroupByOutputType = {
    id: string
    timestamp: Date
    results: JsonValue
    summary: JsonValue
    status: string
    createdAt: Date
    _count: BackupValidationCountAggregateOutputType | null
    _min: BackupValidationMinAggregateOutputType | null
    _max: BackupValidationMaxAggregateOutputType | null
  }

  type GetBackupValidationGroupByPayload<T extends BackupValidationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackupValidationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackupValidationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackupValidationGroupByOutputType[P]>
            : GetScalarType<T[P], BackupValidationGroupByOutputType[P]>
        }
      >
    >


  export type BackupValidationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    results?: boolean
    summary?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["backupValidation"]>

  export type BackupValidationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    results?: boolean
    summary?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["backupValidation"]>

  export type BackupValidationSelectScalar = {
    id?: boolean
    timestamp?: boolean
    results?: boolean
    summary?: boolean
    status?: boolean
    createdAt?: boolean
  }


  export type $BackupValidationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BackupValidation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      results: Prisma.JsonValue
      summary: Prisma.JsonValue
      status: string
      createdAt: Date
    }, ExtArgs["result"]["backupValidation"]>
    composites: {}
  }

  type BackupValidationGetPayload<S extends boolean | null | undefined | BackupValidationDefaultArgs> = $Result.GetResult<Prisma.$BackupValidationPayload, S>

  type BackupValidationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BackupValidationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BackupValidationCountAggregateInputType | true
    }

  export interface BackupValidationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BackupValidation'], meta: { name: 'BackupValidation' } }
    /**
     * Find zero or one BackupValidation that matches the filter.
     * @param {BackupValidationFindUniqueArgs} args - Arguments to find a BackupValidation
     * @example
     * // Get one BackupValidation
     * const backupValidation = await prisma.backupValidation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackupValidationFindUniqueArgs>(args: SelectSubset<T, BackupValidationFindUniqueArgs<ExtArgs>>): Prisma__BackupValidationClient<$Result.GetResult<Prisma.$BackupValidationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BackupValidation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BackupValidationFindUniqueOrThrowArgs} args - Arguments to find a BackupValidation
     * @example
     * // Get one BackupValidation
     * const backupValidation = await prisma.backupValidation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackupValidationFindUniqueOrThrowArgs>(args: SelectSubset<T, BackupValidationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackupValidationClient<$Result.GetResult<Prisma.$BackupValidationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BackupValidation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupValidationFindFirstArgs} args - Arguments to find a BackupValidation
     * @example
     * // Get one BackupValidation
     * const backupValidation = await prisma.backupValidation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackupValidationFindFirstArgs>(args?: SelectSubset<T, BackupValidationFindFirstArgs<ExtArgs>>): Prisma__BackupValidationClient<$Result.GetResult<Prisma.$BackupValidationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BackupValidation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupValidationFindFirstOrThrowArgs} args - Arguments to find a BackupValidation
     * @example
     * // Get one BackupValidation
     * const backupValidation = await prisma.backupValidation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackupValidationFindFirstOrThrowArgs>(args?: SelectSubset<T, BackupValidationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackupValidationClient<$Result.GetResult<Prisma.$BackupValidationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BackupValidations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupValidationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BackupValidations
     * const backupValidations = await prisma.backupValidation.findMany()
     * 
     * // Get first 10 BackupValidations
     * const backupValidations = await prisma.backupValidation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backupValidationWithIdOnly = await prisma.backupValidation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BackupValidationFindManyArgs>(args?: SelectSubset<T, BackupValidationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupValidationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BackupValidation.
     * @param {BackupValidationCreateArgs} args - Arguments to create a BackupValidation.
     * @example
     * // Create one BackupValidation
     * const BackupValidation = await prisma.backupValidation.create({
     *   data: {
     *     // ... data to create a BackupValidation
     *   }
     * })
     * 
     */
    create<T extends BackupValidationCreateArgs>(args: SelectSubset<T, BackupValidationCreateArgs<ExtArgs>>): Prisma__BackupValidationClient<$Result.GetResult<Prisma.$BackupValidationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BackupValidations.
     * @param {BackupValidationCreateManyArgs} args - Arguments to create many BackupValidations.
     * @example
     * // Create many BackupValidations
     * const backupValidation = await prisma.backupValidation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackupValidationCreateManyArgs>(args?: SelectSubset<T, BackupValidationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BackupValidations and returns the data saved in the database.
     * @param {BackupValidationCreateManyAndReturnArgs} args - Arguments to create many BackupValidations.
     * @example
     * // Create many BackupValidations
     * const backupValidation = await prisma.backupValidation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BackupValidations and only return the `id`
     * const backupValidationWithIdOnly = await prisma.backupValidation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BackupValidationCreateManyAndReturnArgs>(args?: SelectSubset<T, BackupValidationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupValidationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BackupValidation.
     * @param {BackupValidationDeleteArgs} args - Arguments to delete one BackupValidation.
     * @example
     * // Delete one BackupValidation
     * const BackupValidation = await prisma.backupValidation.delete({
     *   where: {
     *     // ... filter to delete one BackupValidation
     *   }
     * })
     * 
     */
    delete<T extends BackupValidationDeleteArgs>(args: SelectSubset<T, BackupValidationDeleteArgs<ExtArgs>>): Prisma__BackupValidationClient<$Result.GetResult<Prisma.$BackupValidationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BackupValidation.
     * @param {BackupValidationUpdateArgs} args - Arguments to update one BackupValidation.
     * @example
     * // Update one BackupValidation
     * const backupValidation = await prisma.backupValidation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackupValidationUpdateArgs>(args: SelectSubset<T, BackupValidationUpdateArgs<ExtArgs>>): Prisma__BackupValidationClient<$Result.GetResult<Prisma.$BackupValidationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BackupValidations.
     * @param {BackupValidationDeleteManyArgs} args - Arguments to filter BackupValidations to delete.
     * @example
     * // Delete a few BackupValidations
     * const { count } = await prisma.backupValidation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackupValidationDeleteManyArgs>(args?: SelectSubset<T, BackupValidationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BackupValidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupValidationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BackupValidations
     * const backupValidation = await prisma.backupValidation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackupValidationUpdateManyArgs>(args: SelectSubset<T, BackupValidationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BackupValidation.
     * @param {BackupValidationUpsertArgs} args - Arguments to update or create a BackupValidation.
     * @example
     * // Update or create a BackupValidation
     * const backupValidation = await prisma.backupValidation.upsert({
     *   create: {
     *     // ... data to create a BackupValidation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BackupValidation we want to update
     *   }
     * })
     */
    upsert<T extends BackupValidationUpsertArgs>(args: SelectSubset<T, BackupValidationUpsertArgs<ExtArgs>>): Prisma__BackupValidationClient<$Result.GetResult<Prisma.$BackupValidationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BackupValidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupValidationCountArgs} args - Arguments to filter BackupValidations to count.
     * @example
     * // Count the number of BackupValidations
     * const count = await prisma.backupValidation.count({
     *   where: {
     *     // ... the filter for the BackupValidations we want to count
     *   }
     * })
    **/
    count<T extends BackupValidationCountArgs>(
      args?: Subset<T, BackupValidationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackupValidationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BackupValidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupValidationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackupValidationAggregateArgs>(args: Subset<T, BackupValidationAggregateArgs>): Prisma.PrismaPromise<GetBackupValidationAggregateType<T>>

    /**
     * Group by BackupValidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupValidationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackupValidationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackupValidationGroupByArgs['orderBy'] }
        : { orderBy?: BackupValidationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackupValidationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackupValidationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BackupValidation model
   */
  readonly fields: BackupValidationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BackupValidation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackupValidationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BackupValidation model
   */ 
  interface BackupValidationFieldRefs {
    readonly id: FieldRef<"BackupValidation", 'String'>
    readonly timestamp: FieldRef<"BackupValidation", 'DateTime'>
    readonly results: FieldRef<"BackupValidation", 'Json'>
    readonly summary: FieldRef<"BackupValidation", 'Json'>
    readonly status: FieldRef<"BackupValidation", 'String'>
    readonly createdAt: FieldRef<"BackupValidation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BackupValidation findUnique
   */
  export type BackupValidationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupValidation
     */
    select?: BackupValidationSelect<ExtArgs> | null
    /**
     * Filter, which BackupValidation to fetch.
     */
    where: BackupValidationWhereUniqueInput
  }

  /**
   * BackupValidation findUniqueOrThrow
   */
  export type BackupValidationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupValidation
     */
    select?: BackupValidationSelect<ExtArgs> | null
    /**
     * Filter, which BackupValidation to fetch.
     */
    where: BackupValidationWhereUniqueInput
  }

  /**
   * BackupValidation findFirst
   */
  export type BackupValidationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupValidation
     */
    select?: BackupValidationSelect<ExtArgs> | null
    /**
     * Filter, which BackupValidation to fetch.
     */
    where?: BackupValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupValidations to fetch.
     */
    orderBy?: BackupValidationOrderByWithRelationInput | BackupValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackupValidations.
     */
    cursor?: BackupValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackupValidations.
     */
    distinct?: BackupValidationScalarFieldEnum | BackupValidationScalarFieldEnum[]
  }

  /**
   * BackupValidation findFirstOrThrow
   */
  export type BackupValidationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupValidation
     */
    select?: BackupValidationSelect<ExtArgs> | null
    /**
     * Filter, which BackupValidation to fetch.
     */
    where?: BackupValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupValidations to fetch.
     */
    orderBy?: BackupValidationOrderByWithRelationInput | BackupValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackupValidations.
     */
    cursor?: BackupValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackupValidations.
     */
    distinct?: BackupValidationScalarFieldEnum | BackupValidationScalarFieldEnum[]
  }

  /**
   * BackupValidation findMany
   */
  export type BackupValidationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupValidation
     */
    select?: BackupValidationSelect<ExtArgs> | null
    /**
     * Filter, which BackupValidations to fetch.
     */
    where?: BackupValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupValidations to fetch.
     */
    orderBy?: BackupValidationOrderByWithRelationInput | BackupValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BackupValidations.
     */
    cursor?: BackupValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupValidations.
     */
    skip?: number
    distinct?: BackupValidationScalarFieldEnum | BackupValidationScalarFieldEnum[]
  }

  /**
   * BackupValidation create
   */
  export type BackupValidationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupValidation
     */
    select?: BackupValidationSelect<ExtArgs> | null
    /**
     * The data needed to create a BackupValidation.
     */
    data: XOR<BackupValidationCreateInput, BackupValidationUncheckedCreateInput>
  }

  /**
   * BackupValidation createMany
   */
  export type BackupValidationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BackupValidations.
     */
    data: BackupValidationCreateManyInput | BackupValidationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackupValidation createManyAndReturn
   */
  export type BackupValidationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupValidation
     */
    select?: BackupValidationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BackupValidations.
     */
    data: BackupValidationCreateManyInput | BackupValidationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackupValidation update
   */
  export type BackupValidationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupValidation
     */
    select?: BackupValidationSelect<ExtArgs> | null
    /**
     * The data needed to update a BackupValidation.
     */
    data: XOR<BackupValidationUpdateInput, BackupValidationUncheckedUpdateInput>
    /**
     * Choose, which BackupValidation to update.
     */
    where: BackupValidationWhereUniqueInput
  }

  /**
   * BackupValidation updateMany
   */
  export type BackupValidationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BackupValidations.
     */
    data: XOR<BackupValidationUpdateManyMutationInput, BackupValidationUncheckedUpdateManyInput>
    /**
     * Filter which BackupValidations to update
     */
    where?: BackupValidationWhereInput
  }

  /**
   * BackupValidation upsert
   */
  export type BackupValidationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupValidation
     */
    select?: BackupValidationSelect<ExtArgs> | null
    /**
     * The filter to search for the BackupValidation to update in case it exists.
     */
    where: BackupValidationWhereUniqueInput
    /**
     * In case the BackupValidation found by the `where` argument doesn't exist, create a new BackupValidation with this data.
     */
    create: XOR<BackupValidationCreateInput, BackupValidationUncheckedCreateInput>
    /**
     * In case the BackupValidation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackupValidationUpdateInput, BackupValidationUncheckedUpdateInput>
  }

  /**
   * BackupValidation delete
   */
  export type BackupValidationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupValidation
     */
    select?: BackupValidationSelect<ExtArgs> | null
    /**
     * Filter which BackupValidation to delete.
     */
    where: BackupValidationWhereUniqueInput
  }

  /**
   * BackupValidation deleteMany
   */
  export type BackupValidationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackupValidations to delete
     */
    where?: BackupValidationWhereInput
  }

  /**
   * BackupValidation without action
   */
  export type BackupValidationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupValidation
     */
    select?: BackupValidationSelect<ExtArgs> | null
  }


  /**
   * Model BackupIndex
   */

  export type AggregateBackupIndex = {
    _count: BackupIndexCountAggregateOutputType | null
    _min: BackupIndexMinAggregateOutputType | null
    _max: BackupIndexMaxAggregateOutputType | null
  }

  export type BackupIndexMinAggregateOutputType = {
    id: string | null
    backupId: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type BackupIndexMaxAggregateOutputType = {
    id: string | null
    backupId: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type BackupIndexCountAggregateOutputType = {
    id: number
    backupId: number
    timestamp: number
    metadata: number
    tables: number
    createdAt: number
    _all: number
  }


  export type BackupIndexMinAggregateInputType = {
    id?: true
    backupId?: true
    timestamp?: true
    createdAt?: true
  }

  export type BackupIndexMaxAggregateInputType = {
    id?: true
    backupId?: true
    timestamp?: true
    createdAt?: true
  }

  export type BackupIndexCountAggregateInputType = {
    id?: true
    backupId?: true
    timestamp?: true
    metadata?: true
    tables?: true
    createdAt?: true
    _all?: true
  }

  export type BackupIndexAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackupIndex to aggregate.
     */
    where?: BackupIndexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupIndices to fetch.
     */
    orderBy?: BackupIndexOrderByWithRelationInput | BackupIndexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackupIndexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupIndices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupIndices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BackupIndices
    **/
    _count?: true | BackupIndexCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackupIndexMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackupIndexMaxAggregateInputType
  }

  export type GetBackupIndexAggregateType<T extends BackupIndexAggregateArgs> = {
        [P in keyof T & keyof AggregateBackupIndex]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackupIndex[P]>
      : GetScalarType<T[P], AggregateBackupIndex[P]>
  }




  export type BackupIndexGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackupIndexWhereInput
    orderBy?: BackupIndexOrderByWithAggregationInput | BackupIndexOrderByWithAggregationInput[]
    by: BackupIndexScalarFieldEnum[] | BackupIndexScalarFieldEnum
    having?: BackupIndexScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackupIndexCountAggregateInputType | true
    _min?: BackupIndexMinAggregateInputType
    _max?: BackupIndexMaxAggregateInputType
  }

  export type BackupIndexGroupByOutputType = {
    id: string
    backupId: string
    timestamp: Date
    metadata: JsonValue
    tables: JsonValue
    createdAt: Date
    _count: BackupIndexCountAggregateOutputType | null
    _min: BackupIndexMinAggregateOutputType | null
    _max: BackupIndexMaxAggregateOutputType | null
  }

  type GetBackupIndexGroupByPayload<T extends BackupIndexGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackupIndexGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackupIndexGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackupIndexGroupByOutputType[P]>
            : GetScalarType<T[P], BackupIndexGroupByOutputType[P]>
        }
      >
    >


  export type BackupIndexSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    backupId?: boolean
    timestamp?: boolean
    metadata?: boolean
    tables?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["backupIndex"]>

  export type BackupIndexSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    backupId?: boolean
    timestamp?: boolean
    metadata?: boolean
    tables?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["backupIndex"]>

  export type BackupIndexSelectScalar = {
    id?: boolean
    backupId?: boolean
    timestamp?: boolean
    metadata?: boolean
    tables?: boolean
    createdAt?: boolean
  }


  export type $BackupIndexPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BackupIndex"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      backupId: string
      timestamp: Date
      metadata: Prisma.JsonValue
      tables: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["backupIndex"]>
    composites: {}
  }

  type BackupIndexGetPayload<S extends boolean | null | undefined | BackupIndexDefaultArgs> = $Result.GetResult<Prisma.$BackupIndexPayload, S>

  type BackupIndexCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BackupIndexFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BackupIndexCountAggregateInputType | true
    }

  export interface BackupIndexDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BackupIndex'], meta: { name: 'BackupIndex' } }
    /**
     * Find zero or one BackupIndex that matches the filter.
     * @param {BackupIndexFindUniqueArgs} args - Arguments to find a BackupIndex
     * @example
     * // Get one BackupIndex
     * const backupIndex = await prisma.backupIndex.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackupIndexFindUniqueArgs>(args: SelectSubset<T, BackupIndexFindUniqueArgs<ExtArgs>>): Prisma__BackupIndexClient<$Result.GetResult<Prisma.$BackupIndexPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BackupIndex that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BackupIndexFindUniqueOrThrowArgs} args - Arguments to find a BackupIndex
     * @example
     * // Get one BackupIndex
     * const backupIndex = await prisma.backupIndex.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackupIndexFindUniqueOrThrowArgs>(args: SelectSubset<T, BackupIndexFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackupIndexClient<$Result.GetResult<Prisma.$BackupIndexPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BackupIndex that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupIndexFindFirstArgs} args - Arguments to find a BackupIndex
     * @example
     * // Get one BackupIndex
     * const backupIndex = await prisma.backupIndex.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackupIndexFindFirstArgs>(args?: SelectSubset<T, BackupIndexFindFirstArgs<ExtArgs>>): Prisma__BackupIndexClient<$Result.GetResult<Prisma.$BackupIndexPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BackupIndex that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupIndexFindFirstOrThrowArgs} args - Arguments to find a BackupIndex
     * @example
     * // Get one BackupIndex
     * const backupIndex = await prisma.backupIndex.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackupIndexFindFirstOrThrowArgs>(args?: SelectSubset<T, BackupIndexFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackupIndexClient<$Result.GetResult<Prisma.$BackupIndexPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BackupIndices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupIndexFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BackupIndices
     * const backupIndices = await prisma.backupIndex.findMany()
     * 
     * // Get first 10 BackupIndices
     * const backupIndices = await prisma.backupIndex.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backupIndexWithIdOnly = await prisma.backupIndex.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BackupIndexFindManyArgs>(args?: SelectSubset<T, BackupIndexFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupIndexPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BackupIndex.
     * @param {BackupIndexCreateArgs} args - Arguments to create a BackupIndex.
     * @example
     * // Create one BackupIndex
     * const BackupIndex = await prisma.backupIndex.create({
     *   data: {
     *     // ... data to create a BackupIndex
     *   }
     * })
     * 
     */
    create<T extends BackupIndexCreateArgs>(args: SelectSubset<T, BackupIndexCreateArgs<ExtArgs>>): Prisma__BackupIndexClient<$Result.GetResult<Prisma.$BackupIndexPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BackupIndices.
     * @param {BackupIndexCreateManyArgs} args - Arguments to create many BackupIndices.
     * @example
     * // Create many BackupIndices
     * const backupIndex = await prisma.backupIndex.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackupIndexCreateManyArgs>(args?: SelectSubset<T, BackupIndexCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BackupIndices and returns the data saved in the database.
     * @param {BackupIndexCreateManyAndReturnArgs} args - Arguments to create many BackupIndices.
     * @example
     * // Create many BackupIndices
     * const backupIndex = await prisma.backupIndex.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BackupIndices and only return the `id`
     * const backupIndexWithIdOnly = await prisma.backupIndex.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BackupIndexCreateManyAndReturnArgs>(args?: SelectSubset<T, BackupIndexCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupIndexPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BackupIndex.
     * @param {BackupIndexDeleteArgs} args - Arguments to delete one BackupIndex.
     * @example
     * // Delete one BackupIndex
     * const BackupIndex = await prisma.backupIndex.delete({
     *   where: {
     *     // ... filter to delete one BackupIndex
     *   }
     * })
     * 
     */
    delete<T extends BackupIndexDeleteArgs>(args: SelectSubset<T, BackupIndexDeleteArgs<ExtArgs>>): Prisma__BackupIndexClient<$Result.GetResult<Prisma.$BackupIndexPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BackupIndex.
     * @param {BackupIndexUpdateArgs} args - Arguments to update one BackupIndex.
     * @example
     * // Update one BackupIndex
     * const backupIndex = await prisma.backupIndex.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackupIndexUpdateArgs>(args: SelectSubset<T, BackupIndexUpdateArgs<ExtArgs>>): Prisma__BackupIndexClient<$Result.GetResult<Prisma.$BackupIndexPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BackupIndices.
     * @param {BackupIndexDeleteManyArgs} args - Arguments to filter BackupIndices to delete.
     * @example
     * // Delete a few BackupIndices
     * const { count } = await prisma.backupIndex.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackupIndexDeleteManyArgs>(args?: SelectSubset<T, BackupIndexDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BackupIndices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupIndexUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BackupIndices
     * const backupIndex = await prisma.backupIndex.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackupIndexUpdateManyArgs>(args: SelectSubset<T, BackupIndexUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BackupIndex.
     * @param {BackupIndexUpsertArgs} args - Arguments to update or create a BackupIndex.
     * @example
     * // Update or create a BackupIndex
     * const backupIndex = await prisma.backupIndex.upsert({
     *   create: {
     *     // ... data to create a BackupIndex
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BackupIndex we want to update
     *   }
     * })
     */
    upsert<T extends BackupIndexUpsertArgs>(args: SelectSubset<T, BackupIndexUpsertArgs<ExtArgs>>): Prisma__BackupIndexClient<$Result.GetResult<Prisma.$BackupIndexPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BackupIndices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupIndexCountArgs} args - Arguments to filter BackupIndices to count.
     * @example
     * // Count the number of BackupIndices
     * const count = await prisma.backupIndex.count({
     *   where: {
     *     // ... the filter for the BackupIndices we want to count
     *   }
     * })
    **/
    count<T extends BackupIndexCountArgs>(
      args?: Subset<T, BackupIndexCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackupIndexCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BackupIndex.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupIndexAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackupIndexAggregateArgs>(args: Subset<T, BackupIndexAggregateArgs>): Prisma.PrismaPromise<GetBackupIndexAggregateType<T>>

    /**
     * Group by BackupIndex.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupIndexGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackupIndexGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackupIndexGroupByArgs['orderBy'] }
        : { orderBy?: BackupIndexGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackupIndexGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackupIndexGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BackupIndex model
   */
  readonly fields: BackupIndexFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BackupIndex.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackupIndexClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BackupIndex model
   */ 
  interface BackupIndexFieldRefs {
    readonly id: FieldRef<"BackupIndex", 'String'>
    readonly backupId: FieldRef<"BackupIndex", 'String'>
    readonly timestamp: FieldRef<"BackupIndex", 'DateTime'>
    readonly metadata: FieldRef<"BackupIndex", 'Json'>
    readonly tables: FieldRef<"BackupIndex", 'Json'>
    readonly createdAt: FieldRef<"BackupIndex", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BackupIndex findUnique
   */
  export type BackupIndexFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupIndex
     */
    select?: BackupIndexSelect<ExtArgs> | null
    /**
     * Filter, which BackupIndex to fetch.
     */
    where: BackupIndexWhereUniqueInput
  }

  /**
   * BackupIndex findUniqueOrThrow
   */
  export type BackupIndexFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupIndex
     */
    select?: BackupIndexSelect<ExtArgs> | null
    /**
     * Filter, which BackupIndex to fetch.
     */
    where: BackupIndexWhereUniqueInput
  }

  /**
   * BackupIndex findFirst
   */
  export type BackupIndexFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupIndex
     */
    select?: BackupIndexSelect<ExtArgs> | null
    /**
     * Filter, which BackupIndex to fetch.
     */
    where?: BackupIndexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupIndices to fetch.
     */
    orderBy?: BackupIndexOrderByWithRelationInput | BackupIndexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackupIndices.
     */
    cursor?: BackupIndexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupIndices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupIndices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackupIndices.
     */
    distinct?: BackupIndexScalarFieldEnum | BackupIndexScalarFieldEnum[]
  }

  /**
   * BackupIndex findFirstOrThrow
   */
  export type BackupIndexFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupIndex
     */
    select?: BackupIndexSelect<ExtArgs> | null
    /**
     * Filter, which BackupIndex to fetch.
     */
    where?: BackupIndexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupIndices to fetch.
     */
    orderBy?: BackupIndexOrderByWithRelationInput | BackupIndexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackupIndices.
     */
    cursor?: BackupIndexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupIndices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupIndices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackupIndices.
     */
    distinct?: BackupIndexScalarFieldEnum | BackupIndexScalarFieldEnum[]
  }

  /**
   * BackupIndex findMany
   */
  export type BackupIndexFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupIndex
     */
    select?: BackupIndexSelect<ExtArgs> | null
    /**
     * Filter, which BackupIndices to fetch.
     */
    where?: BackupIndexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupIndices to fetch.
     */
    orderBy?: BackupIndexOrderByWithRelationInput | BackupIndexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BackupIndices.
     */
    cursor?: BackupIndexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupIndices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupIndices.
     */
    skip?: number
    distinct?: BackupIndexScalarFieldEnum | BackupIndexScalarFieldEnum[]
  }

  /**
   * BackupIndex create
   */
  export type BackupIndexCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupIndex
     */
    select?: BackupIndexSelect<ExtArgs> | null
    /**
     * The data needed to create a BackupIndex.
     */
    data: XOR<BackupIndexCreateInput, BackupIndexUncheckedCreateInput>
  }

  /**
   * BackupIndex createMany
   */
  export type BackupIndexCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BackupIndices.
     */
    data: BackupIndexCreateManyInput | BackupIndexCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackupIndex createManyAndReturn
   */
  export type BackupIndexCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupIndex
     */
    select?: BackupIndexSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BackupIndices.
     */
    data: BackupIndexCreateManyInput | BackupIndexCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackupIndex update
   */
  export type BackupIndexUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupIndex
     */
    select?: BackupIndexSelect<ExtArgs> | null
    /**
     * The data needed to update a BackupIndex.
     */
    data: XOR<BackupIndexUpdateInput, BackupIndexUncheckedUpdateInput>
    /**
     * Choose, which BackupIndex to update.
     */
    where: BackupIndexWhereUniqueInput
  }

  /**
   * BackupIndex updateMany
   */
  export type BackupIndexUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BackupIndices.
     */
    data: XOR<BackupIndexUpdateManyMutationInput, BackupIndexUncheckedUpdateManyInput>
    /**
     * Filter which BackupIndices to update
     */
    where?: BackupIndexWhereInput
  }

  /**
   * BackupIndex upsert
   */
  export type BackupIndexUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupIndex
     */
    select?: BackupIndexSelect<ExtArgs> | null
    /**
     * The filter to search for the BackupIndex to update in case it exists.
     */
    where: BackupIndexWhereUniqueInput
    /**
     * In case the BackupIndex found by the `where` argument doesn't exist, create a new BackupIndex with this data.
     */
    create: XOR<BackupIndexCreateInput, BackupIndexUncheckedCreateInput>
    /**
     * In case the BackupIndex was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackupIndexUpdateInput, BackupIndexUncheckedUpdateInput>
  }

  /**
   * BackupIndex delete
   */
  export type BackupIndexDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupIndex
     */
    select?: BackupIndexSelect<ExtArgs> | null
    /**
     * Filter which BackupIndex to delete.
     */
    where: BackupIndexWhereUniqueInput
  }

  /**
   * BackupIndex deleteMany
   */
  export type BackupIndexDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackupIndices to delete
     */
    where?: BackupIndexWhereInput
  }

  /**
   * BackupIndex without action
   */
  export type BackupIndexDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupIndex
     */
    select?: BackupIndexSelect<ExtArgs> | null
  }


  /**
   * Model AIUsageLog
   */

  export type AggregateAIUsageLog = {
    _count: AIUsageLogCountAggregateOutputType | null
    _avg: AIUsageLogAvgAggregateOutputType | null
    _sum: AIUsageLogSumAggregateOutputType | null
    _min: AIUsageLogMinAggregateOutputType | null
    _max: AIUsageLogMaxAggregateOutputType | null
  }

  export type AIUsageLogAvgAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    cost: number | null
  }

  export type AIUsageLogSumAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    cost: number | null
  }

  export type AIUsageLogMinAggregateOutputType = {
    id: string | null
    provider: string | null
    model: string | null
    purpose: string | null
    userId: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    cost: number | null
    cached: boolean | null
    timestamp: Date | null
  }

  export type AIUsageLogMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    model: string | null
    purpose: string | null
    userId: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    cost: number | null
    cached: boolean | null
    timestamp: Date | null
  }

  export type AIUsageLogCountAggregateOutputType = {
    id: number
    provider: number
    model: number
    purpose: number
    userId: number
    promptTokens: number
    completionTokens: number
    totalTokens: number
    cost: number
    cached: number
    timestamp: number
    _all: number
  }


  export type AIUsageLogAvgAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    cost?: true
  }

  export type AIUsageLogSumAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    cost?: true
  }

  export type AIUsageLogMinAggregateInputType = {
    id?: true
    provider?: true
    model?: true
    purpose?: true
    userId?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    cost?: true
    cached?: true
    timestamp?: true
  }

  export type AIUsageLogMaxAggregateInputType = {
    id?: true
    provider?: true
    model?: true
    purpose?: true
    userId?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    cost?: true
    cached?: true
    timestamp?: true
  }

  export type AIUsageLogCountAggregateInputType = {
    id?: true
    provider?: true
    model?: true
    purpose?: true
    userId?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    cost?: true
    cached?: true
    timestamp?: true
    _all?: true
  }

  export type AIUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageLog to aggregate.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIUsageLogs
    **/
    _count?: true | AIUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIUsageLogMaxAggregateInputType
  }

  export type GetAIUsageLogAggregateType<T extends AIUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAIUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIUsageLog[P]>
      : GetScalarType<T[P], AggregateAIUsageLog[P]>
  }




  export type AIUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageLogWhereInput
    orderBy?: AIUsageLogOrderByWithAggregationInput | AIUsageLogOrderByWithAggregationInput[]
    by: AIUsageLogScalarFieldEnum[] | AIUsageLogScalarFieldEnum
    having?: AIUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIUsageLogCountAggregateInputType | true
    _avg?: AIUsageLogAvgAggregateInputType
    _sum?: AIUsageLogSumAggregateInputType
    _min?: AIUsageLogMinAggregateInputType
    _max?: AIUsageLogMaxAggregateInputType
  }

  export type AIUsageLogGroupByOutputType = {
    id: string
    provider: string
    model: string
    purpose: string
    userId: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    cost: number
    cached: boolean
    timestamp: Date
    _count: AIUsageLogCountAggregateOutputType | null
    _avg: AIUsageLogAvgAggregateOutputType | null
    _sum: AIUsageLogSumAggregateOutputType | null
    _min: AIUsageLogMinAggregateOutputType | null
    _max: AIUsageLogMaxAggregateOutputType | null
  }

  type GetAIUsageLogGroupByPayload<T extends AIUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], AIUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type AIUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    model?: boolean
    purpose?: boolean
    userId?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    cost?: boolean
    cached?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["aIUsageLog"]>

  export type AIUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    model?: boolean
    purpose?: boolean
    userId?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    cost?: boolean
    cached?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["aIUsageLog"]>

  export type AIUsageLogSelectScalar = {
    id?: boolean
    provider?: boolean
    model?: boolean
    purpose?: boolean
    userId?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    cost?: boolean
    cached?: boolean
    timestamp?: boolean
  }


  export type $AIUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIUsageLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      model: string
      purpose: string
      userId: string
      promptTokens: number
      completionTokens: number
      totalTokens: number
      cost: number
      cached: boolean
      timestamp: Date
    }, ExtArgs["result"]["aIUsageLog"]>
    composites: {}
  }

  type AIUsageLogGetPayload<S extends boolean | null | undefined | AIUsageLogDefaultArgs> = $Result.GetResult<Prisma.$AIUsageLogPayload, S>

  type AIUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AIUsageLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AIUsageLogCountAggregateInputType | true
    }

  export interface AIUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIUsageLog'], meta: { name: 'AIUsageLog' } }
    /**
     * Find zero or one AIUsageLog that matches the filter.
     * @param {AIUsageLogFindUniqueArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIUsageLogFindUniqueArgs>(args: SelectSubset<T, AIUsageLogFindUniqueArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AIUsageLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AIUsageLogFindUniqueOrThrowArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AIUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AIUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindFirstArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIUsageLogFindFirstArgs>(args?: SelectSubset<T, AIUsageLogFindFirstArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AIUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindFirstOrThrowArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AIUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AIUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIUsageLogs
     * const aIUsageLogs = await prisma.aIUsageLog.findMany()
     * 
     * // Get first 10 AIUsageLogs
     * const aIUsageLogs = await prisma.aIUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIUsageLogWithIdOnly = await prisma.aIUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIUsageLogFindManyArgs>(args?: SelectSubset<T, AIUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AIUsageLog.
     * @param {AIUsageLogCreateArgs} args - Arguments to create a AIUsageLog.
     * @example
     * // Create one AIUsageLog
     * const AIUsageLog = await prisma.aIUsageLog.create({
     *   data: {
     *     // ... data to create a AIUsageLog
     *   }
     * })
     * 
     */
    create<T extends AIUsageLogCreateArgs>(args: SelectSubset<T, AIUsageLogCreateArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AIUsageLogs.
     * @param {AIUsageLogCreateManyArgs} args - Arguments to create many AIUsageLogs.
     * @example
     * // Create many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIUsageLogCreateManyArgs>(args?: SelectSubset<T, AIUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIUsageLogs and returns the data saved in the database.
     * @param {AIUsageLogCreateManyAndReturnArgs} args - Arguments to create many AIUsageLogs.
     * @example
     * // Create many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIUsageLogs and only return the `id`
     * const aIUsageLogWithIdOnly = await prisma.aIUsageLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AIUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AIUsageLog.
     * @param {AIUsageLogDeleteArgs} args - Arguments to delete one AIUsageLog.
     * @example
     * // Delete one AIUsageLog
     * const AIUsageLog = await prisma.aIUsageLog.delete({
     *   where: {
     *     // ... filter to delete one AIUsageLog
     *   }
     * })
     * 
     */
    delete<T extends AIUsageLogDeleteArgs>(args: SelectSubset<T, AIUsageLogDeleteArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AIUsageLog.
     * @param {AIUsageLogUpdateArgs} args - Arguments to update one AIUsageLog.
     * @example
     * // Update one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIUsageLogUpdateArgs>(args: SelectSubset<T, AIUsageLogUpdateArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AIUsageLogs.
     * @param {AIUsageLogDeleteManyArgs} args - Arguments to filter AIUsageLogs to delete.
     * @example
     * // Delete a few AIUsageLogs
     * const { count } = await prisma.aIUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIUsageLogDeleteManyArgs>(args?: SelectSubset<T, AIUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIUsageLogUpdateManyArgs>(args: SelectSubset<T, AIUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIUsageLog.
     * @param {AIUsageLogUpsertArgs} args - Arguments to update or create a AIUsageLog.
     * @example
     * // Update or create a AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.upsert({
     *   create: {
     *     // ... data to create a AIUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends AIUsageLogUpsertArgs>(args: SelectSubset<T, AIUsageLogUpsertArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AIUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogCountArgs} args - Arguments to filter AIUsageLogs to count.
     * @example
     * // Count the number of AIUsageLogs
     * const count = await prisma.aIUsageLog.count({
     *   where: {
     *     // ... the filter for the AIUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends AIUsageLogCountArgs>(
      args?: Subset<T, AIUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIUsageLogAggregateArgs>(args: Subset<T, AIUsageLogAggregateArgs>): Prisma.PrismaPromise<GetAIUsageLogAggregateType<T>>

    /**
     * Group by AIUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: AIUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIUsageLog model
   */
  readonly fields: AIUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIUsageLog model
   */ 
  interface AIUsageLogFieldRefs {
    readonly id: FieldRef<"AIUsageLog", 'String'>
    readonly provider: FieldRef<"AIUsageLog", 'String'>
    readonly model: FieldRef<"AIUsageLog", 'String'>
    readonly purpose: FieldRef<"AIUsageLog", 'String'>
    readonly userId: FieldRef<"AIUsageLog", 'String'>
    readonly promptTokens: FieldRef<"AIUsageLog", 'Int'>
    readonly completionTokens: FieldRef<"AIUsageLog", 'Int'>
    readonly totalTokens: FieldRef<"AIUsageLog", 'Int'>
    readonly cost: FieldRef<"AIUsageLog", 'Float'>
    readonly cached: FieldRef<"AIUsageLog", 'Boolean'>
    readonly timestamp: FieldRef<"AIUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIUsageLog findUnique
   */
  export type AIUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog findUniqueOrThrow
   */
  export type AIUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog findFirst
   */
  export type AIUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageLogs.
     */
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog findFirstOrThrow
   */
  export type AIUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageLogs.
     */
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog findMany
   */
  export type AIUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Filter, which AIUsageLogs to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog create
   */
  export type AIUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AIUsageLog.
     */
    data: XOR<AIUsageLogCreateInput, AIUsageLogUncheckedCreateInput>
  }

  /**
   * AIUsageLog createMany
   */
  export type AIUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIUsageLogs.
     */
    data: AIUsageLogCreateManyInput | AIUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIUsageLog createManyAndReturn
   */
  export type AIUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AIUsageLogs.
     */
    data: AIUsageLogCreateManyInput | AIUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIUsageLog update
   */
  export type AIUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AIUsageLog.
     */
    data: XOR<AIUsageLogUpdateInput, AIUsageLogUncheckedUpdateInput>
    /**
     * Choose, which AIUsageLog to update.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog updateMany
   */
  export type AIUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIUsageLogs.
     */
    data: XOR<AIUsageLogUpdateManyMutationInput, AIUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which AIUsageLogs to update
     */
    where?: AIUsageLogWhereInput
  }

  /**
   * AIUsageLog upsert
   */
  export type AIUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AIUsageLog to update in case it exists.
     */
    where: AIUsageLogWhereUniqueInput
    /**
     * In case the AIUsageLog found by the `where` argument doesn't exist, create a new AIUsageLog with this data.
     */
    create: XOR<AIUsageLogCreateInput, AIUsageLogUncheckedCreateInput>
    /**
     * In case the AIUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIUsageLogUpdateInput, AIUsageLogUncheckedUpdateInput>
  }

  /**
   * AIUsageLog delete
   */
  export type AIUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Filter which AIUsageLog to delete.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog deleteMany
   */
  export type AIUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageLogs to delete
     */
    where?: AIUsageLogWhereInput
  }

  /**
   * AIUsageLog without action
   */
  export type AIUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
  }


  /**
   * Model CostReservation
   */

  export type AggregateCostReservation = {
    _count: CostReservationCountAggregateOutputType | null
    _avg: CostReservationAvgAggregateOutputType | null
    _sum: CostReservationSumAggregateOutputType | null
    _min: CostReservationMinAggregateOutputType | null
    _max: CostReservationMaxAggregateOutputType | null
  }

  export type CostReservationAvgAggregateOutputType = {
    units: number | null
    unitPrice: number | null
    savings: number | null
  }

  export type CostReservationSumAggregateOutputType = {
    units: number | null
    unitPrice: number | null
    savings: number | null
  }

  export type CostReservationMinAggregateOutputType = {
    id: string | null
    provider: string | null
    service: string | null
    commitment: string | null
    units: number | null
    unitPrice: number | null
    savings: number | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostReservationMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    service: string | null
    commitment: string | null
    units: number | null
    unitPrice: number | null
    savings: number | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostReservationCountAggregateOutputType = {
    id: number
    provider: number
    service: number
    commitment: number
    units: number
    unitPrice: number
    savings: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostReservationAvgAggregateInputType = {
    units?: true
    unitPrice?: true
    savings?: true
  }

  export type CostReservationSumAggregateInputType = {
    units?: true
    unitPrice?: true
    savings?: true
  }

  export type CostReservationMinAggregateInputType = {
    id?: true
    provider?: true
    service?: true
    commitment?: true
    units?: true
    unitPrice?: true
    savings?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostReservationMaxAggregateInputType = {
    id?: true
    provider?: true
    service?: true
    commitment?: true
    units?: true
    unitPrice?: true
    savings?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostReservationCountAggregateInputType = {
    id?: true
    provider?: true
    service?: true
    commitment?: true
    units?: true
    unitPrice?: true
    savings?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostReservation to aggregate.
     */
    where?: CostReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostReservations to fetch.
     */
    orderBy?: CostReservationOrderByWithRelationInput | CostReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostReservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostReservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostReservations
    **/
    _count?: true | CostReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostReservationMaxAggregateInputType
  }

  export type GetCostReservationAggregateType<T extends CostReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateCostReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostReservation[P]>
      : GetScalarType<T[P], AggregateCostReservation[P]>
  }




  export type CostReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostReservationWhereInput
    orderBy?: CostReservationOrderByWithAggregationInput | CostReservationOrderByWithAggregationInput[]
    by: CostReservationScalarFieldEnum[] | CostReservationScalarFieldEnum
    having?: CostReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostReservationCountAggregateInputType | true
    _avg?: CostReservationAvgAggregateInputType
    _sum?: CostReservationSumAggregateInputType
    _min?: CostReservationMinAggregateInputType
    _max?: CostReservationMaxAggregateInputType
  }

  export type CostReservationGroupByOutputType = {
    id: string
    provider: string
    service: string
    commitment: string
    units: number
    unitPrice: number
    savings: number
    startDate: Date
    endDate: Date
    status: string
    createdAt: Date
    updatedAt: Date
    _count: CostReservationCountAggregateOutputType | null
    _avg: CostReservationAvgAggregateOutputType | null
    _sum: CostReservationSumAggregateOutputType | null
    _min: CostReservationMinAggregateOutputType | null
    _max: CostReservationMaxAggregateOutputType | null
  }

  type GetCostReservationGroupByPayload<T extends CostReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostReservationGroupByOutputType[P]>
            : GetScalarType<T[P], CostReservationGroupByOutputType[P]>
        }
      >
    >


  export type CostReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    service?: boolean
    commitment?: boolean
    units?: boolean
    unitPrice?: boolean
    savings?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["costReservation"]>

  export type CostReservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    service?: boolean
    commitment?: boolean
    units?: boolean
    unitPrice?: boolean
    savings?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["costReservation"]>

  export type CostReservationSelectScalar = {
    id?: boolean
    provider?: boolean
    service?: boolean
    commitment?: boolean
    units?: boolean
    unitPrice?: boolean
    savings?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CostReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostReservation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      service: string
      commitment: string
      units: number
      unitPrice: number
      savings: number
      startDate: Date
      endDate: Date
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["costReservation"]>
    composites: {}
  }

  type CostReservationGetPayload<S extends boolean | null | undefined | CostReservationDefaultArgs> = $Result.GetResult<Prisma.$CostReservationPayload, S>

  type CostReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CostReservationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CostReservationCountAggregateInputType | true
    }

  export interface CostReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostReservation'], meta: { name: 'CostReservation' } }
    /**
     * Find zero or one CostReservation that matches the filter.
     * @param {CostReservationFindUniqueArgs} args - Arguments to find a CostReservation
     * @example
     * // Get one CostReservation
     * const costReservation = await prisma.costReservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostReservationFindUniqueArgs>(args: SelectSubset<T, CostReservationFindUniqueArgs<ExtArgs>>): Prisma__CostReservationClient<$Result.GetResult<Prisma.$CostReservationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CostReservation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CostReservationFindUniqueOrThrowArgs} args - Arguments to find a CostReservation
     * @example
     * // Get one CostReservation
     * const costReservation = await prisma.costReservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, CostReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostReservationClient<$Result.GetResult<Prisma.$CostReservationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CostReservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostReservationFindFirstArgs} args - Arguments to find a CostReservation
     * @example
     * // Get one CostReservation
     * const costReservation = await prisma.costReservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostReservationFindFirstArgs>(args?: SelectSubset<T, CostReservationFindFirstArgs<ExtArgs>>): Prisma__CostReservationClient<$Result.GetResult<Prisma.$CostReservationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CostReservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostReservationFindFirstOrThrowArgs} args - Arguments to find a CostReservation
     * @example
     * // Get one CostReservation
     * const costReservation = await prisma.costReservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, CostReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostReservationClient<$Result.GetResult<Prisma.$CostReservationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CostReservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostReservations
     * const costReservations = await prisma.costReservation.findMany()
     * 
     * // Get first 10 CostReservations
     * const costReservations = await prisma.costReservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costReservationWithIdOnly = await prisma.costReservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostReservationFindManyArgs>(args?: SelectSubset<T, CostReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostReservationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CostReservation.
     * @param {CostReservationCreateArgs} args - Arguments to create a CostReservation.
     * @example
     * // Create one CostReservation
     * const CostReservation = await prisma.costReservation.create({
     *   data: {
     *     // ... data to create a CostReservation
     *   }
     * })
     * 
     */
    create<T extends CostReservationCreateArgs>(args: SelectSubset<T, CostReservationCreateArgs<ExtArgs>>): Prisma__CostReservationClient<$Result.GetResult<Prisma.$CostReservationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CostReservations.
     * @param {CostReservationCreateManyArgs} args - Arguments to create many CostReservations.
     * @example
     * // Create many CostReservations
     * const costReservation = await prisma.costReservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostReservationCreateManyArgs>(args?: SelectSubset<T, CostReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostReservations and returns the data saved in the database.
     * @param {CostReservationCreateManyAndReturnArgs} args - Arguments to create many CostReservations.
     * @example
     * // Create many CostReservations
     * const costReservation = await prisma.costReservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostReservations and only return the `id`
     * const costReservationWithIdOnly = await prisma.costReservation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostReservationCreateManyAndReturnArgs>(args?: SelectSubset<T, CostReservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostReservationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CostReservation.
     * @param {CostReservationDeleteArgs} args - Arguments to delete one CostReservation.
     * @example
     * // Delete one CostReservation
     * const CostReservation = await prisma.costReservation.delete({
     *   where: {
     *     // ... filter to delete one CostReservation
     *   }
     * })
     * 
     */
    delete<T extends CostReservationDeleteArgs>(args: SelectSubset<T, CostReservationDeleteArgs<ExtArgs>>): Prisma__CostReservationClient<$Result.GetResult<Prisma.$CostReservationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CostReservation.
     * @param {CostReservationUpdateArgs} args - Arguments to update one CostReservation.
     * @example
     * // Update one CostReservation
     * const costReservation = await prisma.costReservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostReservationUpdateArgs>(args: SelectSubset<T, CostReservationUpdateArgs<ExtArgs>>): Prisma__CostReservationClient<$Result.GetResult<Prisma.$CostReservationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CostReservations.
     * @param {CostReservationDeleteManyArgs} args - Arguments to filter CostReservations to delete.
     * @example
     * // Delete a few CostReservations
     * const { count } = await prisma.costReservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostReservationDeleteManyArgs>(args?: SelectSubset<T, CostReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostReservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostReservations
     * const costReservation = await prisma.costReservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostReservationUpdateManyArgs>(args: SelectSubset<T, CostReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CostReservation.
     * @param {CostReservationUpsertArgs} args - Arguments to update or create a CostReservation.
     * @example
     * // Update or create a CostReservation
     * const costReservation = await prisma.costReservation.upsert({
     *   create: {
     *     // ... data to create a CostReservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostReservation we want to update
     *   }
     * })
     */
    upsert<T extends CostReservationUpsertArgs>(args: SelectSubset<T, CostReservationUpsertArgs<ExtArgs>>): Prisma__CostReservationClient<$Result.GetResult<Prisma.$CostReservationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CostReservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostReservationCountArgs} args - Arguments to filter CostReservations to count.
     * @example
     * // Count the number of CostReservations
     * const count = await prisma.costReservation.count({
     *   where: {
     *     // ... the filter for the CostReservations we want to count
     *   }
     * })
    **/
    count<T extends CostReservationCountArgs>(
      args?: Subset<T, CostReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostReservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostReservationAggregateArgs>(args: Subset<T, CostReservationAggregateArgs>): Prisma.PrismaPromise<GetCostReservationAggregateType<T>>

    /**
     * Group by CostReservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostReservationGroupByArgs['orderBy'] }
        : { orderBy?: CostReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostReservation model
   */
  readonly fields: CostReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostReservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostReservation model
   */ 
  interface CostReservationFieldRefs {
    readonly id: FieldRef<"CostReservation", 'String'>
    readonly provider: FieldRef<"CostReservation", 'String'>
    readonly service: FieldRef<"CostReservation", 'String'>
    readonly commitment: FieldRef<"CostReservation", 'String'>
    readonly units: FieldRef<"CostReservation", 'Float'>
    readonly unitPrice: FieldRef<"CostReservation", 'Float'>
    readonly savings: FieldRef<"CostReservation", 'Float'>
    readonly startDate: FieldRef<"CostReservation", 'DateTime'>
    readonly endDate: FieldRef<"CostReservation", 'DateTime'>
    readonly status: FieldRef<"CostReservation", 'String'>
    readonly createdAt: FieldRef<"CostReservation", 'DateTime'>
    readonly updatedAt: FieldRef<"CostReservation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostReservation findUnique
   */
  export type CostReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostReservation
     */
    select?: CostReservationSelect<ExtArgs> | null
    /**
     * Filter, which CostReservation to fetch.
     */
    where: CostReservationWhereUniqueInput
  }

  /**
   * CostReservation findUniqueOrThrow
   */
  export type CostReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostReservation
     */
    select?: CostReservationSelect<ExtArgs> | null
    /**
     * Filter, which CostReservation to fetch.
     */
    where: CostReservationWhereUniqueInput
  }

  /**
   * CostReservation findFirst
   */
  export type CostReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostReservation
     */
    select?: CostReservationSelect<ExtArgs> | null
    /**
     * Filter, which CostReservation to fetch.
     */
    where?: CostReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostReservations to fetch.
     */
    orderBy?: CostReservationOrderByWithRelationInput | CostReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostReservations.
     */
    cursor?: CostReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostReservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostReservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostReservations.
     */
    distinct?: CostReservationScalarFieldEnum | CostReservationScalarFieldEnum[]
  }

  /**
   * CostReservation findFirstOrThrow
   */
  export type CostReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostReservation
     */
    select?: CostReservationSelect<ExtArgs> | null
    /**
     * Filter, which CostReservation to fetch.
     */
    where?: CostReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostReservations to fetch.
     */
    orderBy?: CostReservationOrderByWithRelationInput | CostReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostReservations.
     */
    cursor?: CostReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostReservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostReservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostReservations.
     */
    distinct?: CostReservationScalarFieldEnum | CostReservationScalarFieldEnum[]
  }

  /**
   * CostReservation findMany
   */
  export type CostReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostReservation
     */
    select?: CostReservationSelect<ExtArgs> | null
    /**
     * Filter, which CostReservations to fetch.
     */
    where?: CostReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostReservations to fetch.
     */
    orderBy?: CostReservationOrderByWithRelationInput | CostReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostReservations.
     */
    cursor?: CostReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostReservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostReservations.
     */
    skip?: number
    distinct?: CostReservationScalarFieldEnum | CostReservationScalarFieldEnum[]
  }

  /**
   * CostReservation create
   */
  export type CostReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostReservation
     */
    select?: CostReservationSelect<ExtArgs> | null
    /**
     * The data needed to create a CostReservation.
     */
    data: XOR<CostReservationCreateInput, CostReservationUncheckedCreateInput>
  }

  /**
   * CostReservation createMany
   */
  export type CostReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostReservations.
     */
    data: CostReservationCreateManyInput | CostReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostReservation createManyAndReturn
   */
  export type CostReservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostReservation
     */
    select?: CostReservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CostReservations.
     */
    data: CostReservationCreateManyInput | CostReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostReservation update
   */
  export type CostReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostReservation
     */
    select?: CostReservationSelect<ExtArgs> | null
    /**
     * The data needed to update a CostReservation.
     */
    data: XOR<CostReservationUpdateInput, CostReservationUncheckedUpdateInput>
    /**
     * Choose, which CostReservation to update.
     */
    where: CostReservationWhereUniqueInput
  }

  /**
   * CostReservation updateMany
   */
  export type CostReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostReservations.
     */
    data: XOR<CostReservationUpdateManyMutationInput, CostReservationUncheckedUpdateManyInput>
    /**
     * Filter which CostReservations to update
     */
    where?: CostReservationWhereInput
  }

  /**
   * CostReservation upsert
   */
  export type CostReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostReservation
     */
    select?: CostReservationSelect<ExtArgs> | null
    /**
     * The filter to search for the CostReservation to update in case it exists.
     */
    where: CostReservationWhereUniqueInput
    /**
     * In case the CostReservation found by the `where` argument doesn't exist, create a new CostReservation with this data.
     */
    create: XOR<CostReservationCreateInput, CostReservationUncheckedCreateInput>
    /**
     * In case the CostReservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostReservationUpdateInput, CostReservationUncheckedUpdateInput>
  }

  /**
   * CostReservation delete
   */
  export type CostReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostReservation
     */
    select?: CostReservationSelect<ExtArgs> | null
    /**
     * Filter which CostReservation to delete.
     */
    where: CostReservationWhereUniqueInput
  }

  /**
   * CostReservation deleteMany
   */
  export type CostReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostReservations to delete
     */
    where?: CostReservationWhereInput
  }

  /**
   * CostReservation without action
   */
  export type CostReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostReservation
     */
    select?: CostReservationSelect<ExtArgs> | null
  }


  /**
   * Model PromptOptimization
   */

  export type AggregatePromptOptimization = {
    _count: PromptOptimizationCountAggregateOutputType | null
    _avg: PromptOptimizationAvgAggregateOutputType | null
    _sum: PromptOptimizationSumAggregateOutputType | null
    _min: PromptOptimizationMinAggregateOutputType | null
    _max: PromptOptimizationMaxAggregateOutputType | null
  }

  export type PromptOptimizationAvgAggregateOutputType = {
    originalTokens: number | null
    optimizedTokens: number | null
    tokenReduction: number | null
    qualityScore: number | null
  }

  export type PromptOptimizationSumAggregateOutputType = {
    originalTokens: number | null
    optimizedTokens: number | null
    tokenReduction: number | null
    qualityScore: number | null
  }

  export type PromptOptimizationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    originalPrompt: string | null
    optimizedPrompt: string | null
    originalTokens: number | null
    optimizedTokens: number | null
    tokenReduction: number | null
    qualityScore: number | null
    timestamp: Date | null
  }

  export type PromptOptimizationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    originalPrompt: string | null
    optimizedPrompt: string | null
    originalTokens: number | null
    optimizedTokens: number | null
    tokenReduction: number | null
    qualityScore: number | null
    timestamp: Date | null
  }

  export type PromptOptimizationCountAggregateOutputType = {
    id: number
    userId: number
    originalPrompt: number
    optimizedPrompt: number
    originalTokens: number
    optimizedTokens: number
    tokenReduction: number
    qualityScore: number
    abTestResults: number
    timestamp: number
    _all: number
  }


  export type PromptOptimizationAvgAggregateInputType = {
    originalTokens?: true
    optimizedTokens?: true
    tokenReduction?: true
    qualityScore?: true
  }

  export type PromptOptimizationSumAggregateInputType = {
    originalTokens?: true
    optimizedTokens?: true
    tokenReduction?: true
    qualityScore?: true
  }

  export type PromptOptimizationMinAggregateInputType = {
    id?: true
    userId?: true
    originalPrompt?: true
    optimizedPrompt?: true
    originalTokens?: true
    optimizedTokens?: true
    tokenReduction?: true
    qualityScore?: true
    timestamp?: true
  }

  export type PromptOptimizationMaxAggregateInputType = {
    id?: true
    userId?: true
    originalPrompt?: true
    optimizedPrompt?: true
    originalTokens?: true
    optimizedTokens?: true
    tokenReduction?: true
    qualityScore?: true
    timestamp?: true
  }

  export type PromptOptimizationCountAggregateInputType = {
    id?: true
    userId?: true
    originalPrompt?: true
    optimizedPrompt?: true
    originalTokens?: true
    optimizedTokens?: true
    tokenReduction?: true
    qualityScore?: true
    abTestResults?: true
    timestamp?: true
    _all?: true
  }

  export type PromptOptimizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptOptimization to aggregate.
     */
    where?: PromptOptimizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptOptimizations to fetch.
     */
    orderBy?: PromptOptimizationOrderByWithRelationInput | PromptOptimizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptOptimizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptOptimizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptOptimizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromptOptimizations
    **/
    _count?: true | PromptOptimizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromptOptimizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromptOptimizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptOptimizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptOptimizationMaxAggregateInputType
  }

  export type GetPromptOptimizationAggregateType<T extends PromptOptimizationAggregateArgs> = {
        [P in keyof T & keyof AggregatePromptOptimization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromptOptimization[P]>
      : GetScalarType<T[P], AggregatePromptOptimization[P]>
  }




  export type PromptOptimizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptOptimizationWhereInput
    orderBy?: PromptOptimizationOrderByWithAggregationInput | PromptOptimizationOrderByWithAggregationInput[]
    by: PromptOptimizationScalarFieldEnum[] | PromptOptimizationScalarFieldEnum
    having?: PromptOptimizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptOptimizationCountAggregateInputType | true
    _avg?: PromptOptimizationAvgAggregateInputType
    _sum?: PromptOptimizationSumAggregateInputType
    _min?: PromptOptimizationMinAggregateInputType
    _max?: PromptOptimizationMaxAggregateInputType
  }

  export type PromptOptimizationGroupByOutputType = {
    id: string
    userId: string
    originalPrompt: string
    optimizedPrompt: string
    originalTokens: number
    optimizedTokens: number
    tokenReduction: number
    qualityScore: number | null
    abTestResults: JsonValue | null
    timestamp: Date
    _count: PromptOptimizationCountAggregateOutputType | null
    _avg: PromptOptimizationAvgAggregateOutputType | null
    _sum: PromptOptimizationSumAggregateOutputType | null
    _min: PromptOptimizationMinAggregateOutputType | null
    _max: PromptOptimizationMaxAggregateOutputType | null
  }

  type GetPromptOptimizationGroupByPayload<T extends PromptOptimizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptOptimizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptOptimizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptOptimizationGroupByOutputType[P]>
            : GetScalarType<T[P], PromptOptimizationGroupByOutputType[P]>
        }
      >
    >


  export type PromptOptimizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    originalPrompt?: boolean
    optimizedPrompt?: boolean
    originalTokens?: boolean
    optimizedTokens?: boolean
    tokenReduction?: boolean
    qualityScore?: boolean
    abTestResults?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["promptOptimization"]>

  export type PromptOptimizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    originalPrompt?: boolean
    optimizedPrompt?: boolean
    originalTokens?: boolean
    optimizedTokens?: boolean
    tokenReduction?: boolean
    qualityScore?: boolean
    abTestResults?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["promptOptimization"]>

  export type PromptOptimizationSelectScalar = {
    id?: boolean
    userId?: boolean
    originalPrompt?: boolean
    optimizedPrompt?: boolean
    originalTokens?: boolean
    optimizedTokens?: boolean
    tokenReduction?: boolean
    qualityScore?: boolean
    abTestResults?: boolean
    timestamp?: boolean
  }


  export type $PromptOptimizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromptOptimization"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      originalPrompt: string
      optimizedPrompt: string
      originalTokens: number
      optimizedTokens: number
      tokenReduction: number
      qualityScore: number | null
      abTestResults: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["promptOptimization"]>
    composites: {}
  }

  type PromptOptimizationGetPayload<S extends boolean | null | undefined | PromptOptimizationDefaultArgs> = $Result.GetResult<Prisma.$PromptOptimizationPayload, S>

  type PromptOptimizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromptOptimizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromptOptimizationCountAggregateInputType | true
    }

  export interface PromptOptimizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromptOptimization'], meta: { name: 'PromptOptimization' } }
    /**
     * Find zero or one PromptOptimization that matches the filter.
     * @param {PromptOptimizationFindUniqueArgs} args - Arguments to find a PromptOptimization
     * @example
     * // Get one PromptOptimization
     * const promptOptimization = await prisma.promptOptimization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromptOptimizationFindUniqueArgs>(args: SelectSubset<T, PromptOptimizationFindUniqueArgs<ExtArgs>>): Prisma__PromptOptimizationClient<$Result.GetResult<Prisma.$PromptOptimizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PromptOptimization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromptOptimizationFindUniqueOrThrowArgs} args - Arguments to find a PromptOptimization
     * @example
     * // Get one PromptOptimization
     * const promptOptimization = await prisma.promptOptimization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromptOptimizationFindUniqueOrThrowArgs>(args: SelectSubset<T, PromptOptimizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromptOptimizationClient<$Result.GetResult<Prisma.$PromptOptimizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PromptOptimization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptOptimizationFindFirstArgs} args - Arguments to find a PromptOptimization
     * @example
     * // Get one PromptOptimization
     * const promptOptimization = await prisma.promptOptimization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromptOptimizationFindFirstArgs>(args?: SelectSubset<T, PromptOptimizationFindFirstArgs<ExtArgs>>): Prisma__PromptOptimizationClient<$Result.GetResult<Prisma.$PromptOptimizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PromptOptimization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptOptimizationFindFirstOrThrowArgs} args - Arguments to find a PromptOptimization
     * @example
     * // Get one PromptOptimization
     * const promptOptimization = await prisma.promptOptimization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromptOptimizationFindFirstOrThrowArgs>(args?: SelectSubset<T, PromptOptimizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromptOptimizationClient<$Result.GetResult<Prisma.$PromptOptimizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PromptOptimizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptOptimizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromptOptimizations
     * const promptOptimizations = await prisma.promptOptimization.findMany()
     * 
     * // Get first 10 PromptOptimizations
     * const promptOptimizations = await prisma.promptOptimization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptOptimizationWithIdOnly = await prisma.promptOptimization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromptOptimizationFindManyArgs>(args?: SelectSubset<T, PromptOptimizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptOptimizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PromptOptimization.
     * @param {PromptOptimizationCreateArgs} args - Arguments to create a PromptOptimization.
     * @example
     * // Create one PromptOptimization
     * const PromptOptimization = await prisma.promptOptimization.create({
     *   data: {
     *     // ... data to create a PromptOptimization
     *   }
     * })
     * 
     */
    create<T extends PromptOptimizationCreateArgs>(args: SelectSubset<T, PromptOptimizationCreateArgs<ExtArgs>>): Prisma__PromptOptimizationClient<$Result.GetResult<Prisma.$PromptOptimizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PromptOptimizations.
     * @param {PromptOptimizationCreateManyArgs} args - Arguments to create many PromptOptimizations.
     * @example
     * // Create many PromptOptimizations
     * const promptOptimization = await prisma.promptOptimization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromptOptimizationCreateManyArgs>(args?: SelectSubset<T, PromptOptimizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromptOptimizations and returns the data saved in the database.
     * @param {PromptOptimizationCreateManyAndReturnArgs} args - Arguments to create many PromptOptimizations.
     * @example
     * // Create many PromptOptimizations
     * const promptOptimization = await prisma.promptOptimization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromptOptimizations and only return the `id`
     * const promptOptimizationWithIdOnly = await prisma.promptOptimization.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromptOptimizationCreateManyAndReturnArgs>(args?: SelectSubset<T, PromptOptimizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptOptimizationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PromptOptimization.
     * @param {PromptOptimizationDeleteArgs} args - Arguments to delete one PromptOptimization.
     * @example
     * // Delete one PromptOptimization
     * const PromptOptimization = await prisma.promptOptimization.delete({
     *   where: {
     *     // ... filter to delete one PromptOptimization
     *   }
     * })
     * 
     */
    delete<T extends PromptOptimizationDeleteArgs>(args: SelectSubset<T, PromptOptimizationDeleteArgs<ExtArgs>>): Prisma__PromptOptimizationClient<$Result.GetResult<Prisma.$PromptOptimizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PromptOptimization.
     * @param {PromptOptimizationUpdateArgs} args - Arguments to update one PromptOptimization.
     * @example
     * // Update one PromptOptimization
     * const promptOptimization = await prisma.promptOptimization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromptOptimizationUpdateArgs>(args: SelectSubset<T, PromptOptimizationUpdateArgs<ExtArgs>>): Prisma__PromptOptimizationClient<$Result.GetResult<Prisma.$PromptOptimizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PromptOptimizations.
     * @param {PromptOptimizationDeleteManyArgs} args - Arguments to filter PromptOptimizations to delete.
     * @example
     * // Delete a few PromptOptimizations
     * const { count } = await prisma.promptOptimization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromptOptimizationDeleteManyArgs>(args?: SelectSubset<T, PromptOptimizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromptOptimizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptOptimizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromptOptimizations
     * const promptOptimization = await prisma.promptOptimization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromptOptimizationUpdateManyArgs>(args: SelectSubset<T, PromptOptimizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromptOptimization.
     * @param {PromptOptimizationUpsertArgs} args - Arguments to update or create a PromptOptimization.
     * @example
     * // Update or create a PromptOptimization
     * const promptOptimization = await prisma.promptOptimization.upsert({
     *   create: {
     *     // ... data to create a PromptOptimization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromptOptimization we want to update
     *   }
     * })
     */
    upsert<T extends PromptOptimizationUpsertArgs>(args: SelectSubset<T, PromptOptimizationUpsertArgs<ExtArgs>>): Prisma__PromptOptimizationClient<$Result.GetResult<Prisma.$PromptOptimizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PromptOptimizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptOptimizationCountArgs} args - Arguments to filter PromptOptimizations to count.
     * @example
     * // Count the number of PromptOptimizations
     * const count = await prisma.promptOptimization.count({
     *   where: {
     *     // ... the filter for the PromptOptimizations we want to count
     *   }
     * })
    **/
    count<T extends PromptOptimizationCountArgs>(
      args?: Subset<T, PromptOptimizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptOptimizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromptOptimization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptOptimizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptOptimizationAggregateArgs>(args: Subset<T, PromptOptimizationAggregateArgs>): Prisma.PrismaPromise<GetPromptOptimizationAggregateType<T>>

    /**
     * Group by PromptOptimization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptOptimizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptOptimizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptOptimizationGroupByArgs['orderBy'] }
        : { orderBy?: PromptOptimizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptOptimizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptOptimizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromptOptimization model
   */
  readonly fields: PromptOptimizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromptOptimization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromptOptimizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromptOptimization model
   */ 
  interface PromptOptimizationFieldRefs {
    readonly id: FieldRef<"PromptOptimization", 'String'>
    readonly userId: FieldRef<"PromptOptimization", 'String'>
    readonly originalPrompt: FieldRef<"PromptOptimization", 'String'>
    readonly optimizedPrompt: FieldRef<"PromptOptimization", 'String'>
    readonly originalTokens: FieldRef<"PromptOptimization", 'Int'>
    readonly optimizedTokens: FieldRef<"PromptOptimization", 'Int'>
    readonly tokenReduction: FieldRef<"PromptOptimization", 'Float'>
    readonly qualityScore: FieldRef<"PromptOptimization", 'Float'>
    readonly abTestResults: FieldRef<"PromptOptimization", 'Json'>
    readonly timestamp: FieldRef<"PromptOptimization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromptOptimization findUnique
   */
  export type PromptOptimizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptOptimization
     */
    select?: PromptOptimizationSelect<ExtArgs> | null
    /**
     * Filter, which PromptOptimization to fetch.
     */
    where: PromptOptimizationWhereUniqueInput
  }

  /**
   * PromptOptimization findUniqueOrThrow
   */
  export type PromptOptimizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptOptimization
     */
    select?: PromptOptimizationSelect<ExtArgs> | null
    /**
     * Filter, which PromptOptimization to fetch.
     */
    where: PromptOptimizationWhereUniqueInput
  }

  /**
   * PromptOptimization findFirst
   */
  export type PromptOptimizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptOptimization
     */
    select?: PromptOptimizationSelect<ExtArgs> | null
    /**
     * Filter, which PromptOptimization to fetch.
     */
    where?: PromptOptimizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptOptimizations to fetch.
     */
    orderBy?: PromptOptimizationOrderByWithRelationInput | PromptOptimizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptOptimizations.
     */
    cursor?: PromptOptimizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptOptimizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptOptimizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptOptimizations.
     */
    distinct?: PromptOptimizationScalarFieldEnum | PromptOptimizationScalarFieldEnum[]
  }

  /**
   * PromptOptimization findFirstOrThrow
   */
  export type PromptOptimizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptOptimization
     */
    select?: PromptOptimizationSelect<ExtArgs> | null
    /**
     * Filter, which PromptOptimization to fetch.
     */
    where?: PromptOptimizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptOptimizations to fetch.
     */
    orderBy?: PromptOptimizationOrderByWithRelationInput | PromptOptimizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptOptimizations.
     */
    cursor?: PromptOptimizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptOptimizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptOptimizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptOptimizations.
     */
    distinct?: PromptOptimizationScalarFieldEnum | PromptOptimizationScalarFieldEnum[]
  }

  /**
   * PromptOptimization findMany
   */
  export type PromptOptimizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptOptimization
     */
    select?: PromptOptimizationSelect<ExtArgs> | null
    /**
     * Filter, which PromptOptimizations to fetch.
     */
    where?: PromptOptimizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptOptimizations to fetch.
     */
    orderBy?: PromptOptimizationOrderByWithRelationInput | PromptOptimizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromptOptimizations.
     */
    cursor?: PromptOptimizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptOptimizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptOptimizations.
     */
    skip?: number
    distinct?: PromptOptimizationScalarFieldEnum | PromptOptimizationScalarFieldEnum[]
  }

  /**
   * PromptOptimization create
   */
  export type PromptOptimizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptOptimization
     */
    select?: PromptOptimizationSelect<ExtArgs> | null
    /**
     * The data needed to create a PromptOptimization.
     */
    data: XOR<PromptOptimizationCreateInput, PromptOptimizationUncheckedCreateInput>
  }

  /**
   * PromptOptimization createMany
   */
  export type PromptOptimizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromptOptimizations.
     */
    data: PromptOptimizationCreateManyInput | PromptOptimizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromptOptimization createManyAndReturn
   */
  export type PromptOptimizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptOptimization
     */
    select?: PromptOptimizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PromptOptimizations.
     */
    data: PromptOptimizationCreateManyInput | PromptOptimizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromptOptimization update
   */
  export type PromptOptimizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptOptimization
     */
    select?: PromptOptimizationSelect<ExtArgs> | null
    /**
     * The data needed to update a PromptOptimization.
     */
    data: XOR<PromptOptimizationUpdateInput, PromptOptimizationUncheckedUpdateInput>
    /**
     * Choose, which PromptOptimization to update.
     */
    where: PromptOptimizationWhereUniqueInput
  }

  /**
   * PromptOptimization updateMany
   */
  export type PromptOptimizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromptOptimizations.
     */
    data: XOR<PromptOptimizationUpdateManyMutationInput, PromptOptimizationUncheckedUpdateManyInput>
    /**
     * Filter which PromptOptimizations to update
     */
    where?: PromptOptimizationWhereInput
  }

  /**
   * PromptOptimization upsert
   */
  export type PromptOptimizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptOptimization
     */
    select?: PromptOptimizationSelect<ExtArgs> | null
    /**
     * The filter to search for the PromptOptimization to update in case it exists.
     */
    where: PromptOptimizationWhereUniqueInput
    /**
     * In case the PromptOptimization found by the `where` argument doesn't exist, create a new PromptOptimization with this data.
     */
    create: XOR<PromptOptimizationCreateInput, PromptOptimizationUncheckedCreateInput>
    /**
     * In case the PromptOptimization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptOptimizationUpdateInput, PromptOptimizationUncheckedUpdateInput>
  }

  /**
   * PromptOptimization delete
   */
  export type PromptOptimizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptOptimization
     */
    select?: PromptOptimizationSelect<ExtArgs> | null
    /**
     * Filter which PromptOptimization to delete.
     */
    where: PromptOptimizationWhereUniqueInput
  }

  /**
   * PromptOptimization deleteMany
   */
  export type PromptOptimizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptOptimizations to delete
     */
    where?: PromptOptimizationWhereInput
  }

  /**
   * PromptOptimization without action
   */
  export type PromptOptimizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptOptimization
     */
    select?: PromptOptimizationSelect<ExtArgs> | null
  }


  /**
   * Model CostAlert
   */

  export type AggregateCostAlert = {
    _count: CostAlertCountAggregateOutputType | null
    _avg: CostAlertAvgAggregateOutputType | null
    _sum: CostAlertSumAggregateOutputType | null
    _min: CostAlertMinAggregateOutputType | null
    _max: CostAlertMaxAggregateOutputType | null
  }

  export type CostAlertAvgAggregateOutputType = {
    threshold: number | null
    current: number | null
  }

  export type CostAlertSumAggregateOutputType = {
    threshold: number | null
    current: number | null
  }

  export type CostAlertMinAggregateOutputType = {
    id: string | null
    type: string | null
    service: string | null
    threshold: number | null
    current: number | null
    message: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type CostAlertMaxAggregateOutputType = {
    id: string | null
    type: string | null
    service: string | null
    threshold: number | null
    current: number | null
    message: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type CostAlertCountAggregateOutputType = {
    id: number
    type: number
    service: number
    threshold: number
    current: number
    message: number
    resolved: number
    resolvedAt: number
    createdAt: number
    _all: number
  }


  export type CostAlertAvgAggregateInputType = {
    threshold?: true
    current?: true
  }

  export type CostAlertSumAggregateInputType = {
    threshold?: true
    current?: true
  }

  export type CostAlertMinAggregateInputType = {
    id?: true
    type?: true
    service?: true
    threshold?: true
    current?: true
    message?: true
    resolved?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type CostAlertMaxAggregateInputType = {
    id?: true
    type?: true
    service?: true
    threshold?: true
    current?: true
    message?: true
    resolved?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type CostAlertCountAggregateInputType = {
    id?: true
    type?: true
    service?: true
    threshold?: true
    current?: true
    message?: true
    resolved?: true
    resolvedAt?: true
    createdAt?: true
    _all?: true
  }

  export type CostAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostAlert to aggregate.
     */
    where?: CostAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostAlerts to fetch.
     */
    orderBy?: CostAlertOrderByWithRelationInput | CostAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostAlerts
    **/
    _count?: true | CostAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostAlertMaxAggregateInputType
  }

  export type GetCostAlertAggregateType<T extends CostAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateCostAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostAlert[P]>
      : GetScalarType<T[P], AggregateCostAlert[P]>
  }




  export type CostAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostAlertWhereInput
    orderBy?: CostAlertOrderByWithAggregationInput | CostAlertOrderByWithAggregationInput[]
    by: CostAlertScalarFieldEnum[] | CostAlertScalarFieldEnum
    having?: CostAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostAlertCountAggregateInputType | true
    _avg?: CostAlertAvgAggregateInputType
    _sum?: CostAlertSumAggregateInputType
    _min?: CostAlertMinAggregateInputType
    _max?: CostAlertMaxAggregateInputType
  }

  export type CostAlertGroupByOutputType = {
    id: string
    type: string
    service: string
    threshold: number
    current: number
    message: string
    resolved: boolean
    resolvedAt: Date | null
    createdAt: Date
    _count: CostAlertCountAggregateOutputType | null
    _avg: CostAlertAvgAggregateOutputType | null
    _sum: CostAlertSumAggregateOutputType | null
    _min: CostAlertMinAggregateOutputType | null
    _max: CostAlertMaxAggregateOutputType | null
  }

  type GetCostAlertGroupByPayload<T extends CostAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostAlertGroupByOutputType[P]>
            : GetScalarType<T[P], CostAlertGroupByOutputType[P]>
        }
      >
    >


  export type CostAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    service?: boolean
    threshold?: boolean
    current?: boolean
    message?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["costAlert"]>

  export type CostAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    service?: boolean
    threshold?: boolean
    current?: boolean
    message?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["costAlert"]>

  export type CostAlertSelectScalar = {
    id?: boolean
    type?: boolean
    service?: boolean
    threshold?: boolean
    current?: boolean
    message?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }


  export type $CostAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostAlert"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      service: string
      threshold: number
      current: number
      message: string
      resolved: boolean
      resolvedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["costAlert"]>
    composites: {}
  }

  type CostAlertGetPayload<S extends boolean | null | undefined | CostAlertDefaultArgs> = $Result.GetResult<Prisma.$CostAlertPayload, S>

  type CostAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CostAlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CostAlertCountAggregateInputType | true
    }

  export interface CostAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostAlert'], meta: { name: 'CostAlert' } }
    /**
     * Find zero or one CostAlert that matches the filter.
     * @param {CostAlertFindUniqueArgs} args - Arguments to find a CostAlert
     * @example
     * // Get one CostAlert
     * const costAlert = await prisma.costAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostAlertFindUniqueArgs>(args: SelectSubset<T, CostAlertFindUniqueArgs<ExtArgs>>): Prisma__CostAlertClient<$Result.GetResult<Prisma.$CostAlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CostAlert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CostAlertFindUniqueOrThrowArgs} args - Arguments to find a CostAlert
     * @example
     * // Get one CostAlert
     * const costAlert = await prisma.costAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, CostAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostAlertClient<$Result.GetResult<Prisma.$CostAlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CostAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostAlertFindFirstArgs} args - Arguments to find a CostAlert
     * @example
     * // Get one CostAlert
     * const costAlert = await prisma.costAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostAlertFindFirstArgs>(args?: SelectSubset<T, CostAlertFindFirstArgs<ExtArgs>>): Prisma__CostAlertClient<$Result.GetResult<Prisma.$CostAlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CostAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostAlertFindFirstOrThrowArgs} args - Arguments to find a CostAlert
     * @example
     * // Get one CostAlert
     * const costAlert = await prisma.costAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, CostAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostAlertClient<$Result.GetResult<Prisma.$CostAlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CostAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostAlerts
     * const costAlerts = await prisma.costAlert.findMany()
     * 
     * // Get first 10 CostAlerts
     * const costAlerts = await prisma.costAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costAlertWithIdOnly = await prisma.costAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostAlertFindManyArgs>(args?: SelectSubset<T, CostAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostAlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CostAlert.
     * @param {CostAlertCreateArgs} args - Arguments to create a CostAlert.
     * @example
     * // Create one CostAlert
     * const CostAlert = await prisma.costAlert.create({
     *   data: {
     *     // ... data to create a CostAlert
     *   }
     * })
     * 
     */
    create<T extends CostAlertCreateArgs>(args: SelectSubset<T, CostAlertCreateArgs<ExtArgs>>): Prisma__CostAlertClient<$Result.GetResult<Prisma.$CostAlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CostAlerts.
     * @param {CostAlertCreateManyArgs} args - Arguments to create many CostAlerts.
     * @example
     * // Create many CostAlerts
     * const costAlert = await prisma.costAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostAlertCreateManyArgs>(args?: SelectSubset<T, CostAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostAlerts and returns the data saved in the database.
     * @param {CostAlertCreateManyAndReturnArgs} args - Arguments to create many CostAlerts.
     * @example
     * // Create many CostAlerts
     * const costAlert = await prisma.costAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostAlerts and only return the `id`
     * const costAlertWithIdOnly = await prisma.costAlert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, CostAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostAlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CostAlert.
     * @param {CostAlertDeleteArgs} args - Arguments to delete one CostAlert.
     * @example
     * // Delete one CostAlert
     * const CostAlert = await prisma.costAlert.delete({
     *   where: {
     *     // ... filter to delete one CostAlert
     *   }
     * })
     * 
     */
    delete<T extends CostAlertDeleteArgs>(args: SelectSubset<T, CostAlertDeleteArgs<ExtArgs>>): Prisma__CostAlertClient<$Result.GetResult<Prisma.$CostAlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CostAlert.
     * @param {CostAlertUpdateArgs} args - Arguments to update one CostAlert.
     * @example
     * // Update one CostAlert
     * const costAlert = await prisma.costAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostAlertUpdateArgs>(args: SelectSubset<T, CostAlertUpdateArgs<ExtArgs>>): Prisma__CostAlertClient<$Result.GetResult<Prisma.$CostAlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CostAlerts.
     * @param {CostAlertDeleteManyArgs} args - Arguments to filter CostAlerts to delete.
     * @example
     * // Delete a few CostAlerts
     * const { count } = await prisma.costAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostAlertDeleteManyArgs>(args?: SelectSubset<T, CostAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostAlerts
     * const costAlert = await prisma.costAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostAlertUpdateManyArgs>(args: SelectSubset<T, CostAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CostAlert.
     * @param {CostAlertUpsertArgs} args - Arguments to update or create a CostAlert.
     * @example
     * // Update or create a CostAlert
     * const costAlert = await prisma.costAlert.upsert({
     *   create: {
     *     // ... data to create a CostAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostAlert we want to update
     *   }
     * })
     */
    upsert<T extends CostAlertUpsertArgs>(args: SelectSubset<T, CostAlertUpsertArgs<ExtArgs>>): Prisma__CostAlertClient<$Result.GetResult<Prisma.$CostAlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CostAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostAlertCountArgs} args - Arguments to filter CostAlerts to count.
     * @example
     * // Count the number of CostAlerts
     * const count = await prisma.costAlert.count({
     *   where: {
     *     // ... the filter for the CostAlerts we want to count
     *   }
     * })
    **/
    count<T extends CostAlertCountArgs>(
      args?: Subset<T, CostAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostAlertAggregateArgs>(args: Subset<T, CostAlertAggregateArgs>): Prisma.PrismaPromise<GetCostAlertAggregateType<T>>

    /**
     * Group by CostAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostAlertGroupByArgs['orderBy'] }
        : { orderBy?: CostAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostAlert model
   */
  readonly fields: CostAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostAlert model
   */ 
  interface CostAlertFieldRefs {
    readonly id: FieldRef<"CostAlert", 'String'>
    readonly type: FieldRef<"CostAlert", 'String'>
    readonly service: FieldRef<"CostAlert", 'String'>
    readonly threshold: FieldRef<"CostAlert", 'Float'>
    readonly current: FieldRef<"CostAlert", 'Float'>
    readonly message: FieldRef<"CostAlert", 'String'>
    readonly resolved: FieldRef<"CostAlert", 'Boolean'>
    readonly resolvedAt: FieldRef<"CostAlert", 'DateTime'>
    readonly createdAt: FieldRef<"CostAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostAlert findUnique
   */
  export type CostAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostAlert
     */
    select?: CostAlertSelect<ExtArgs> | null
    /**
     * Filter, which CostAlert to fetch.
     */
    where: CostAlertWhereUniqueInput
  }

  /**
   * CostAlert findUniqueOrThrow
   */
  export type CostAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostAlert
     */
    select?: CostAlertSelect<ExtArgs> | null
    /**
     * Filter, which CostAlert to fetch.
     */
    where: CostAlertWhereUniqueInput
  }

  /**
   * CostAlert findFirst
   */
  export type CostAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostAlert
     */
    select?: CostAlertSelect<ExtArgs> | null
    /**
     * Filter, which CostAlert to fetch.
     */
    where?: CostAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostAlerts to fetch.
     */
    orderBy?: CostAlertOrderByWithRelationInput | CostAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostAlerts.
     */
    cursor?: CostAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostAlerts.
     */
    distinct?: CostAlertScalarFieldEnum | CostAlertScalarFieldEnum[]
  }

  /**
   * CostAlert findFirstOrThrow
   */
  export type CostAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostAlert
     */
    select?: CostAlertSelect<ExtArgs> | null
    /**
     * Filter, which CostAlert to fetch.
     */
    where?: CostAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostAlerts to fetch.
     */
    orderBy?: CostAlertOrderByWithRelationInput | CostAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostAlerts.
     */
    cursor?: CostAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostAlerts.
     */
    distinct?: CostAlertScalarFieldEnum | CostAlertScalarFieldEnum[]
  }

  /**
   * CostAlert findMany
   */
  export type CostAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostAlert
     */
    select?: CostAlertSelect<ExtArgs> | null
    /**
     * Filter, which CostAlerts to fetch.
     */
    where?: CostAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostAlerts to fetch.
     */
    orderBy?: CostAlertOrderByWithRelationInput | CostAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostAlerts.
     */
    cursor?: CostAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostAlerts.
     */
    skip?: number
    distinct?: CostAlertScalarFieldEnum | CostAlertScalarFieldEnum[]
  }

  /**
   * CostAlert create
   */
  export type CostAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostAlert
     */
    select?: CostAlertSelect<ExtArgs> | null
    /**
     * The data needed to create a CostAlert.
     */
    data: XOR<CostAlertCreateInput, CostAlertUncheckedCreateInput>
  }

  /**
   * CostAlert createMany
   */
  export type CostAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostAlerts.
     */
    data: CostAlertCreateManyInput | CostAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostAlert createManyAndReturn
   */
  export type CostAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostAlert
     */
    select?: CostAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CostAlerts.
     */
    data: CostAlertCreateManyInput | CostAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostAlert update
   */
  export type CostAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostAlert
     */
    select?: CostAlertSelect<ExtArgs> | null
    /**
     * The data needed to update a CostAlert.
     */
    data: XOR<CostAlertUpdateInput, CostAlertUncheckedUpdateInput>
    /**
     * Choose, which CostAlert to update.
     */
    where: CostAlertWhereUniqueInput
  }

  /**
   * CostAlert updateMany
   */
  export type CostAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostAlerts.
     */
    data: XOR<CostAlertUpdateManyMutationInput, CostAlertUncheckedUpdateManyInput>
    /**
     * Filter which CostAlerts to update
     */
    where?: CostAlertWhereInput
  }

  /**
   * CostAlert upsert
   */
  export type CostAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostAlert
     */
    select?: CostAlertSelect<ExtArgs> | null
    /**
     * The filter to search for the CostAlert to update in case it exists.
     */
    where: CostAlertWhereUniqueInput
    /**
     * In case the CostAlert found by the `where` argument doesn't exist, create a new CostAlert with this data.
     */
    create: XOR<CostAlertCreateInput, CostAlertUncheckedCreateInput>
    /**
     * In case the CostAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostAlertUpdateInput, CostAlertUncheckedUpdateInput>
  }

  /**
   * CostAlert delete
   */
  export type CostAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostAlert
     */
    select?: CostAlertSelect<ExtArgs> | null
    /**
     * Filter which CostAlert to delete.
     */
    where: CostAlertWhereUniqueInput
  }

  /**
   * CostAlert deleteMany
   */
  export type CostAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostAlerts to delete
     */
    where?: CostAlertWhereInput
  }

  /**
   * CostAlert without action
   */
  export type CostAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostAlert
     */
    select?: CostAlertSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CreatorScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    displayName: 'displayName',
    bio: 'bio',
    avatar: 'avatar',
    stripeAccountId: 'stripeAccountId',
    stripeCustomerId: 'stripeCustomerId',
    stripeConnected: 'stripeConnected',
    kycStatus: 'kycStatus',
    commissionTier: 'commissionTier',
    totalRevenue: 'totalRevenue',
    availableBalance: 'availableBalance',
    currency: 'currency',
    locale: 'locale',
    timezone: 'timezone',
    onboardingCompleted: 'onboardingCompleted',
    emailVerified: 'emailVerified',
    twoFactorEnabled: 'twoFactorEnabled',
    phoneNumber: 'phoneNumber',
    smsOptIn: 'smsOptIn',
    currentPlan: 'currentPlan',
    accountStatus: 'accountStatus',
    planDowngradedAt: 'planDowngradedAt',
    planDowngradeReason: 'planDowngradeReason',
    suspendedAt: 'suspendedAt',
    suspensionReason: 'suspensionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CreatorScalarFieldEnum = (typeof CreatorScalarFieldEnum)[keyof typeof CreatorScalarFieldEnum]


  export const CreatorSettingsScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    emailNotifications: 'emailNotifications',
    smsNotifications: 'smsNotifications',
    pushNotifications: 'pushNotifications',
    showPublicProfile: 'showPublicProfile',
    allowDMs: 'allowDMs',
    minPayout: 'minPayout',
    payoutFrequency: 'payoutFrequency',
    taxFormSubmitted: 'taxFormSubmitted',
    w9Submitted: 'w9Submitted',
    defaultContentAccess: 'defaultContentAccess',
    watermarkContent: 'watermarkContent',
    updatedAt: 'updatedAt'
  };

  export type CreatorSettingsScalarFieldEnum = (typeof CreatorSettingsScalarFieldEnum)[keyof typeof CreatorSettingsScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    name: 'name',
    description: 'description',
    price: 'price',
    currency: 'currency',
    interval: 'interval',
    intervalCount: 'intervalCount',
    features: 'features',
    maxDownloads: 'maxDownloads',
    earlyAccess: 'earlyAccess',
    exclusiveContent: 'exclusiveContent',
    trialPeriodDays: 'trialPeriodDays',
    stripePriceId: 'stripePriceId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    type: 'type',
    title: 'title',
    description: 'description',
    price: 'price',
    currency: 'currency',
    contentUrl: 'contentUrl',
    thumbnailUrl: 'thumbnailUrl',
    previewUrl: 'previewUrl',
    accessType: 'accessType',
    requiresSubscription: 'requiresSubscription',
    tags: 'tags',
    isPublished: 'isPublished',
    publishedAt: 'publishedAt',
    viewCount: 'viewCount',
    purchaseCount: 'purchaseCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const FanScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    displayName: 'displayName',
    avatar: 'avatar',
    stripeCustomerId: 'stripeCustomerId',
    emailVerified: 'emailVerified',
    phoneNumber: 'phoneNumber',
    phoneVerified: 'phoneVerified',
    locale: 'locale',
    timezone: 'timezone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FanScalarFieldEnum = (typeof FanScalarFieldEnum)[keyof typeof FanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    fanId: 'fanId',
    creatorId: 'creatorId',
    planId: 'planId',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    canceledAt: 'canceledAt',
    endedAt: 'endedAt',
    stripeSubscriptionId: 'stripeSubscriptionId',
    totalSpent: 'totalSpent',
    renewalCount: 'renewalCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    fanId: 'fanId',
    productId: 'productId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    stripePaymentIntentId: 'stripePaymentIntentId',
    downloadCount: 'downloadCount',
    lastDownloadAt: 'lastDownloadAt',
    createdAt: 'createdAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    fanId: 'fanId',
    type: 'type',
    amount: 'amount',
    currency: 'currency',
    platformFee: 'platformFee',
    platformFeeRate: 'platformFeeRate',
    netAmount: 'netAmount',
    status: 'status',
    subscriptionId: 'subscriptionId',
    purchaseId: 'purchaseId',
    payoutId: 'payoutId',
    stripeTransferId: 'stripeTransferId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const PayoutScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    method: 'method',
    destination: 'destination',
    stripePayoutId: 'stripePayoutId',
    processedAt: 'processedAt',
    failureReason: 'failureReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayoutScalarFieldEnum = (typeof PayoutScalarFieldEnum)[keyof typeof PayoutScalarFieldEnum]


  export const AnalyticsScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    date: 'date',
    revenue: 'revenue',
    subscriptionRevenue: 'subscriptionRevenue',
    productRevenue: 'productRevenue',
    newSubscribers: 'newSubscribers',
    churned: 'churned',
    activeSubscribers: 'activeSubscribers',
    pageViews: 'pageViews',
    uniqueVisitors: 'uniqueVisitors',
    contentViews: 'contentViews',
    conversionRate: 'conversionRate',
    avgOrderValue: 'avgOrderValue',
    createdAt: 'createdAt'
  };

  export type AnalyticsScalarFieldEnum = (typeof AnalyticsScalarFieldEnum)[keyof typeof AnalyticsScalarFieldEnum]


  export const FanRelationScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    fanId: 'fanId',
    tags: 'tags',
    notes: 'notes',
    engagementScore: 'engagementScore',
    lifetimeValue: 'lifetimeValue',
    lastInteraction: 'lastInteraction',
    emailOptIn: 'emailOptIn',
    smsOptIn: 'smsOptIn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FanRelationScalarFieldEnum = (typeof FanRelationScalarFieldEnum)[keyof typeof FanRelationScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    name: 'name',
    type: 'type',
    status: 'status',
    subject: 'subject',
    content: 'content',
    targetTags: 'targetTags',
    targetSegment: 'targetSegment',
    scheduledFor: 'scheduledFor',
    sentAt: 'sentAt',
    sentCount: 'sentCount',
    openCount: 'openCount',
    clickCount: 'clickCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignRecipientScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    fanId: 'fanId',
    status: 'status',
    sentAt: 'sentAt',
    openedAt: 'openedAt',
    clickedAt: 'clickedAt'
  };

  export type CampaignRecipientScalarFieldEnum = (typeof CampaignRecipientScalarFieldEnum)[keyof typeof CampaignRecipientScalarFieldEnum]


  export const AppScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    icon: 'icon',
    developer: 'developer',
    website: 'website',
    category: 'category',
    pricing: 'pricing',
    price: 'price',
    webhookUrl: 'webhookUrl',
    scopes: 'scopes',
    isPublished: 'isPublished',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppScalarFieldEnum = (typeof AppScalarFieldEnum)[keyof typeof AppScalarFieldEnum]


  export const InstalledAppScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    appId: 'appId',
    status: 'status',
    settings: 'settings',
    billingCycle: 'billingCycle',
    nextBilling: 'nextBilling',
    installedAt: 'installedAt',
    uninstalledAt: 'uninstalledAt'
  };

  export type InstalledAppScalarFieldEnum = (typeof InstalledAppScalarFieldEnum)[keyof typeof InstalledAppScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    actorId: 'actorId',
    actorType: 'actorType',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const LedgerAccountScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    type: 'type',
    currency: 'currency',
    ownerId: 'ownerId',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LedgerAccountScalarFieldEnum = (typeof LedgerAccountScalarFieldEnum)[keyof typeof LedgerAccountScalarFieldEnum]


  export const LedgerTransactionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    kind: 'kind',
    currency: 'currency',
    occurredAt: 'occurredAt',
    memo: 'memo',
    source: 'source',
    extRef: 'extRef',
    stripeEventId: 'stripeEventId',
    idempotencyKey: 'idempotencyKey',
    reversedBy: 'reversedBy',
    createdAt: 'createdAt'
  };

  export type LedgerTransactionScalarFieldEnum = (typeof LedgerTransactionScalarFieldEnum)[keyof typeof LedgerTransactionScalarFieldEnum]


  export const LedgerEntryScalarFieldEnum: {
    id: 'id',
    txId: 'txId',
    accountId: 'accountId',
    direction: 'direction',
    amountCents: 'amountCents',
    currency: 'currency',
    createdAt: 'createdAt'
  };

  export type LedgerEntryScalarFieldEnum = (typeof LedgerEntryScalarFieldEnum)[keyof typeof LedgerEntryScalarFieldEnum]


  export const CommissionCapMonthlyScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    yearMonth: 'yearMonth',
    currency: 'currency',
    capCents: 'capCents',
    appliedCents: 'appliedCents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommissionCapMonthlyScalarFieldEnum = (typeof CommissionCapMonthlyScalarFieldEnum)[keyof typeof CommissionCapMonthlyScalarFieldEnum]


  export const ExternalEarningsSourceScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    platform: 'platform',
    externalHandle: 'externalHandle',
    currency: 'currency',
    connectedAt: 'connectedAt',
    active: 'active',
    lastSync: 'lastSync',
    metadata: 'metadata'
  };

  export type ExternalEarningsSourceScalarFieldEnum = (typeof ExternalEarningsSourceScalarFieldEnum)[keyof typeof ExternalEarningsSourceScalarFieldEnum]


  export const ExternalEarningsImportScalarFieldEnum: {
    id: 'id',
    sourceId: 'sourceId',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    rawHash: 'rawHash',
    rawJson: 'rawJson',
    processedAt: 'processedAt',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt'
  };

  export type ExternalEarningsImportScalarFieldEnum = (typeof ExternalEarningsImportScalarFieldEnum)[keyof typeof ExternalEarningsImportScalarFieldEnum]


  export const NormalizedEarningScalarFieldEnum: {
    id: 'id',
    sourceId: 'sourceId',
    occurredAt: 'occurredAt',
    currency: 'currency',
    grossCents: 'grossCents',
    feesCents: 'feesCents',
    netCents: 'netCents',
    payoutId: 'payoutId',
    extRef: 'extRef',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type NormalizedEarningScalarFieldEnum = (typeof NormalizedEarningScalarFieldEnum)[keyof typeof NormalizedEarningScalarFieldEnum]


  export const CommissionStatementScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    platform: 'platform',
    yearMonth: 'yearMonth',
    currency: 'currency',
    baseNetCents: 'baseNetCents',
    rateBps: 'rateBps',
    commissionCents: 'commissionCents',
    capAppliedCents: 'capAppliedCents',
    finalCents: 'finalCents',
    closedAt: 'closedAt',
    invoicedAt: 'invoicedAt',
    stripeInvoiceId: 'stripeInvoiceId',
    paidAt: 'paidAt',
    writeOffAt: 'writeOffAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommissionStatementScalarFieldEnum = (typeof CommissionStatementScalarFieldEnum)[keyof typeof CommissionStatementScalarFieldEnum]


  export const DunningStateScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    creatorId: 'creatorId',
    attemptCount: 'attemptCount',
    status: 'status',
    lastAttempt: 'lastAttempt',
    nextAttempt: 'nextAttempt',
    recoveredAt: 'recoveredAt',
    writeOffAt: 'writeOffAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DunningStateScalarFieldEnum = (typeof DunningStateScalarFieldEnum)[keyof typeof DunningStateScalarFieldEnum]


  export const PaymentAttemptScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    attemptNumber: 'attemptNumber',
    status: 'status',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    paymentMethodId: 'paymentMethodId',
    amount: 'amount',
    currency: 'currency',
    createdAt: 'createdAt'
  };

  export type PaymentAttemptScalarFieldEnum = (typeof PaymentAttemptScalarFieldEnum)[keyof typeof PaymentAttemptScalarFieldEnum]


  export const AutomationScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    name: 'name',
    triggerType: 'triggerType',
    conditions: 'conditions',
    actions: 'actions',
    status: 'status',
    lastRun: 'lastRun',
    runCount: 'runCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutomationScalarFieldEnum = (typeof AutomationScalarFieldEnum)[keyof typeof AutomationScalarFieldEnum]


  export const BackupLogScalarFieldEnum: {
    id: 'id',
    status: 'status',
    duration: 'duration',
    error: 'error',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type BackupLogScalarFieldEnum = (typeof BackupLogScalarFieldEnum)[keyof typeof BackupLogScalarFieldEnum]


  export const BackupValidationScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    results: 'results',
    summary: 'summary',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type BackupValidationScalarFieldEnum = (typeof BackupValidationScalarFieldEnum)[keyof typeof BackupValidationScalarFieldEnum]


  export const BackupIndexScalarFieldEnum: {
    id: 'id',
    backupId: 'backupId',
    timestamp: 'timestamp',
    metadata: 'metadata',
    tables: 'tables',
    createdAt: 'createdAt'
  };

  export type BackupIndexScalarFieldEnum = (typeof BackupIndexScalarFieldEnum)[keyof typeof BackupIndexScalarFieldEnum]


  export const AIUsageLogScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    model: 'model',
    purpose: 'purpose',
    userId: 'userId',
    promptTokens: 'promptTokens',
    completionTokens: 'completionTokens',
    totalTokens: 'totalTokens',
    cost: 'cost',
    cached: 'cached',
    timestamp: 'timestamp'
  };

  export type AIUsageLogScalarFieldEnum = (typeof AIUsageLogScalarFieldEnum)[keyof typeof AIUsageLogScalarFieldEnum]


  export const CostReservationScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    service: 'service',
    commitment: 'commitment',
    units: 'units',
    unitPrice: 'unitPrice',
    savings: 'savings',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostReservationScalarFieldEnum = (typeof CostReservationScalarFieldEnum)[keyof typeof CostReservationScalarFieldEnum]


  export const PromptOptimizationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    originalPrompt: 'originalPrompt',
    optimizedPrompt: 'optimizedPrompt',
    originalTokens: 'originalTokens',
    optimizedTokens: 'optimizedTokens',
    tokenReduction: 'tokenReduction',
    qualityScore: 'qualityScore',
    abTestResults: 'abTestResults',
    timestamp: 'timestamp'
  };

  export type PromptOptimizationScalarFieldEnum = (typeof PromptOptimizationScalarFieldEnum)[keyof typeof PromptOptimizationScalarFieldEnum]


  export const CostAlertScalarFieldEnum: {
    id: 'id',
    type: 'type',
    service: 'service',
    threshold: 'threshold',
    current: 'current',
    message: 'message',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt'
  };

  export type CostAlertScalarFieldEnum = (typeof CostAlertScalarFieldEnum)[keyof typeof CostAlertScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'KycStatus'
   */
  export type EnumKycStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KycStatus'>
    


  /**
   * Reference to a field of type 'KycStatus[]'
   */
  export type ListEnumKycStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KycStatus[]'>
    


  /**
   * Reference to a field of type 'CommissionTier'
   */
  export type EnumCommissionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommissionTier'>
    


  /**
   * Reference to a field of type 'CommissionTier[]'
   */
  export type ListEnumCommissionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommissionTier[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PayoutFrequency'
   */
  export type EnumPayoutFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutFrequency'>
    


  /**
   * Reference to a field of type 'PayoutFrequency[]'
   */
  export type ListEnumPayoutFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutFrequency[]'>
    


  /**
   * Reference to a field of type 'ContentAccess'
   */
  export type EnumContentAccessFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentAccess'>
    


  /**
   * Reference to a field of type 'ContentAccess[]'
   */
  export type ListEnumContentAccessFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentAccess[]'>
    


  /**
   * Reference to a field of type 'BillingInterval'
   */
  export type EnumBillingIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingInterval'>
    


  /**
   * Reference to a field of type 'BillingInterval[]'
   */
  export type ListEnumBillingIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingInterval[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'ProductType[]'
   */
  export type ListEnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'PurchaseStatus'
   */
  export type EnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus'>
    


  /**
   * Reference to a field of type 'PurchaseStatus[]'
   */
  export type ListEnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'PayoutStatus'
   */
  export type EnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus'>
    


  /**
   * Reference to a field of type 'PayoutStatus[]'
   */
  export type ListEnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus[]'>
    


  /**
   * Reference to a field of type 'PayoutMethod'
   */
  export type EnumPayoutMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutMethod'>
    


  /**
   * Reference to a field of type 'PayoutMethod[]'
   */
  export type ListEnumPayoutMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutMethod[]'>
    


  /**
   * Reference to a field of type 'CampaignType'
   */
  export type EnumCampaignTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignType'>
    


  /**
   * Reference to a field of type 'CampaignType[]'
   */
  export type ListEnumCampaignTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignType[]'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus[]'
   */
  export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    


  /**
   * Reference to a field of type 'RecipientStatus'
   */
  export type EnumRecipientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecipientStatus'>
    


  /**
   * Reference to a field of type 'RecipientStatus[]'
   */
  export type ListEnumRecipientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecipientStatus[]'>
    


  /**
   * Reference to a field of type 'AppCategory'
   */
  export type EnumAppCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppCategory'>
    


  /**
   * Reference to a field of type 'AppCategory[]'
   */
  export type ListEnumAppCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppCategory[]'>
    


  /**
   * Reference to a field of type 'AppPricing'
   */
  export type EnumAppPricingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppPricing'>
    


  /**
   * Reference to a field of type 'AppPricing[]'
   */
  export type ListEnumAppPricingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppPricing[]'>
    


  /**
   * Reference to a field of type 'AppStatus'
   */
  export type EnumAppStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppStatus'>
    


  /**
   * Reference to a field of type 'AppStatus[]'
   */
  export type ListEnumAppStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppStatus[]'>
    


  /**
   * Reference to a field of type 'ActorType'
   */
  export type EnumActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActorType'>
    


  /**
   * Reference to a field of type 'ActorType[]'
   */
  export type ListEnumActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActorType[]'>
    


  /**
   * Reference to a field of type 'LedgerAccountType'
   */
  export type EnumLedgerAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerAccountType'>
    


  /**
   * Reference to a field of type 'LedgerAccountType[]'
   */
  export type ListEnumLedgerAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerAccountType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'LedgerTransactionKind'
   */
  export type EnumLedgerTransactionKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerTransactionKind'>
    


  /**
   * Reference to a field of type 'LedgerTransactionKind[]'
   */
  export type ListEnumLedgerTransactionKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerTransactionKind[]'>
    


  /**
   * Reference to a field of type 'LedgerDirection'
   */
  export type EnumLedgerDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerDirection'>
    


  /**
   * Reference to a field of type 'LedgerDirection[]'
   */
  export type ListEnumLedgerDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerDirection[]'>
    


  /**
   * Reference to a field of type 'ExternalPlatform'
   */
  export type EnumExternalPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExternalPlatform'>
    


  /**
   * Reference to a field of type 'ExternalPlatform[]'
   */
  export type ListEnumExternalPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExternalPlatform[]'>
    


  /**
   * Reference to a field of type 'DunningStatus'
   */
  export type EnumDunningStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DunningStatus'>
    


  /**
   * Reference to a field of type 'DunningStatus[]'
   */
  export type ListEnumDunningStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DunningStatus[]'>
    


  /**
   * Reference to a field of type 'AutomationTrigger'
   */
  export type EnumAutomationTriggerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationTrigger'>
    


  /**
   * Reference to a field of type 'AutomationTrigger[]'
   */
  export type ListEnumAutomationTriggerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationTrigger[]'>
    


  /**
   * Reference to a field of type 'AutomationStatus'
   */
  export type EnumAutomationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationStatus'>
    


  /**
   * Reference to a field of type 'AutomationStatus[]'
   */
  export type ListEnumAutomationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CreatorWhereInput = {
    AND?: CreatorWhereInput | CreatorWhereInput[]
    OR?: CreatorWhereInput[]
    NOT?: CreatorWhereInput | CreatorWhereInput[]
    id?: StringFilter<"Creator"> | string
    email?: StringFilter<"Creator"> | string
    username?: StringFilter<"Creator"> | string
    displayName?: StringFilter<"Creator"> | string
    bio?: StringNullableFilter<"Creator"> | string | null
    avatar?: StringNullableFilter<"Creator"> | string | null
    stripeAccountId?: StringNullableFilter<"Creator"> | string | null
    stripeCustomerId?: StringNullableFilter<"Creator"> | string | null
    stripeConnected?: BoolFilter<"Creator"> | boolean
    kycStatus?: EnumKycStatusFilter<"Creator"> | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFilter<"Creator"> | $Enums.CommissionTier
    totalRevenue?: DecimalFilter<"Creator"> | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFilter<"Creator"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Creator"> | string
    locale?: StringFilter<"Creator"> | string
    timezone?: StringFilter<"Creator"> | string
    onboardingCompleted?: BoolFilter<"Creator"> | boolean
    emailVerified?: BoolFilter<"Creator"> | boolean
    twoFactorEnabled?: BoolFilter<"Creator"> | boolean
    phoneNumber?: StringNullableFilter<"Creator"> | string | null
    smsOptIn?: BoolFilter<"Creator"> | boolean
    currentPlan?: StringFilter<"Creator"> | string
    accountStatus?: EnumAccountStatusFilter<"Creator"> | $Enums.AccountStatus
    planDowngradedAt?: DateTimeNullableFilter<"Creator"> | Date | string | null
    planDowngradeReason?: StringNullableFilter<"Creator"> | string | null
    suspendedAt?: DateTimeNullableFilter<"Creator"> | Date | string | null
    suspensionReason?: StringNullableFilter<"Creator"> | string | null
    createdAt?: DateTimeFilter<"Creator"> | Date | string
    updatedAt?: DateTimeFilter<"Creator"> | Date | string
    subscriptionPlans?: SubscriptionPlanListRelationFilter
    products?: ProductListRelationFilter
    subscribers?: SubscriptionListRelationFilter
    transactions?: TransactionListRelationFilter
    payouts?: PayoutListRelationFilter
    analytics?: AnalyticsListRelationFilter
    installedApps?: InstalledAppListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    settings?: XOR<CreatorSettingsNullableRelationFilter, CreatorSettingsWhereInput> | null
    fanRelations?: FanRelationListRelationFilter
    campaigns?: CampaignListRelationFilter
  }

  export type CreatorOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeConnected?: SortOrder
    kycStatus?: SortOrder
    commissionTier?: SortOrder
    totalRevenue?: SortOrder
    availableBalance?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    onboardingCompleted?: SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    smsOptIn?: SortOrder
    currentPlan?: SortOrder
    accountStatus?: SortOrder
    planDowngradedAt?: SortOrderInput | SortOrder
    planDowngradeReason?: SortOrderInput | SortOrder
    suspendedAt?: SortOrderInput | SortOrder
    suspensionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptionPlans?: SubscriptionPlanOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    subscribers?: SubscriptionOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    payouts?: PayoutOrderByRelationAggregateInput
    analytics?: AnalyticsOrderByRelationAggregateInput
    installedApps?: InstalledAppOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    settings?: CreatorSettingsOrderByWithRelationInput
    fanRelations?: FanRelationOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
  }

  export type CreatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    stripeAccountId?: string
    stripeCustomerId?: string
    AND?: CreatorWhereInput | CreatorWhereInput[]
    OR?: CreatorWhereInput[]
    NOT?: CreatorWhereInput | CreatorWhereInput[]
    displayName?: StringFilter<"Creator"> | string
    bio?: StringNullableFilter<"Creator"> | string | null
    avatar?: StringNullableFilter<"Creator"> | string | null
    stripeConnected?: BoolFilter<"Creator"> | boolean
    kycStatus?: EnumKycStatusFilter<"Creator"> | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFilter<"Creator"> | $Enums.CommissionTier
    totalRevenue?: DecimalFilter<"Creator"> | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFilter<"Creator"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Creator"> | string
    locale?: StringFilter<"Creator"> | string
    timezone?: StringFilter<"Creator"> | string
    onboardingCompleted?: BoolFilter<"Creator"> | boolean
    emailVerified?: BoolFilter<"Creator"> | boolean
    twoFactorEnabled?: BoolFilter<"Creator"> | boolean
    phoneNumber?: StringNullableFilter<"Creator"> | string | null
    smsOptIn?: BoolFilter<"Creator"> | boolean
    currentPlan?: StringFilter<"Creator"> | string
    accountStatus?: EnumAccountStatusFilter<"Creator"> | $Enums.AccountStatus
    planDowngradedAt?: DateTimeNullableFilter<"Creator"> | Date | string | null
    planDowngradeReason?: StringNullableFilter<"Creator"> | string | null
    suspendedAt?: DateTimeNullableFilter<"Creator"> | Date | string | null
    suspensionReason?: StringNullableFilter<"Creator"> | string | null
    createdAt?: DateTimeFilter<"Creator"> | Date | string
    updatedAt?: DateTimeFilter<"Creator"> | Date | string
    subscriptionPlans?: SubscriptionPlanListRelationFilter
    products?: ProductListRelationFilter
    subscribers?: SubscriptionListRelationFilter
    transactions?: TransactionListRelationFilter
    payouts?: PayoutListRelationFilter
    analytics?: AnalyticsListRelationFilter
    installedApps?: InstalledAppListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    settings?: XOR<CreatorSettingsNullableRelationFilter, CreatorSettingsWhereInput> | null
    fanRelations?: FanRelationListRelationFilter
    campaigns?: CampaignListRelationFilter
  }, "id" | "email" | "username" | "stripeAccountId" | "stripeCustomerId">

  export type CreatorOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeConnected?: SortOrder
    kycStatus?: SortOrder
    commissionTier?: SortOrder
    totalRevenue?: SortOrder
    availableBalance?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    onboardingCompleted?: SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    smsOptIn?: SortOrder
    currentPlan?: SortOrder
    accountStatus?: SortOrder
    planDowngradedAt?: SortOrderInput | SortOrder
    planDowngradeReason?: SortOrderInput | SortOrder
    suspendedAt?: SortOrderInput | SortOrder
    suspensionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CreatorCountOrderByAggregateInput
    _avg?: CreatorAvgOrderByAggregateInput
    _max?: CreatorMaxOrderByAggregateInput
    _min?: CreatorMinOrderByAggregateInput
    _sum?: CreatorSumOrderByAggregateInput
  }

  export type CreatorScalarWhereWithAggregatesInput = {
    AND?: CreatorScalarWhereWithAggregatesInput | CreatorScalarWhereWithAggregatesInput[]
    OR?: CreatorScalarWhereWithAggregatesInput[]
    NOT?: CreatorScalarWhereWithAggregatesInput | CreatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Creator"> | string
    email?: StringWithAggregatesFilter<"Creator"> | string
    username?: StringWithAggregatesFilter<"Creator"> | string
    displayName?: StringWithAggregatesFilter<"Creator"> | string
    bio?: StringNullableWithAggregatesFilter<"Creator"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Creator"> | string | null
    stripeAccountId?: StringNullableWithAggregatesFilter<"Creator"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Creator"> | string | null
    stripeConnected?: BoolWithAggregatesFilter<"Creator"> | boolean
    kycStatus?: EnumKycStatusWithAggregatesFilter<"Creator"> | $Enums.KycStatus
    commissionTier?: EnumCommissionTierWithAggregatesFilter<"Creator"> | $Enums.CommissionTier
    totalRevenue?: DecimalWithAggregatesFilter<"Creator"> | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalWithAggregatesFilter<"Creator"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Creator"> | string
    locale?: StringWithAggregatesFilter<"Creator"> | string
    timezone?: StringWithAggregatesFilter<"Creator"> | string
    onboardingCompleted?: BoolWithAggregatesFilter<"Creator"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"Creator"> | boolean
    twoFactorEnabled?: BoolWithAggregatesFilter<"Creator"> | boolean
    phoneNumber?: StringNullableWithAggregatesFilter<"Creator"> | string | null
    smsOptIn?: BoolWithAggregatesFilter<"Creator"> | boolean
    currentPlan?: StringWithAggregatesFilter<"Creator"> | string
    accountStatus?: EnumAccountStatusWithAggregatesFilter<"Creator"> | $Enums.AccountStatus
    planDowngradedAt?: DateTimeNullableWithAggregatesFilter<"Creator"> | Date | string | null
    planDowngradeReason?: StringNullableWithAggregatesFilter<"Creator"> | string | null
    suspendedAt?: DateTimeNullableWithAggregatesFilter<"Creator"> | Date | string | null
    suspensionReason?: StringNullableWithAggregatesFilter<"Creator"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Creator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Creator"> | Date | string
  }

  export type CreatorSettingsWhereInput = {
    AND?: CreatorSettingsWhereInput | CreatorSettingsWhereInput[]
    OR?: CreatorSettingsWhereInput[]
    NOT?: CreatorSettingsWhereInput | CreatorSettingsWhereInput[]
    id?: StringFilter<"CreatorSettings"> | string
    creatorId?: StringFilter<"CreatorSettings"> | string
    emailNotifications?: BoolFilter<"CreatorSettings"> | boolean
    smsNotifications?: BoolFilter<"CreatorSettings"> | boolean
    pushNotifications?: BoolFilter<"CreatorSettings"> | boolean
    showPublicProfile?: BoolFilter<"CreatorSettings"> | boolean
    allowDMs?: BoolFilter<"CreatorSettings"> | boolean
    minPayout?: DecimalFilter<"CreatorSettings"> | Decimal | DecimalJsLike | number | string
    payoutFrequency?: EnumPayoutFrequencyFilter<"CreatorSettings"> | $Enums.PayoutFrequency
    taxFormSubmitted?: BoolFilter<"CreatorSettings"> | boolean
    w9Submitted?: BoolFilter<"CreatorSettings"> | boolean
    defaultContentAccess?: EnumContentAccessFilter<"CreatorSettings"> | $Enums.ContentAccess
    watermarkContent?: BoolFilter<"CreatorSettings"> | boolean
    updatedAt?: DateTimeFilter<"CreatorSettings"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
  }

  export type CreatorSettingsOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    showPublicProfile?: SortOrder
    allowDMs?: SortOrder
    minPayout?: SortOrder
    payoutFrequency?: SortOrder
    taxFormSubmitted?: SortOrder
    w9Submitted?: SortOrder
    defaultContentAccess?: SortOrder
    watermarkContent?: SortOrder
    updatedAt?: SortOrder
    creator?: CreatorOrderByWithRelationInput
  }

  export type CreatorSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creatorId?: string
    AND?: CreatorSettingsWhereInput | CreatorSettingsWhereInput[]
    OR?: CreatorSettingsWhereInput[]
    NOT?: CreatorSettingsWhereInput | CreatorSettingsWhereInput[]
    emailNotifications?: BoolFilter<"CreatorSettings"> | boolean
    smsNotifications?: BoolFilter<"CreatorSettings"> | boolean
    pushNotifications?: BoolFilter<"CreatorSettings"> | boolean
    showPublicProfile?: BoolFilter<"CreatorSettings"> | boolean
    allowDMs?: BoolFilter<"CreatorSettings"> | boolean
    minPayout?: DecimalFilter<"CreatorSettings"> | Decimal | DecimalJsLike | number | string
    payoutFrequency?: EnumPayoutFrequencyFilter<"CreatorSettings"> | $Enums.PayoutFrequency
    taxFormSubmitted?: BoolFilter<"CreatorSettings"> | boolean
    w9Submitted?: BoolFilter<"CreatorSettings"> | boolean
    defaultContentAccess?: EnumContentAccessFilter<"CreatorSettings"> | $Enums.ContentAccess
    watermarkContent?: BoolFilter<"CreatorSettings"> | boolean
    updatedAt?: DateTimeFilter<"CreatorSettings"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
  }, "id" | "creatorId">

  export type CreatorSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    showPublicProfile?: SortOrder
    allowDMs?: SortOrder
    minPayout?: SortOrder
    payoutFrequency?: SortOrder
    taxFormSubmitted?: SortOrder
    w9Submitted?: SortOrder
    defaultContentAccess?: SortOrder
    watermarkContent?: SortOrder
    updatedAt?: SortOrder
    _count?: CreatorSettingsCountOrderByAggregateInput
    _avg?: CreatorSettingsAvgOrderByAggregateInput
    _max?: CreatorSettingsMaxOrderByAggregateInput
    _min?: CreatorSettingsMinOrderByAggregateInput
    _sum?: CreatorSettingsSumOrderByAggregateInput
  }

  export type CreatorSettingsScalarWhereWithAggregatesInput = {
    AND?: CreatorSettingsScalarWhereWithAggregatesInput | CreatorSettingsScalarWhereWithAggregatesInput[]
    OR?: CreatorSettingsScalarWhereWithAggregatesInput[]
    NOT?: CreatorSettingsScalarWhereWithAggregatesInput | CreatorSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreatorSettings"> | string
    creatorId?: StringWithAggregatesFilter<"CreatorSettings"> | string
    emailNotifications?: BoolWithAggregatesFilter<"CreatorSettings"> | boolean
    smsNotifications?: BoolWithAggregatesFilter<"CreatorSettings"> | boolean
    pushNotifications?: BoolWithAggregatesFilter<"CreatorSettings"> | boolean
    showPublicProfile?: BoolWithAggregatesFilter<"CreatorSettings"> | boolean
    allowDMs?: BoolWithAggregatesFilter<"CreatorSettings"> | boolean
    minPayout?: DecimalWithAggregatesFilter<"CreatorSettings"> | Decimal | DecimalJsLike | number | string
    payoutFrequency?: EnumPayoutFrequencyWithAggregatesFilter<"CreatorSettings"> | $Enums.PayoutFrequency
    taxFormSubmitted?: BoolWithAggregatesFilter<"CreatorSettings"> | boolean
    w9Submitted?: BoolWithAggregatesFilter<"CreatorSettings"> | boolean
    defaultContentAccess?: EnumContentAccessWithAggregatesFilter<"CreatorSettings"> | $Enums.ContentAccess
    watermarkContent?: BoolWithAggregatesFilter<"CreatorSettings"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"CreatorSettings"> | Date | string
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    creatorId?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    interval?: EnumBillingIntervalFilter<"SubscriptionPlan"> | $Enums.BillingInterval
    intervalCount?: IntFilter<"SubscriptionPlan"> | number
    features?: JsonFilter<"SubscriptionPlan">
    maxDownloads?: IntNullableFilter<"SubscriptionPlan"> | number | null
    earlyAccess?: BoolFilter<"SubscriptionPlan"> | boolean
    exclusiveContent?: BoolFilter<"SubscriptionPlan"> | boolean
    trialPeriodDays?: IntNullableFilter<"SubscriptionPlan"> | number | null
    stripePriceId?: StringNullableFilter<"SubscriptionPlan"> | string | null
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    subscriptions?: SubscriptionListRelationFilter
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    features?: SortOrder
    maxDownloads?: SortOrderInput | SortOrder
    earlyAccess?: SortOrder
    exclusiveContent?: SortOrder
    trialPeriodDays?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: CreatorOrderByWithRelationInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePriceId?: string
    creatorId_name?: SubscriptionPlanCreatorIdNameCompoundUniqueInput
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    creatorId?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    interval?: EnumBillingIntervalFilter<"SubscriptionPlan"> | $Enums.BillingInterval
    intervalCount?: IntFilter<"SubscriptionPlan"> | number
    features?: JsonFilter<"SubscriptionPlan">
    maxDownloads?: IntNullableFilter<"SubscriptionPlan"> | number | null
    earlyAccess?: BoolFilter<"SubscriptionPlan"> | boolean
    exclusiveContent?: BoolFilter<"SubscriptionPlan"> | boolean
    trialPeriodDays?: IntNullableFilter<"SubscriptionPlan"> | number | null
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    subscriptions?: SubscriptionListRelationFilter
  }, "id" | "stripePriceId" | "creatorId_name">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    features?: SortOrder
    maxDownloads?: SortOrderInput | SortOrder
    earlyAccess?: SortOrder
    exclusiveContent?: SortOrder
    trialPeriodDays?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    creatorId?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    description?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    price?: DecimalWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    interval?: EnumBillingIntervalWithAggregatesFilter<"SubscriptionPlan"> | $Enums.BillingInterval
    intervalCount?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    features?: JsonWithAggregatesFilter<"SubscriptionPlan">
    maxDownloads?: IntNullableWithAggregatesFilter<"SubscriptionPlan"> | number | null
    earlyAccess?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    exclusiveContent?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    trialPeriodDays?: IntNullableWithAggregatesFilter<"SubscriptionPlan"> | number | null
    stripePriceId?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    isActive?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    creatorId?: StringFilter<"Product"> | string
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    title?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Product"> | string
    contentUrl?: StringNullableFilter<"Product"> | string | null
    thumbnailUrl?: StringNullableFilter<"Product"> | string | null
    previewUrl?: StringNullableFilter<"Product"> | string | null
    accessType?: EnumContentAccessFilter<"Product"> | $Enums.ContentAccess
    requiresSubscription?: BoolFilter<"Product"> | boolean
    tags?: StringNullableListFilter<"Product">
    isPublished?: BoolFilter<"Product"> | boolean
    publishedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    viewCount?: IntFilter<"Product"> | number
    purchaseCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    purchases?: PurchaseListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrder
    contentUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    previewUrl?: SortOrderInput | SortOrder
    accessType?: SortOrder
    requiresSubscription?: SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    purchaseCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: CreatorOrderByWithRelationInput
    purchases?: PurchaseOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    creatorId?: StringFilter<"Product"> | string
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    title?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Product"> | string
    contentUrl?: StringNullableFilter<"Product"> | string | null
    thumbnailUrl?: StringNullableFilter<"Product"> | string | null
    previewUrl?: StringNullableFilter<"Product"> | string | null
    accessType?: EnumContentAccessFilter<"Product"> | $Enums.ContentAccess
    requiresSubscription?: BoolFilter<"Product"> | boolean
    tags?: StringNullableListFilter<"Product">
    isPublished?: BoolFilter<"Product"> | boolean
    publishedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    viewCount?: IntFilter<"Product"> | number
    purchaseCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    purchases?: PurchaseListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrder
    contentUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    previewUrl?: SortOrderInput | SortOrder
    accessType?: SortOrder
    requiresSubscription?: SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    purchaseCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    creatorId?: StringWithAggregatesFilter<"Product"> | string
    type?: EnumProductTypeWithAggregatesFilter<"Product"> | $Enums.ProductType
    title?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"Product"> | string
    contentUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    previewUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    accessType?: EnumContentAccessWithAggregatesFilter<"Product"> | $Enums.ContentAccess
    requiresSubscription?: BoolWithAggregatesFilter<"Product"> | boolean
    tags?: StringNullableListFilter<"Product">
    isPublished?: BoolWithAggregatesFilter<"Product"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    viewCount?: IntWithAggregatesFilter<"Product"> | number
    purchaseCount?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type FanWhereInput = {
    AND?: FanWhereInput | FanWhereInput[]
    OR?: FanWhereInput[]
    NOT?: FanWhereInput | FanWhereInput[]
    id?: StringFilter<"Fan"> | string
    email?: StringFilter<"Fan"> | string
    username?: StringNullableFilter<"Fan"> | string | null
    displayName?: StringNullableFilter<"Fan"> | string | null
    avatar?: StringNullableFilter<"Fan"> | string | null
    stripeCustomerId?: StringNullableFilter<"Fan"> | string | null
    emailVerified?: BoolFilter<"Fan"> | boolean
    phoneNumber?: StringNullableFilter<"Fan"> | string | null
    phoneVerified?: BoolFilter<"Fan"> | boolean
    locale?: StringFilter<"Fan"> | string
    timezone?: StringFilter<"Fan"> | string
    createdAt?: DateTimeFilter<"Fan"> | Date | string
    updatedAt?: DateTimeFilter<"Fan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
    purchases?: PurchaseListRelationFilter
    transactions?: TransactionListRelationFilter
    fanRelations?: FanRelationListRelationFilter
    campaignRecipients?: CampaignRecipientListRelationFilter
  }

  export type FanOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    fanRelations?: FanRelationOrderByRelationAggregateInput
    campaignRecipients?: CampaignRecipientOrderByRelationAggregateInput
  }

  export type FanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    stripeCustomerId?: string
    AND?: FanWhereInput | FanWhereInput[]
    OR?: FanWhereInput[]
    NOT?: FanWhereInput | FanWhereInput[]
    displayName?: StringNullableFilter<"Fan"> | string | null
    avatar?: StringNullableFilter<"Fan"> | string | null
    emailVerified?: BoolFilter<"Fan"> | boolean
    phoneNumber?: StringNullableFilter<"Fan"> | string | null
    phoneVerified?: BoolFilter<"Fan"> | boolean
    locale?: StringFilter<"Fan"> | string
    timezone?: StringFilter<"Fan"> | string
    createdAt?: DateTimeFilter<"Fan"> | Date | string
    updatedAt?: DateTimeFilter<"Fan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
    purchases?: PurchaseListRelationFilter
    transactions?: TransactionListRelationFilter
    fanRelations?: FanRelationListRelationFilter
    campaignRecipients?: CampaignRecipientListRelationFilter
  }, "id" | "email" | "username" | "stripeCustomerId">

  export type FanOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FanCountOrderByAggregateInput
    _max?: FanMaxOrderByAggregateInput
    _min?: FanMinOrderByAggregateInput
  }

  export type FanScalarWhereWithAggregatesInput = {
    AND?: FanScalarWhereWithAggregatesInput | FanScalarWhereWithAggregatesInput[]
    OR?: FanScalarWhereWithAggregatesInput[]
    NOT?: FanScalarWhereWithAggregatesInput | FanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fan"> | string
    email?: StringWithAggregatesFilter<"Fan"> | string
    username?: StringNullableWithAggregatesFilter<"Fan"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"Fan"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Fan"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Fan"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"Fan"> | boolean
    phoneNumber?: StringNullableWithAggregatesFilter<"Fan"> | string | null
    phoneVerified?: BoolWithAggregatesFilter<"Fan"> | boolean
    locale?: StringWithAggregatesFilter<"Fan"> | string
    timezone?: StringWithAggregatesFilter<"Fan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Fan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fan"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    fanId?: StringFilter<"Subscription"> | string
    creatorId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    totalSpent?: DecimalFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    fan?: XOR<FanRelationFilter, FanWhereInput>
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    fanId?: SortOrder
    creatorId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    totalSpent?: SortOrder
    renewalCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fan?: FanOrderByWithRelationInput
    creator?: CreatorOrderByWithRelationInput
    plan?: SubscriptionPlanOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeSubscriptionId?: string
    fanId_creatorId_planId?: SubscriptionFanIdCreatorIdPlanIdCompoundUniqueInput
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    fanId?: StringFilter<"Subscription"> | string
    creatorId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    totalSpent?: DecimalFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    fan?: XOR<FanRelationFilter, FanWhereInput>
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
  }, "id" | "stripeSubscriptionId" | "fanId_creatorId_planId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    fanId?: SortOrder
    creatorId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    totalSpent?: SortOrder
    renewalCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    fanId?: StringWithAggregatesFilter<"Subscription"> | string
    creatorId?: StringWithAggregatesFilter<"Subscription"> | string
    planId?: StringWithAggregatesFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    totalSpent?: DecimalWithAggregatesFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    renewalCount?: IntWithAggregatesFilter<"Subscription"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    fanId?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    amount?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Purchase"> | string
    status?: EnumPurchaseStatusFilter<"Purchase"> | $Enums.PurchaseStatus
    stripePaymentIntentId?: StringNullableFilter<"Purchase"> | string | null
    downloadCount?: IntFilter<"Purchase"> | number
    lastDownloadAt?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    fan?: XOR<FanRelationFilter, FanWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    transaction?: XOR<TransactionNullableRelationFilter, TransactionWhereInput> | null
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    fanId?: SortOrder
    productId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    downloadCount?: SortOrder
    lastDownloadAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    fan?: FanOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentIntentId?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    fanId?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    amount?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Purchase"> | string
    status?: EnumPurchaseStatusFilter<"Purchase"> | $Enums.PurchaseStatus
    downloadCount?: IntFilter<"Purchase"> | number
    lastDownloadAt?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    fan?: XOR<FanRelationFilter, FanWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    transaction?: XOR<TransactionNullableRelationFilter, TransactionWhereInput> | null
  }, "id" | "stripePaymentIntentId">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    fanId?: SortOrder
    productId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    downloadCount?: SortOrder
    lastDownloadAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    fanId?: StringWithAggregatesFilter<"Purchase"> | string
    productId?: StringWithAggregatesFilter<"Purchase"> | string
    amount?: DecimalWithAggregatesFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Purchase"> | string
    status?: EnumPurchaseStatusWithAggregatesFilter<"Purchase"> | $Enums.PurchaseStatus
    stripePaymentIntentId?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    downloadCount?: IntWithAggregatesFilter<"Purchase"> | number
    lastDownloadAt?: DateTimeNullableWithAggregatesFilter<"Purchase"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    creatorId?: StringFilter<"Transaction"> | string
    fanId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    platformFee?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    subscriptionId?: StringNullableFilter<"Transaction"> | string | null
    purchaseId?: StringNullableFilter<"Transaction"> | string | null
    payoutId?: StringNullableFilter<"Transaction"> | string | null
    stripeTransferId?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    fan?: XOR<FanNullableRelationFilter, FanWhereInput> | null
    purchase?: XOR<PurchaseNullableRelationFilter, PurchaseWhereInput> | null
    payout?: XOR<PayoutNullableRelationFilter, PayoutWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    fanId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    platformFee?: SortOrder
    platformFeeRate?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    purchaseId?: SortOrderInput | SortOrder
    payoutId?: SortOrderInput | SortOrder
    stripeTransferId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    creator?: CreatorOrderByWithRelationInput
    fan?: FanOrderByWithRelationInput
    purchase?: PurchaseOrderByWithRelationInput
    payout?: PayoutOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    purchaseId?: string
    stripeTransferId?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    creatorId?: StringFilter<"Transaction"> | string
    fanId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    platformFee?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    subscriptionId?: StringNullableFilter<"Transaction"> | string | null
    payoutId?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    fan?: XOR<FanNullableRelationFilter, FanWhereInput> | null
    purchase?: XOR<PurchaseNullableRelationFilter, PurchaseWhereInput> | null
    payout?: XOR<PayoutNullableRelationFilter, PayoutWhereInput> | null
  }, "id" | "purchaseId" | "stripeTransferId">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    fanId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    platformFee?: SortOrder
    platformFeeRate?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    purchaseId?: SortOrderInput | SortOrder
    payoutId?: SortOrderInput | SortOrder
    stripeTransferId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    creatorId?: StringWithAggregatesFilter<"Transaction"> | string
    fanId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    platformFee?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    subscriptionId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    purchaseId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    payoutId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    stripeTransferId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Transaction">
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type PayoutWhereInput = {
    AND?: PayoutWhereInput | PayoutWhereInput[]
    OR?: PayoutWhereInput[]
    NOT?: PayoutWhereInput | PayoutWhereInput[]
    id?: StringFilter<"Payout"> | string
    creatorId?: StringFilter<"Payout"> | string
    amount?: DecimalFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payout"> | string
    status?: EnumPayoutStatusFilter<"Payout"> | $Enums.PayoutStatus
    method?: EnumPayoutMethodFilter<"Payout"> | $Enums.PayoutMethod
    destination?: StringNullableFilter<"Payout"> | string | null
    stripePayoutId?: StringNullableFilter<"Payout"> | string | null
    processedAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
    failureReason?: StringNullableFilter<"Payout"> | string | null
    createdAt?: DateTimeFilter<"Payout"> | Date | string
    updatedAt?: DateTimeFilter<"Payout"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type PayoutOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    destination?: SortOrderInput | SortOrder
    stripePayoutId?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: CreatorOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type PayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePayoutId?: string
    AND?: PayoutWhereInput | PayoutWhereInput[]
    OR?: PayoutWhereInput[]
    NOT?: PayoutWhereInput | PayoutWhereInput[]
    creatorId?: StringFilter<"Payout"> | string
    amount?: DecimalFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payout"> | string
    status?: EnumPayoutStatusFilter<"Payout"> | $Enums.PayoutStatus
    method?: EnumPayoutMethodFilter<"Payout"> | $Enums.PayoutMethod
    destination?: StringNullableFilter<"Payout"> | string | null
    processedAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
    failureReason?: StringNullableFilter<"Payout"> | string | null
    createdAt?: DateTimeFilter<"Payout"> | Date | string
    updatedAt?: DateTimeFilter<"Payout"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id" | "stripePayoutId">

  export type PayoutOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    destination?: SortOrderInput | SortOrder
    stripePayoutId?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayoutCountOrderByAggregateInput
    _avg?: PayoutAvgOrderByAggregateInput
    _max?: PayoutMaxOrderByAggregateInput
    _min?: PayoutMinOrderByAggregateInput
    _sum?: PayoutSumOrderByAggregateInput
  }

  export type PayoutScalarWhereWithAggregatesInput = {
    AND?: PayoutScalarWhereWithAggregatesInput | PayoutScalarWhereWithAggregatesInput[]
    OR?: PayoutScalarWhereWithAggregatesInput[]
    NOT?: PayoutScalarWhereWithAggregatesInput | PayoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payout"> | string
    creatorId?: StringWithAggregatesFilter<"Payout"> | string
    amount?: DecimalWithAggregatesFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payout"> | string
    status?: EnumPayoutStatusWithAggregatesFilter<"Payout"> | $Enums.PayoutStatus
    method?: EnumPayoutMethodWithAggregatesFilter<"Payout"> | $Enums.PayoutMethod
    destination?: StringNullableWithAggregatesFilter<"Payout"> | string | null
    stripePayoutId?: StringNullableWithAggregatesFilter<"Payout"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payout"> | Date | string | null
    failureReason?: StringNullableWithAggregatesFilter<"Payout"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payout"> | Date | string
  }

  export type AnalyticsWhereInput = {
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    id?: StringFilter<"Analytics"> | string
    creatorId?: StringFilter<"Analytics"> | string
    date?: DateTimeFilter<"Analytics"> | Date | string
    revenue?: DecimalFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: DecimalFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    productRevenue?: DecimalFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    newSubscribers?: IntFilter<"Analytics"> | number
    churned?: IntFilter<"Analytics"> | number
    activeSubscribers?: IntFilter<"Analytics"> | number
    pageViews?: IntFilter<"Analytics"> | number
    uniqueVisitors?: IntFilter<"Analytics"> | number
    contentViews?: IntFilter<"Analytics"> | number
    conversionRate?: DecimalNullableFilter<"Analytics"> | Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: DecimalNullableFilter<"Analytics"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
  }

  export type AnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    subscriptionRevenue?: SortOrder
    productRevenue?: SortOrder
    newSubscribers?: SortOrder
    churned?: SortOrder
    activeSubscribers?: SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    contentViews?: SortOrder
    conversionRate?: SortOrderInput | SortOrder
    avgOrderValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    creator?: CreatorOrderByWithRelationInput
  }

  export type AnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creatorId_date?: AnalyticsCreatorIdDateCompoundUniqueInput
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    creatorId?: StringFilter<"Analytics"> | string
    date?: DateTimeFilter<"Analytics"> | Date | string
    revenue?: DecimalFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: DecimalFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    productRevenue?: DecimalFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    newSubscribers?: IntFilter<"Analytics"> | number
    churned?: IntFilter<"Analytics"> | number
    activeSubscribers?: IntFilter<"Analytics"> | number
    pageViews?: IntFilter<"Analytics"> | number
    uniqueVisitors?: IntFilter<"Analytics"> | number
    contentViews?: IntFilter<"Analytics"> | number
    conversionRate?: DecimalNullableFilter<"Analytics"> | Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: DecimalNullableFilter<"Analytics"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
  }, "id" | "creatorId_date">

  export type AnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    subscriptionRevenue?: SortOrder
    productRevenue?: SortOrder
    newSubscribers?: SortOrder
    churned?: SortOrder
    activeSubscribers?: SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    contentViews?: SortOrder
    conversionRate?: SortOrderInput | SortOrder
    avgOrderValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsCountOrderByAggregateInput
    _avg?: AnalyticsAvgOrderByAggregateInput
    _max?: AnalyticsMaxOrderByAggregateInput
    _min?: AnalyticsMinOrderByAggregateInput
    _sum?: AnalyticsSumOrderByAggregateInput
  }

  export type AnalyticsScalarWhereWithAggregatesInput = {
    AND?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    OR?: AnalyticsScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Analytics"> | string
    creatorId?: StringWithAggregatesFilter<"Analytics"> | string
    date?: DateTimeWithAggregatesFilter<"Analytics"> | Date | string
    revenue?: DecimalWithAggregatesFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: DecimalWithAggregatesFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    productRevenue?: DecimalWithAggregatesFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    newSubscribers?: IntWithAggregatesFilter<"Analytics"> | number
    churned?: IntWithAggregatesFilter<"Analytics"> | number
    activeSubscribers?: IntWithAggregatesFilter<"Analytics"> | number
    pageViews?: IntWithAggregatesFilter<"Analytics"> | number
    uniqueVisitors?: IntWithAggregatesFilter<"Analytics"> | number
    contentViews?: IntWithAggregatesFilter<"Analytics"> | number
    conversionRate?: DecimalNullableWithAggregatesFilter<"Analytics"> | Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: DecimalNullableWithAggregatesFilter<"Analytics"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Analytics"> | Date | string
  }

  export type FanRelationWhereInput = {
    AND?: FanRelationWhereInput | FanRelationWhereInput[]
    OR?: FanRelationWhereInput[]
    NOT?: FanRelationWhereInput | FanRelationWhereInput[]
    id?: StringFilter<"FanRelation"> | string
    creatorId?: StringFilter<"FanRelation"> | string
    fanId?: StringFilter<"FanRelation"> | string
    tags?: StringNullableListFilter<"FanRelation">
    notes?: StringNullableFilter<"FanRelation"> | string | null
    engagementScore?: IntFilter<"FanRelation"> | number
    lifetimeValue?: DecimalFilter<"FanRelation"> | Decimal | DecimalJsLike | number | string
    lastInteraction?: DateTimeNullableFilter<"FanRelation"> | Date | string | null
    emailOptIn?: BoolFilter<"FanRelation"> | boolean
    smsOptIn?: BoolFilter<"FanRelation"> | boolean
    createdAt?: DateTimeFilter<"FanRelation"> | Date | string
    updatedAt?: DateTimeFilter<"FanRelation"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    fan?: XOR<FanRelationFilter, FanWhereInput>
  }

  export type FanRelationOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    fanId?: SortOrder
    tags?: SortOrder
    notes?: SortOrderInput | SortOrder
    engagementScore?: SortOrder
    lifetimeValue?: SortOrder
    lastInteraction?: SortOrderInput | SortOrder
    emailOptIn?: SortOrder
    smsOptIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: CreatorOrderByWithRelationInput
    fan?: FanOrderByWithRelationInput
  }

  export type FanRelationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creatorId_fanId?: FanRelationCreatorIdFanIdCompoundUniqueInput
    AND?: FanRelationWhereInput | FanRelationWhereInput[]
    OR?: FanRelationWhereInput[]
    NOT?: FanRelationWhereInput | FanRelationWhereInput[]
    creatorId?: StringFilter<"FanRelation"> | string
    fanId?: StringFilter<"FanRelation"> | string
    tags?: StringNullableListFilter<"FanRelation">
    notes?: StringNullableFilter<"FanRelation"> | string | null
    engagementScore?: IntFilter<"FanRelation"> | number
    lifetimeValue?: DecimalFilter<"FanRelation"> | Decimal | DecimalJsLike | number | string
    lastInteraction?: DateTimeNullableFilter<"FanRelation"> | Date | string | null
    emailOptIn?: BoolFilter<"FanRelation"> | boolean
    smsOptIn?: BoolFilter<"FanRelation"> | boolean
    createdAt?: DateTimeFilter<"FanRelation"> | Date | string
    updatedAt?: DateTimeFilter<"FanRelation"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    fan?: XOR<FanRelationFilter, FanWhereInput>
  }, "id" | "creatorId_fanId">

  export type FanRelationOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    fanId?: SortOrder
    tags?: SortOrder
    notes?: SortOrderInput | SortOrder
    engagementScore?: SortOrder
    lifetimeValue?: SortOrder
    lastInteraction?: SortOrderInput | SortOrder
    emailOptIn?: SortOrder
    smsOptIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FanRelationCountOrderByAggregateInput
    _avg?: FanRelationAvgOrderByAggregateInput
    _max?: FanRelationMaxOrderByAggregateInput
    _min?: FanRelationMinOrderByAggregateInput
    _sum?: FanRelationSumOrderByAggregateInput
  }

  export type FanRelationScalarWhereWithAggregatesInput = {
    AND?: FanRelationScalarWhereWithAggregatesInput | FanRelationScalarWhereWithAggregatesInput[]
    OR?: FanRelationScalarWhereWithAggregatesInput[]
    NOT?: FanRelationScalarWhereWithAggregatesInput | FanRelationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FanRelation"> | string
    creatorId?: StringWithAggregatesFilter<"FanRelation"> | string
    fanId?: StringWithAggregatesFilter<"FanRelation"> | string
    tags?: StringNullableListFilter<"FanRelation">
    notes?: StringNullableWithAggregatesFilter<"FanRelation"> | string | null
    engagementScore?: IntWithAggregatesFilter<"FanRelation"> | number
    lifetimeValue?: DecimalWithAggregatesFilter<"FanRelation"> | Decimal | DecimalJsLike | number | string
    lastInteraction?: DateTimeNullableWithAggregatesFilter<"FanRelation"> | Date | string | null
    emailOptIn?: BoolWithAggregatesFilter<"FanRelation"> | boolean
    smsOptIn?: BoolWithAggregatesFilter<"FanRelation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FanRelation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FanRelation"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    creatorId?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    type?: EnumCampaignTypeFilter<"Campaign"> | $Enums.CampaignType
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    subject?: StringNullableFilter<"Campaign"> | string | null
    content?: StringFilter<"Campaign"> | string
    targetTags?: StringNullableListFilter<"Campaign">
    targetSegment?: JsonNullableFilter<"Campaign">
    scheduledFor?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sentCount?: IntFilter<"Campaign"> | number
    openCount?: IntFilter<"Campaign"> | number
    clickCount?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    recipients?: CampaignRecipientListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    targetTags?: SortOrder
    targetSegment?: SortOrderInput | SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: CreatorOrderByWithRelationInput
    recipients?: CampaignRecipientOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    creatorId?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    type?: EnumCampaignTypeFilter<"Campaign"> | $Enums.CampaignType
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    subject?: StringNullableFilter<"Campaign"> | string | null
    content?: StringFilter<"Campaign"> | string
    targetTags?: StringNullableListFilter<"Campaign">
    targetSegment?: JsonNullableFilter<"Campaign">
    scheduledFor?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sentCount?: IntFilter<"Campaign"> | number
    openCount?: IntFilter<"Campaign"> | number
    clickCount?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    recipients?: CampaignRecipientListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    targetTags?: SortOrder
    targetSegment?: SortOrderInput | SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    creatorId?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    type?: EnumCampaignTypeWithAggregatesFilter<"Campaign"> | $Enums.CampaignType
    status?: EnumCampaignStatusWithAggregatesFilter<"Campaign"> | $Enums.CampaignStatus
    subject?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    content?: StringWithAggregatesFilter<"Campaign"> | string
    targetTags?: StringNullableListFilter<"Campaign">
    targetSegment?: JsonNullableWithAggregatesFilter<"Campaign">
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    sentCount?: IntWithAggregatesFilter<"Campaign"> | number
    openCount?: IntWithAggregatesFilter<"Campaign"> | number
    clickCount?: IntWithAggregatesFilter<"Campaign"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type CampaignRecipientWhereInput = {
    AND?: CampaignRecipientWhereInput | CampaignRecipientWhereInput[]
    OR?: CampaignRecipientWhereInput[]
    NOT?: CampaignRecipientWhereInput | CampaignRecipientWhereInput[]
    id?: StringFilter<"CampaignRecipient"> | string
    campaignId?: StringFilter<"CampaignRecipient"> | string
    fanId?: StringFilter<"CampaignRecipient"> | string
    status?: EnumRecipientStatusFilter<"CampaignRecipient"> | $Enums.RecipientStatus
    sentAt?: DateTimeNullableFilter<"CampaignRecipient"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"CampaignRecipient"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"CampaignRecipient"> | Date | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    fan?: XOR<FanRelationFilter, FanWhereInput>
  }

  export type CampaignRecipientOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    fanId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
    fan?: FanOrderByWithRelationInput
  }

  export type CampaignRecipientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_fanId?: CampaignRecipientCampaignIdFanIdCompoundUniqueInput
    AND?: CampaignRecipientWhereInput | CampaignRecipientWhereInput[]
    OR?: CampaignRecipientWhereInput[]
    NOT?: CampaignRecipientWhereInput | CampaignRecipientWhereInput[]
    campaignId?: StringFilter<"CampaignRecipient"> | string
    fanId?: StringFilter<"CampaignRecipient"> | string
    status?: EnumRecipientStatusFilter<"CampaignRecipient"> | $Enums.RecipientStatus
    sentAt?: DateTimeNullableFilter<"CampaignRecipient"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"CampaignRecipient"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"CampaignRecipient"> | Date | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    fan?: XOR<FanRelationFilter, FanWhereInput>
  }, "id" | "campaignId_fanId">

  export type CampaignRecipientOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    fanId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    _count?: CampaignRecipientCountOrderByAggregateInput
    _max?: CampaignRecipientMaxOrderByAggregateInput
    _min?: CampaignRecipientMinOrderByAggregateInput
  }

  export type CampaignRecipientScalarWhereWithAggregatesInput = {
    AND?: CampaignRecipientScalarWhereWithAggregatesInput | CampaignRecipientScalarWhereWithAggregatesInput[]
    OR?: CampaignRecipientScalarWhereWithAggregatesInput[]
    NOT?: CampaignRecipientScalarWhereWithAggregatesInput | CampaignRecipientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignRecipient"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignRecipient"> | string
    fanId?: StringWithAggregatesFilter<"CampaignRecipient"> | string
    status?: EnumRecipientStatusWithAggregatesFilter<"CampaignRecipient"> | $Enums.RecipientStatus
    sentAt?: DateTimeNullableWithAggregatesFilter<"CampaignRecipient"> | Date | string | null
    openedAt?: DateTimeNullableWithAggregatesFilter<"CampaignRecipient"> | Date | string | null
    clickedAt?: DateTimeNullableWithAggregatesFilter<"CampaignRecipient"> | Date | string | null
  }

  export type AppWhereInput = {
    AND?: AppWhereInput | AppWhereInput[]
    OR?: AppWhereInput[]
    NOT?: AppWhereInput | AppWhereInput[]
    id?: StringFilter<"App"> | string
    name?: StringFilter<"App"> | string
    slug?: StringFilter<"App"> | string
    description?: StringFilter<"App"> | string
    icon?: StringNullableFilter<"App"> | string | null
    developer?: StringFilter<"App"> | string
    website?: StringNullableFilter<"App"> | string | null
    category?: EnumAppCategoryFilter<"App"> | $Enums.AppCategory
    pricing?: EnumAppPricingFilter<"App"> | $Enums.AppPricing
    price?: DecimalNullableFilter<"App"> | Decimal | DecimalJsLike | number | string | null
    webhookUrl?: StringNullableFilter<"App"> | string | null
    scopes?: StringNullableListFilter<"App">
    isPublished?: BoolFilter<"App"> | boolean
    isVerified?: BoolFilter<"App"> | boolean
    createdAt?: DateTimeFilter<"App"> | Date | string
    updatedAt?: DateTimeFilter<"App"> | Date | string
    installations?: InstalledAppListRelationFilter
  }

  export type AppOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrderInput | SortOrder
    developer?: SortOrder
    website?: SortOrderInput | SortOrder
    category?: SortOrder
    pricing?: SortOrder
    price?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    scopes?: SortOrder
    isPublished?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    installations?: InstalledAppOrderByRelationAggregateInput
  }

  export type AppWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: AppWhereInput | AppWhereInput[]
    OR?: AppWhereInput[]
    NOT?: AppWhereInput | AppWhereInput[]
    description?: StringFilter<"App"> | string
    icon?: StringNullableFilter<"App"> | string | null
    developer?: StringFilter<"App"> | string
    website?: StringNullableFilter<"App"> | string | null
    category?: EnumAppCategoryFilter<"App"> | $Enums.AppCategory
    pricing?: EnumAppPricingFilter<"App"> | $Enums.AppPricing
    price?: DecimalNullableFilter<"App"> | Decimal | DecimalJsLike | number | string | null
    webhookUrl?: StringNullableFilter<"App"> | string | null
    scopes?: StringNullableListFilter<"App">
    isPublished?: BoolFilter<"App"> | boolean
    isVerified?: BoolFilter<"App"> | boolean
    createdAt?: DateTimeFilter<"App"> | Date | string
    updatedAt?: DateTimeFilter<"App"> | Date | string
    installations?: InstalledAppListRelationFilter
  }, "id" | "name" | "slug">

  export type AppOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrderInput | SortOrder
    developer?: SortOrder
    website?: SortOrderInput | SortOrder
    category?: SortOrder
    pricing?: SortOrder
    price?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    scopes?: SortOrder
    isPublished?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppCountOrderByAggregateInput
    _avg?: AppAvgOrderByAggregateInput
    _max?: AppMaxOrderByAggregateInput
    _min?: AppMinOrderByAggregateInput
    _sum?: AppSumOrderByAggregateInput
  }

  export type AppScalarWhereWithAggregatesInput = {
    AND?: AppScalarWhereWithAggregatesInput | AppScalarWhereWithAggregatesInput[]
    OR?: AppScalarWhereWithAggregatesInput[]
    NOT?: AppScalarWhereWithAggregatesInput | AppScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"App"> | string
    name?: StringWithAggregatesFilter<"App"> | string
    slug?: StringWithAggregatesFilter<"App"> | string
    description?: StringWithAggregatesFilter<"App"> | string
    icon?: StringNullableWithAggregatesFilter<"App"> | string | null
    developer?: StringWithAggregatesFilter<"App"> | string
    website?: StringNullableWithAggregatesFilter<"App"> | string | null
    category?: EnumAppCategoryWithAggregatesFilter<"App"> | $Enums.AppCategory
    pricing?: EnumAppPricingWithAggregatesFilter<"App"> | $Enums.AppPricing
    price?: DecimalNullableWithAggregatesFilter<"App"> | Decimal | DecimalJsLike | number | string | null
    webhookUrl?: StringNullableWithAggregatesFilter<"App"> | string | null
    scopes?: StringNullableListFilter<"App">
    isPublished?: BoolWithAggregatesFilter<"App"> | boolean
    isVerified?: BoolWithAggregatesFilter<"App"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"App"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"App"> | Date | string
  }

  export type InstalledAppWhereInput = {
    AND?: InstalledAppWhereInput | InstalledAppWhereInput[]
    OR?: InstalledAppWhereInput[]
    NOT?: InstalledAppWhereInput | InstalledAppWhereInput[]
    id?: StringFilter<"InstalledApp"> | string
    creatorId?: StringFilter<"InstalledApp"> | string
    appId?: StringFilter<"InstalledApp"> | string
    status?: EnumAppStatusFilter<"InstalledApp"> | $Enums.AppStatus
    settings?: JsonNullableFilter<"InstalledApp">
    billingCycle?: EnumBillingIntervalNullableFilter<"InstalledApp"> | $Enums.BillingInterval | null
    nextBilling?: DateTimeNullableFilter<"InstalledApp"> | Date | string | null
    installedAt?: DateTimeFilter<"InstalledApp"> | Date | string
    uninstalledAt?: DateTimeNullableFilter<"InstalledApp"> | Date | string | null
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    app?: XOR<AppRelationFilter, AppWhereInput>
  }

  export type InstalledAppOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    appId?: SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    billingCycle?: SortOrderInput | SortOrder
    nextBilling?: SortOrderInput | SortOrder
    installedAt?: SortOrder
    uninstalledAt?: SortOrderInput | SortOrder
    creator?: CreatorOrderByWithRelationInput
    app?: AppOrderByWithRelationInput
  }

  export type InstalledAppWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creatorId_appId?: InstalledAppCreatorIdAppIdCompoundUniqueInput
    AND?: InstalledAppWhereInput | InstalledAppWhereInput[]
    OR?: InstalledAppWhereInput[]
    NOT?: InstalledAppWhereInput | InstalledAppWhereInput[]
    creatorId?: StringFilter<"InstalledApp"> | string
    appId?: StringFilter<"InstalledApp"> | string
    status?: EnumAppStatusFilter<"InstalledApp"> | $Enums.AppStatus
    settings?: JsonNullableFilter<"InstalledApp">
    billingCycle?: EnumBillingIntervalNullableFilter<"InstalledApp"> | $Enums.BillingInterval | null
    nextBilling?: DateTimeNullableFilter<"InstalledApp"> | Date | string | null
    installedAt?: DateTimeFilter<"InstalledApp"> | Date | string
    uninstalledAt?: DateTimeNullableFilter<"InstalledApp"> | Date | string | null
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    app?: XOR<AppRelationFilter, AppWhereInput>
  }, "id" | "creatorId_appId">

  export type InstalledAppOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    appId?: SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    billingCycle?: SortOrderInput | SortOrder
    nextBilling?: SortOrderInput | SortOrder
    installedAt?: SortOrder
    uninstalledAt?: SortOrderInput | SortOrder
    _count?: InstalledAppCountOrderByAggregateInput
    _max?: InstalledAppMaxOrderByAggregateInput
    _min?: InstalledAppMinOrderByAggregateInput
  }

  export type InstalledAppScalarWhereWithAggregatesInput = {
    AND?: InstalledAppScalarWhereWithAggregatesInput | InstalledAppScalarWhereWithAggregatesInput[]
    OR?: InstalledAppScalarWhereWithAggregatesInput[]
    NOT?: InstalledAppScalarWhereWithAggregatesInput | InstalledAppScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InstalledApp"> | string
    creatorId?: StringWithAggregatesFilter<"InstalledApp"> | string
    appId?: StringWithAggregatesFilter<"InstalledApp"> | string
    status?: EnumAppStatusWithAggregatesFilter<"InstalledApp"> | $Enums.AppStatus
    settings?: JsonNullableWithAggregatesFilter<"InstalledApp">
    billingCycle?: EnumBillingIntervalNullableWithAggregatesFilter<"InstalledApp"> | $Enums.BillingInterval | null
    nextBilling?: DateTimeNullableWithAggregatesFilter<"InstalledApp"> | Date | string | null
    installedAt?: DateTimeWithAggregatesFilter<"InstalledApp"> | Date | string
    uninstalledAt?: DateTimeNullableWithAggregatesFilter<"InstalledApp"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    creatorId?: StringNullableFilter<"AuditLog"> | string | null
    actorId?: StringFilter<"AuditLog"> | string
    actorType?: EnumActorTypeFilter<"AuditLog"> | $Enums.ActorType
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    creator?: XOR<CreatorNullableRelationFilter, CreatorWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    actorId?: SortOrder
    actorType?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    creator?: CreatorOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    creatorId?: StringNullableFilter<"AuditLog"> | string | null
    actorId?: StringFilter<"AuditLog"> | string
    actorType?: EnumActorTypeFilter<"AuditLog"> | $Enums.ActorType
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    creator?: XOR<CreatorNullableRelationFilter, CreatorWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    actorId?: SortOrder
    actorType?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    creatorId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    actorId?: StringWithAggregatesFilter<"AuditLog"> | string
    actorType?: EnumActorTypeWithAggregatesFilter<"AuditLog"> | $Enums.ActorType
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type LedgerAccountWhereInput = {
    AND?: LedgerAccountWhereInput | LedgerAccountWhereInput[]
    OR?: LedgerAccountWhereInput[]
    NOT?: LedgerAccountWhereInput | LedgerAccountWhereInput[]
    id?: StringFilter<"LedgerAccount"> | string
    tenantId?: StringFilter<"LedgerAccount"> | string
    type?: EnumLedgerAccountTypeFilter<"LedgerAccount"> | $Enums.LedgerAccountType
    currency?: StringFilter<"LedgerAccount"> | string
    ownerId?: StringNullableFilter<"LedgerAccount"> | string | null
    balance?: BigIntFilter<"LedgerAccount"> | bigint | number
    createdAt?: DateTimeFilter<"LedgerAccount"> | Date | string
    updatedAt?: DateTimeFilter<"LedgerAccount"> | Date | string
    entries?: LedgerEntryListRelationFilter
  }

  export type LedgerAccountOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entries?: LedgerEntryOrderByRelationAggregateInput
  }

  export type LedgerAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_type_currency_ownerId?: LedgerAccountTenantIdTypeCurrencyOwnerIdCompoundUniqueInput
    AND?: LedgerAccountWhereInput | LedgerAccountWhereInput[]
    OR?: LedgerAccountWhereInput[]
    NOT?: LedgerAccountWhereInput | LedgerAccountWhereInput[]
    tenantId?: StringFilter<"LedgerAccount"> | string
    type?: EnumLedgerAccountTypeFilter<"LedgerAccount"> | $Enums.LedgerAccountType
    currency?: StringFilter<"LedgerAccount"> | string
    ownerId?: StringNullableFilter<"LedgerAccount"> | string | null
    balance?: BigIntFilter<"LedgerAccount"> | bigint | number
    createdAt?: DateTimeFilter<"LedgerAccount"> | Date | string
    updatedAt?: DateTimeFilter<"LedgerAccount"> | Date | string
    entries?: LedgerEntryListRelationFilter
  }, "id" | "tenantId_type_currency_ownerId">

  export type LedgerAccountOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LedgerAccountCountOrderByAggregateInput
    _avg?: LedgerAccountAvgOrderByAggregateInput
    _max?: LedgerAccountMaxOrderByAggregateInput
    _min?: LedgerAccountMinOrderByAggregateInput
    _sum?: LedgerAccountSumOrderByAggregateInput
  }

  export type LedgerAccountScalarWhereWithAggregatesInput = {
    AND?: LedgerAccountScalarWhereWithAggregatesInput | LedgerAccountScalarWhereWithAggregatesInput[]
    OR?: LedgerAccountScalarWhereWithAggregatesInput[]
    NOT?: LedgerAccountScalarWhereWithAggregatesInput | LedgerAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LedgerAccount"> | string
    tenantId?: StringWithAggregatesFilter<"LedgerAccount"> | string
    type?: EnumLedgerAccountTypeWithAggregatesFilter<"LedgerAccount"> | $Enums.LedgerAccountType
    currency?: StringWithAggregatesFilter<"LedgerAccount"> | string
    ownerId?: StringNullableWithAggregatesFilter<"LedgerAccount"> | string | null
    balance?: BigIntWithAggregatesFilter<"LedgerAccount"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"LedgerAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LedgerAccount"> | Date | string
  }

  export type LedgerTransactionWhereInput = {
    AND?: LedgerTransactionWhereInput | LedgerTransactionWhereInput[]
    OR?: LedgerTransactionWhereInput[]
    NOT?: LedgerTransactionWhereInput | LedgerTransactionWhereInput[]
    id?: StringFilter<"LedgerTransaction"> | string
    tenantId?: StringFilter<"LedgerTransaction"> | string
    kind?: EnumLedgerTransactionKindFilter<"LedgerTransaction"> | $Enums.LedgerTransactionKind
    currency?: StringFilter<"LedgerTransaction"> | string
    occurredAt?: DateTimeFilter<"LedgerTransaction"> | Date | string
    memo?: StringNullableFilter<"LedgerTransaction"> | string | null
    source?: StringNullableFilter<"LedgerTransaction"> | string | null
    extRef?: StringNullableFilter<"LedgerTransaction"> | string | null
    stripeEventId?: StringNullableFilter<"LedgerTransaction"> | string | null
    idempotencyKey?: StringNullableFilter<"LedgerTransaction"> | string | null
    reversedBy?: StringNullableFilter<"LedgerTransaction"> | string | null
    createdAt?: DateTimeFilter<"LedgerTransaction"> | Date | string
    entries?: LedgerEntryListRelationFilter
  }

  export type LedgerTransactionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kind?: SortOrder
    currency?: SortOrder
    occurredAt?: SortOrder
    memo?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    extRef?: SortOrderInput | SortOrder
    stripeEventId?: SortOrderInput | SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    reversedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    entries?: LedgerEntryOrderByRelationAggregateInput
  }

  export type LedgerTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeEventId?: string
    idempotencyKey?: string
    AND?: LedgerTransactionWhereInput | LedgerTransactionWhereInput[]
    OR?: LedgerTransactionWhereInput[]
    NOT?: LedgerTransactionWhereInput | LedgerTransactionWhereInput[]
    tenantId?: StringFilter<"LedgerTransaction"> | string
    kind?: EnumLedgerTransactionKindFilter<"LedgerTransaction"> | $Enums.LedgerTransactionKind
    currency?: StringFilter<"LedgerTransaction"> | string
    occurredAt?: DateTimeFilter<"LedgerTransaction"> | Date | string
    memo?: StringNullableFilter<"LedgerTransaction"> | string | null
    source?: StringNullableFilter<"LedgerTransaction"> | string | null
    extRef?: StringNullableFilter<"LedgerTransaction"> | string | null
    reversedBy?: StringNullableFilter<"LedgerTransaction"> | string | null
    createdAt?: DateTimeFilter<"LedgerTransaction"> | Date | string
    entries?: LedgerEntryListRelationFilter
  }, "id" | "stripeEventId" | "idempotencyKey">

  export type LedgerTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kind?: SortOrder
    currency?: SortOrder
    occurredAt?: SortOrder
    memo?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    extRef?: SortOrderInput | SortOrder
    stripeEventId?: SortOrderInput | SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    reversedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LedgerTransactionCountOrderByAggregateInput
    _max?: LedgerTransactionMaxOrderByAggregateInput
    _min?: LedgerTransactionMinOrderByAggregateInput
  }

  export type LedgerTransactionScalarWhereWithAggregatesInput = {
    AND?: LedgerTransactionScalarWhereWithAggregatesInput | LedgerTransactionScalarWhereWithAggregatesInput[]
    OR?: LedgerTransactionScalarWhereWithAggregatesInput[]
    NOT?: LedgerTransactionScalarWhereWithAggregatesInput | LedgerTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LedgerTransaction"> | string
    tenantId?: StringWithAggregatesFilter<"LedgerTransaction"> | string
    kind?: EnumLedgerTransactionKindWithAggregatesFilter<"LedgerTransaction"> | $Enums.LedgerTransactionKind
    currency?: StringWithAggregatesFilter<"LedgerTransaction"> | string
    occurredAt?: DateTimeWithAggregatesFilter<"LedgerTransaction"> | Date | string
    memo?: StringNullableWithAggregatesFilter<"LedgerTransaction"> | string | null
    source?: StringNullableWithAggregatesFilter<"LedgerTransaction"> | string | null
    extRef?: StringNullableWithAggregatesFilter<"LedgerTransaction"> | string | null
    stripeEventId?: StringNullableWithAggregatesFilter<"LedgerTransaction"> | string | null
    idempotencyKey?: StringNullableWithAggregatesFilter<"LedgerTransaction"> | string | null
    reversedBy?: StringNullableWithAggregatesFilter<"LedgerTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LedgerTransaction"> | Date | string
  }

  export type LedgerEntryWhereInput = {
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    id?: StringFilter<"LedgerEntry"> | string
    txId?: StringFilter<"LedgerEntry"> | string
    accountId?: StringFilter<"LedgerEntry"> | string
    direction?: EnumLedgerDirectionFilter<"LedgerEntry"> | $Enums.LedgerDirection
    amountCents?: BigIntFilter<"LedgerEntry"> | bigint | number
    currency?: StringFilter<"LedgerEntry"> | string
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    transaction?: XOR<LedgerTransactionRelationFilter, LedgerTransactionWhereInput>
    account?: XOR<LedgerAccountRelationFilter, LedgerAccountWhereInput>
  }

  export type LedgerEntryOrderByWithRelationInput = {
    id?: SortOrder
    txId?: SortOrder
    accountId?: SortOrder
    direction?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    transaction?: LedgerTransactionOrderByWithRelationInput
    account?: LedgerAccountOrderByWithRelationInput
  }

  export type LedgerEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    txId?: StringFilter<"LedgerEntry"> | string
    accountId?: StringFilter<"LedgerEntry"> | string
    direction?: EnumLedgerDirectionFilter<"LedgerEntry"> | $Enums.LedgerDirection
    amountCents?: BigIntFilter<"LedgerEntry"> | bigint | number
    currency?: StringFilter<"LedgerEntry"> | string
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    transaction?: XOR<LedgerTransactionRelationFilter, LedgerTransactionWhereInput>
    account?: XOR<LedgerAccountRelationFilter, LedgerAccountWhereInput>
  }, "id">

  export type LedgerEntryOrderByWithAggregationInput = {
    id?: SortOrder
    txId?: SortOrder
    accountId?: SortOrder
    direction?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    _count?: LedgerEntryCountOrderByAggregateInput
    _avg?: LedgerEntryAvgOrderByAggregateInput
    _max?: LedgerEntryMaxOrderByAggregateInput
    _min?: LedgerEntryMinOrderByAggregateInput
    _sum?: LedgerEntrySumOrderByAggregateInput
  }

  export type LedgerEntryScalarWhereWithAggregatesInput = {
    AND?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    OR?: LedgerEntryScalarWhereWithAggregatesInput[]
    NOT?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LedgerEntry"> | string
    txId?: StringWithAggregatesFilter<"LedgerEntry"> | string
    accountId?: StringWithAggregatesFilter<"LedgerEntry"> | string
    direction?: EnumLedgerDirectionWithAggregatesFilter<"LedgerEntry"> | $Enums.LedgerDirection
    amountCents?: BigIntWithAggregatesFilter<"LedgerEntry"> | bigint | number
    currency?: StringWithAggregatesFilter<"LedgerEntry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LedgerEntry"> | Date | string
  }

  export type CommissionCapMonthlyWhereInput = {
    AND?: CommissionCapMonthlyWhereInput | CommissionCapMonthlyWhereInput[]
    OR?: CommissionCapMonthlyWhereInput[]
    NOT?: CommissionCapMonthlyWhereInput | CommissionCapMonthlyWhereInput[]
    id?: StringFilter<"CommissionCapMonthly"> | string
    creatorId?: StringFilter<"CommissionCapMonthly"> | string
    yearMonth?: StringFilter<"CommissionCapMonthly"> | string
    currency?: StringFilter<"CommissionCapMonthly"> | string
    capCents?: BigIntFilter<"CommissionCapMonthly"> | bigint | number
    appliedCents?: BigIntFilter<"CommissionCapMonthly"> | bigint | number
    createdAt?: DateTimeFilter<"CommissionCapMonthly"> | Date | string
    updatedAt?: DateTimeFilter<"CommissionCapMonthly"> | Date | string
  }

  export type CommissionCapMonthlyOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    yearMonth?: SortOrder
    currency?: SortOrder
    capCents?: SortOrder
    appliedCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionCapMonthlyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creatorId_yearMonth_currency?: CommissionCapMonthlyCreatorIdYearMonthCurrencyCompoundUniqueInput
    AND?: CommissionCapMonthlyWhereInput | CommissionCapMonthlyWhereInput[]
    OR?: CommissionCapMonthlyWhereInput[]
    NOT?: CommissionCapMonthlyWhereInput | CommissionCapMonthlyWhereInput[]
    creatorId?: StringFilter<"CommissionCapMonthly"> | string
    yearMonth?: StringFilter<"CommissionCapMonthly"> | string
    currency?: StringFilter<"CommissionCapMonthly"> | string
    capCents?: BigIntFilter<"CommissionCapMonthly"> | bigint | number
    appliedCents?: BigIntFilter<"CommissionCapMonthly"> | bigint | number
    createdAt?: DateTimeFilter<"CommissionCapMonthly"> | Date | string
    updatedAt?: DateTimeFilter<"CommissionCapMonthly"> | Date | string
  }, "id" | "creatorId_yearMonth_currency">

  export type CommissionCapMonthlyOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    yearMonth?: SortOrder
    currency?: SortOrder
    capCents?: SortOrder
    appliedCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommissionCapMonthlyCountOrderByAggregateInput
    _avg?: CommissionCapMonthlyAvgOrderByAggregateInput
    _max?: CommissionCapMonthlyMaxOrderByAggregateInput
    _min?: CommissionCapMonthlyMinOrderByAggregateInput
    _sum?: CommissionCapMonthlySumOrderByAggregateInput
  }

  export type CommissionCapMonthlyScalarWhereWithAggregatesInput = {
    AND?: CommissionCapMonthlyScalarWhereWithAggregatesInput | CommissionCapMonthlyScalarWhereWithAggregatesInput[]
    OR?: CommissionCapMonthlyScalarWhereWithAggregatesInput[]
    NOT?: CommissionCapMonthlyScalarWhereWithAggregatesInput | CommissionCapMonthlyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommissionCapMonthly"> | string
    creatorId?: StringWithAggregatesFilter<"CommissionCapMonthly"> | string
    yearMonth?: StringWithAggregatesFilter<"CommissionCapMonthly"> | string
    currency?: StringWithAggregatesFilter<"CommissionCapMonthly"> | string
    capCents?: BigIntWithAggregatesFilter<"CommissionCapMonthly"> | bigint | number
    appliedCents?: BigIntWithAggregatesFilter<"CommissionCapMonthly"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"CommissionCapMonthly"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommissionCapMonthly"> | Date | string
  }

  export type ExternalEarningsSourceWhereInput = {
    AND?: ExternalEarningsSourceWhereInput | ExternalEarningsSourceWhereInput[]
    OR?: ExternalEarningsSourceWhereInput[]
    NOT?: ExternalEarningsSourceWhereInput | ExternalEarningsSourceWhereInput[]
    id?: StringFilter<"ExternalEarningsSource"> | string
    creatorId?: StringFilter<"ExternalEarningsSource"> | string
    platform?: EnumExternalPlatformFilter<"ExternalEarningsSource"> | $Enums.ExternalPlatform
    externalHandle?: StringFilter<"ExternalEarningsSource"> | string
    currency?: StringFilter<"ExternalEarningsSource"> | string
    connectedAt?: DateTimeFilter<"ExternalEarningsSource"> | Date | string
    active?: BoolFilter<"ExternalEarningsSource"> | boolean
    lastSync?: DateTimeNullableFilter<"ExternalEarningsSource"> | Date | string | null
    metadata?: JsonNullableFilter<"ExternalEarningsSource">
    imports?: ExternalEarningsImportListRelationFilter
    earnings?: NormalizedEarningListRelationFilter
  }

  export type ExternalEarningsSourceOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    platform?: SortOrder
    externalHandle?: SortOrder
    currency?: SortOrder
    connectedAt?: SortOrder
    active?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    imports?: ExternalEarningsImportOrderByRelationAggregateInput
    earnings?: NormalizedEarningOrderByRelationAggregateInput
  }

  export type ExternalEarningsSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creatorId_platform_externalHandle?: ExternalEarningsSourceCreatorIdPlatformExternalHandleCompoundUniqueInput
    AND?: ExternalEarningsSourceWhereInput | ExternalEarningsSourceWhereInput[]
    OR?: ExternalEarningsSourceWhereInput[]
    NOT?: ExternalEarningsSourceWhereInput | ExternalEarningsSourceWhereInput[]
    creatorId?: StringFilter<"ExternalEarningsSource"> | string
    platform?: EnumExternalPlatformFilter<"ExternalEarningsSource"> | $Enums.ExternalPlatform
    externalHandle?: StringFilter<"ExternalEarningsSource"> | string
    currency?: StringFilter<"ExternalEarningsSource"> | string
    connectedAt?: DateTimeFilter<"ExternalEarningsSource"> | Date | string
    active?: BoolFilter<"ExternalEarningsSource"> | boolean
    lastSync?: DateTimeNullableFilter<"ExternalEarningsSource"> | Date | string | null
    metadata?: JsonNullableFilter<"ExternalEarningsSource">
    imports?: ExternalEarningsImportListRelationFilter
    earnings?: NormalizedEarningListRelationFilter
  }, "id" | "creatorId_platform_externalHandle">

  export type ExternalEarningsSourceOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    platform?: SortOrder
    externalHandle?: SortOrder
    currency?: SortOrder
    connectedAt?: SortOrder
    active?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ExternalEarningsSourceCountOrderByAggregateInput
    _max?: ExternalEarningsSourceMaxOrderByAggregateInput
    _min?: ExternalEarningsSourceMinOrderByAggregateInput
  }

  export type ExternalEarningsSourceScalarWhereWithAggregatesInput = {
    AND?: ExternalEarningsSourceScalarWhereWithAggregatesInput | ExternalEarningsSourceScalarWhereWithAggregatesInput[]
    OR?: ExternalEarningsSourceScalarWhereWithAggregatesInput[]
    NOT?: ExternalEarningsSourceScalarWhereWithAggregatesInput | ExternalEarningsSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExternalEarningsSource"> | string
    creatorId?: StringWithAggregatesFilter<"ExternalEarningsSource"> | string
    platform?: EnumExternalPlatformWithAggregatesFilter<"ExternalEarningsSource"> | $Enums.ExternalPlatform
    externalHandle?: StringWithAggregatesFilter<"ExternalEarningsSource"> | string
    currency?: StringWithAggregatesFilter<"ExternalEarningsSource"> | string
    connectedAt?: DateTimeWithAggregatesFilter<"ExternalEarningsSource"> | Date | string
    active?: BoolWithAggregatesFilter<"ExternalEarningsSource"> | boolean
    lastSync?: DateTimeNullableWithAggregatesFilter<"ExternalEarningsSource"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ExternalEarningsSource">
  }

  export type ExternalEarningsImportWhereInput = {
    AND?: ExternalEarningsImportWhereInput | ExternalEarningsImportWhereInput[]
    OR?: ExternalEarningsImportWhereInput[]
    NOT?: ExternalEarningsImportWhereInput | ExternalEarningsImportWhereInput[]
    id?: StringFilter<"ExternalEarningsImport"> | string
    sourceId?: StringFilter<"ExternalEarningsImport"> | string
    periodStart?: DateTimeFilter<"ExternalEarningsImport"> | Date | string
    periodEnd?: DateTimeFilter<"ExternalEarningsImport"> | Date | string
    rawHash?: StringFilter<"ExternalEarningsImport"> | string
    rawJson?: JsonFilter<"ExternalEarningsImport">
    processedAt?: DateTimeNullableFilter<"ExternalEarningsImport"> | Date | string | null
    errorMessage?: StringNullableFilter<"ExternalEarningsImport"> | string | null
    createdAt?: DateTimeFilter<"ExternalEarningsImport"> | Date | string
    source?: XOR<ExternalEarningsSourceRelationFilter, ExternalEarningsSourceWhereInput>
  }

  export type ExternalEarningsImportOrderByWithRelationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    rawHash?: SortOrder
    rawJson?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    source?: ExternalEarningsSourceOrderByWithRelationInput
  }

  export type ExternalEarningsImportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sourceId_periodStart_periodEnd_rawHash?: ExternalEarningsImportSourceIdPeriodStartPeriodEndRawHashCompoundUniqueInput
    AND?: ExternalEarningsImportWhereInput | ExternalEarningsImportWhereInput[]
    OR?: ExternalEarningsImportWhereInput[]
    NOT?: ExternalEarningsImportWhereInput | ExternalEarningsImportWhereInput[]
    sourceId?: StringFilter<"ExternalEarningsImport"> | string
    periodStart?: DateTimeFilter<"ExternalEarningsImport"> | Date | string
    periodEnd?: DateTimeFilter<"ExternalEarningsImport"> | Date | string
    rawHash?: StringFilter<"ExternalEarningsImport"> | string
    rawJson?: JsonFilter<"ExternalEarningsImport">
    processedAt?: DateTimeNullableFilter<"ExternalEarningsImport"> | Date | string | null
    errorMessage?: StringNullableFilter<"ExternalEarningsImport"> | string | null
    createdAt?: DateTimeFilter<"ExternalEarningsImport"> | Date | string
    source?: XOR<ExternalEarningsSourceRelationFilter, ExternalEarningsSourceWhereInput>
  }, "id" | "sourceId_periodStart_periodEnd_rawHash">

  export type ExternalEarningsImportOrderByWithAggregationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    rawHash?: SortOrder
    rawJson?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ExternalEarningsImportCountOrderByAggregateInput
    _max?: ExternalEarningsImportMaxOrderByAggregateInput
    _min?: ExternalEarningsImportMinOrderByAggregateInput
  }

  export type ExternalEarningsImportScalarWhereWithAggregatesInput = {
    AND?: ExternalEarningsImportScalarWhereWithAggregatesInput | ExternalEarningsImportScalarWhereWithAggregatesInput[]
    OR?: ExternalEarningsImportScalarWhereWithAggregatesInput[]
    NOT?: ExternalEarningsImportScalarWhereWithAggregatesInput | ExternalEarningsImportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExternalEarningsImport"> | string
    sourceId?: StringWithAggregatesFilter<"ExternalEarningsImport"> | string
    periodStart?: DateTimeWithAggregatesFilter<"ExternalEarningsImport"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"ExternalEarningsImport"> | Date | string
    rawHash?: StringWithAggregatesFilter<"ExternalEarningsImport"> | string
    rawJson?: JsonWithAggregatesFilter<"ExternalEarningsImport">
    processedAt?: DateTimeNullableWithAggregatesFilter<"ExternalEarningsImport"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"ExternalEarningsImport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExternalEarningsImport"> | Date | string
  }

  export type NormalizedEarningWhereInput = {
    AND?: NormalizedEarningWhereInput | NormalizedEarningWhereInput[]
    OR?: NormalizedEarningWhereInput[]
    NOT?: NormalizedEarningWhereInput | NormalizedEarningWhereInput[]
    id?: StringFilter<"NormalizedEarning"> | string
    sourceId?: StringFilter<"NormalizedEarning"> | string
    occurredAt?: DateTimeFilter<"NormalizedEarning"> | Date | string
    currency?: StringFilter<"NormalizedEarning"> | string
    grossCents?: BigIntFilter<"NormalizedEarning"> | bigint | number
    feesCents?: BigIntFilter<"NormalizedEarning"> | bigint | number
    netCents?: BigIntFilter<"NormalizedEarning"> | bigint | number
    payoutId?: StringNullableFilter<"NormalizedEarning"> | string | null
    extRef?: StringNullableFilter<"NormalizedEarning"> | string | null
    metadata?: JsonNullableFilter<"NormalizedEarning">
    createdAt?: DateTimeFilter<"NormalizedEarning"> | Date | string
    source?: XOR<ExternalEarningsSourceRelationFilter, ExternalEarningsSourceWhereInput>
  }

  export type NormalizedEarningOrderByWithRelationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    occurredAt?: SortOrder
    currency?: SortOrder
    grossCents?: SortOrder
    feesCents?: SortOrder
    netCents?: SortOrder
    payoutId?: SortOrderInput | SortOrder
    extRef?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    source?: ExternalEarningsSourceOrderByWithRelationInput
  }

  export type NormalizedEarningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NormalizedEarningWhereInput | NormalizedEarningWhereInput[]
    OR?: NormalizedEarningWhereInput[]
    NOT?: NormalizedEarningWhereInput | NormalizedEarningWhereInput[]
    sourceId?: StringFilter<"NormalizedEarning"> | string
    occurredAt?: DateTimeFilter<"NormalizedEarning"> | Date | string
    currency?: StringFilter<"NormalizedEarning"> | string
    grossCents?: BigIntFilter<"NormalizedEarning"> | bigint | number
    feesCents?: BigIntFilter<"NormalizedEarning"> | bigint | number
    netCents?: BigIntFilter<"NormalizedEarning"> | bigint | number
    payoutId?: StringNullableFilter<"NormalizedEarning"> | string | null
    extRef?: StringNullableFilter<"NormalizedEarning"> | string | null
    metadata?: JsonNullableFilter<"NormalizedEarning">
    createdAt?: DateTimeFilter<"NormalizedEarning"> | Date | string
    source?: XOR<ExternalEarningsSourceRelationFilter, ExternalEarningsSourceWhereInput>
  }, "id">

  export type NormalizedEarningOrderByWithAggregationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    occurredAt?: SortOrder
    currency?: SortOrder
    grossCents?: SortOrder
    feesCents?: SortOrder
    netCents?: SortOrder
    payoutId?: SortOrderInput | SortOrder
    extRef?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NormalizedEarningCountOrderByAggregateInput
    _avg?: NormalizedEarningAvgOrderByAggregateInput
    _max?: NormalizedEarningMaxOrderByAggregateInput
    _min?: NormalizedEarningMinOrderByAggregateInput
    _sum?: NormalizedEarningSumOrderByAggregateInput
  }

  export type NormalizedEarningScalarWhereWithAggregatesInput = {
    AND?: NormalizedEarningScalarWhereWithAggregatesInput | NormalizedEarningScalarWhereWithAggregatesInput[]
    OR?: NormalizedEarningScalarWhereWithAggregatesInput[]
    NOT?: NormalizedEarningScalarWhereWithAggregatesInput | NormalizedEarningScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NormalizedEarning"> | string
    sourceId?: StringWithAggregatesFilter<"NormalizedEarning"> | string
    occurredAt?: DateTimeWithAggregatesFilter<"NormalizedEarning"> | Date | string
    currency?: StringWithAggregatesFilter<"NormalizedEarning"> | string
    grossCents?: BigIntWithAggregatesFilter<"NormalizedEarning"> | bigint | number
    feesCents?: BigIntWithAggregatesFilter<"NormalizedEarning"> | bigint | number
    netCents?: BigIntWithAggregatesFilter<"NormalizedEarning"> | bigint | number
    payoutId?: StringNullableWithAggregatesFilter<"NormalizedEarning"> | string | null
    extRef?: StringNullableWithAggregatesFilter<"NormalizedEarning"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"NormalizedEarning">
    createdAt?: DateTimeWithAggregatesFilter<"NormalizedEarning"> | Date | string
  }

  export type CommissionStatementWhereInput = {
    AND?: CommissionStatementWhereInput | CommissionStatementWhereInput[]
    OR?: CommissionStatementWhereInput[]
    NOT?: CommissionStatementWhereInput | CommissionStatementWhereInput[]
    id?: StringFilter<"CommissionStatement"> | string
    creatorId?: StringFilter<"CommissionStatement"> | string
    platform?: EnumExternalPlatformFilter<"CommissionStatement"> | $Enums.ExternalPlatform
    yearMonth?: StringFilter<"CommissionStatement"> | string
    currency?: StringFilter<"CommissionStatement"> | string
    baseNetCents?: BigIntFilter<"CommissionStatement"> | bigint | number
    rateBps?: IntFilter<"CommissionStatement"> | number
    commissionCents?: BigIntFilter<"CommissionStatement"> | bigint | number
    capAppliedCents?: BigIntFilter<"CommissionStatement"> | bigint | number
    finalCents?: BigIntFilter<"CommissionStatement"> | bigint | number
    closedAt?: DateTimeNullableFilter<"CommissionStatement"> | Date | string | null
    invoicedAt?: DateTimeNullableFilter<"CommissionStatement"> | Date | string | null
    stripeInvoiceId?: StringNullableFilter<"CommissionStatement"> | string | null
    paidAt?: DateTimeNullableFilter<"CommissionStatement"> | Date | string | null
    writeOffAt?: DateTimeNullableFilter<"CommissionStatement"> | Date | string | null
    createdAt?: DateTimeFilter<"CommissionStatement"> | Date | string
    updatedAt?: DateTimeFilter<"CommissionStatement"> | Date | string
  }

  export type CommissionStatementOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    platform?: SortOrder
    yearMonth?: SortOrder
    currency?: SortOrder
    baseNetCents?: SortOrder
    rateBps?: SortOrder
    commissionCents?: SortOrder
    capAppliedCents?: SortOrder
    finalCents?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    invoicedAt?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    writeOffAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionStatementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeInvoiceId?: string
    creatorId_platform_yearMonth_currency?: CommissionStatementCreatorIdPlatformYearMonthCurrencyCompoundUniqueInput
    AND?: CommissionStatementWhereInput | CommissionStatementWhereInput[]
    OR?: CommissionStatementWhereInput[]
    NOT?: CommissionStatementWhereInput | CommissionStatementWhereInput[]
    creatorId?: StringFilter<"CommissionStatement"> | string
    platform?: EnumExternalPlatformFilter<"CommissionStatement"> | $Enums.ExternalPlatform
    yearMonth?: StringFilter<"CommissionStatement"> | string
    currency?: StringFilter<"CommissionStatement"> | string
    baseNetCents?: BigIntFilter<"CommissionStatement"> | bigint | number
    rateBps?: IntFilter<"CommissionStatement"> | number
    commissionCents?: BigIntFilter<"CommissionStatement"> | bigint | number
    capAppliedCents?: BigIntFilter<"CommissionStatement"> | bigint | number
    finalCents?: BigIntFilter<"CommissionStatement"> | bigint | number
    closedAt?: DateTimeNullableFilter<"CommissionStatement"> | Date | string | null
    invoicedAt?: DateTimeNullableFilter<"CommissionStatement"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"CommissionStatement"> | Date | string | null
    writeOffAt?: DateTimeNullableFilter<"CommissionStatement"> | Date | string | null
    createdAt?: DateTimeFilter<"CommissionStatement"> | Date | string
    updatedAt?: DateTimeFilter<"CommissionStatement"> | Date | string
  }, "id" | "stripeInvoiceId" | "creatorId_platform_yearMonth_currency">

  export type CommissionStatementOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    platform?: SortOrder
    yearMonth?: SortOrder
    currency?: SortOrder
    baseNetCents?: SortOrder
    rateBps?: SortOrder
    commissionCents?: SortOrder
    capAppliedCents?: SortOrder
    finalCents?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    invoicedAt?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    writeOffAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommissionStatementCountOrderByAggregateInput
    _avg?: CommissionStatementAvgOrderByAggregateInput
    _max?: CommissionStatementMaxOrderByAggregateInput
    _min?: CommissionStatementMinOrderByAggregateInput
    _sum?: CommissionStatementSumOrderByAggregateInput
  }

  export type CommissionStatementScalarWhereWithAggregatesInput = {
    AND?: CommissionStatementScalarWhereWithAggregatesInput | CommissionStatementScalarWhereWithAggregatesInput[]
    OR?: CommissionStatementScalarWhereWithAggregatesInput[]
    NOT?: CommissionStatementScalarWhereWithAggregatesInput | CommissionStatementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommissionStatement"> | string
    creatorId?: StringWithAggregatesFilter<"CommissionStatement"> | string
    platform?: EnumExternalPlatformWithAggregatesFilter<"CommissionStatement"> | $Enums.ExternalPlatform
    yearMonth?: StringWithAggregatesFilter<"CommissionStatement"> | string
    currency?: StringWithAggregatesFilter<"CommissionStatement"> | string
    baseNetCents?: BigIntWithAggregatesFilter<"CommissionStatement"> | bigint | number
    rateBps?: IntWithAggregatesFilter<"CommissionStatement"> | number
    commissionCents?: BigIntWithAggregatesFilter<"CommissionStatement"> | bigint | number
    capAppliedCents?: BigIntWithAggregatesFilter<"CommissionStatement"> | bigint | number
    finalCents?: BigIntWithAggregatesFilter<"CommissionStatement"> | bigint | number
    closedAt?: DateTimeNullableWithAggregatesFilter<"CommissionStatement"> | Date | string | null
    invoicedAt?: DateTimeNullableWithAggregatesFilter<"CommissionStatement"> | Date | string | null
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"CommissionStatement"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"CommissionStatement"> | Date | string | null
    writeOffAt?: DateTimeNullableWithAggregatesFilter<"CommissionStatement"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CommissionStatement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommissionStatement"> | Date | string
  }

  export type DunningStateWhereInput = {
    AND?: DunningStateWhereInput | DunningStateWhereInput[]
    OR?: DunningStateWhereInput[]
    NOT?: DunningStateWhereInput | DunningStateWhereInput[]
    id?: StringFilter<"DunningState"> | string
    invoiceId?: StringFilter<"DunningState"> | string
    creatorId?: StringFilter<"DunningState"> | string
    attemptCount?: IntFilter<"DunningState"> | number
    status?: EnumDunningStatusFilter<"DunningState"> | $Enums.DunningStatus
    lastAttempt?: DateTimeNullableFilter<"DunningState"> | Date | string | null
    nextAttempt?: DateTimeNullableFilter<"DunningState"> | Date | string | null
    recoveredAt?: DateTimeNullableFilter<"DunningState"> | Date | string | null
    writeOffAt?: DateTimeNullableFilter<"DunningState"> | Date | string | null
    metadata?: JsonNullableFilter<"DunningState">
    createdAt?: DateTimeFilter<"DunningState"> | Date | string
    updatedAt?: DateTimeFilter<"DunningState"> | Date | string
  }

  export type DunningStateOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    creatorId?: SortOrder
    attemptCount?: SortOrder
    status?: SortOrder
    lastAttempt?: SortOrderInput | SortOrder
    nextAttempt?: SortOrderInput | SortOrder
    recoveredAt?: SortOrderInput | SortOrder
    writeOffAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DunningStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceId?: string
    AND?: DunningStateWhereInput | DunningStateWhereInput[]
    OR?: DunningStateWhereInput[]
    NOT?: DunningStateWhereInput | DunningStateWhereInput[]
    creatorId?: StringFilter<"DunningState"> | string
    attemptCount?: IntFilter<"DunningState"> | number
    status?: EnumDunningStatusFilter<"DunningState"> | $Enums.DunningStatus
    lastAttempt?: DateTimeNullableFilter<"DunningState"> | Date | string | null
    nextAttempt?: DateTimeNullableFilter<"DunningState"> | Date | string | null
    recoveredAt?: DateTimeNullableFilter<"DunningState"> | Date | string | null
    writeOffAt?: DateTimeNullableFilter<"DunningState"> | Date | string | null
    metadata?: JsonNullableFilter<"DunningState">
    createdAt?: DateTimeFilter<"DunningState"> | Date | string
    updatedAt?: DateTimeFilter<"DunningState"> | Date | string
  }, "id" | "invoiceId">

  export type DunningStateOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    creatorId?: SortOrder
    attemptCount?: SortOrder
    status?: SortOrder
    lastAttempt?: SortOrderInput | SortOrder
    nextAttempt?: SortOrderInput | SortOrder
    recoveredAt?: SortOrderInput | SortOrder
    writeOffAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DunningStateCountOrderByAggregateInput
    _avg?: DunningStateAvgOrderByAggregateInput
    _max?: DunningStateMaxOrderByAggregateInput
    _min?: DunningStateMinOrderByAggregateInput
    _sum?: DunningStateSumOrderByAggregateInput
  }

  export type DunningStateScalarWhereWithAggregatesInput = {
    AND?: DunningStateScalarWhereWithAggregatesInput | DunningStateScalarWhereWithAggregatesInput[]
    OR?: DunningStateScalarWhereWithAggregatesInput[]
    NOT?: DunningStateScalarWhereWithAggregatesInput | DunningStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DunningState"> | string
    invoiceId?: StringWithAggregatesFilter<"DunningState"> | string
    creatorId?: StringWithAggregatesFilter<"DunningState"> | string
    attemptCount?: IntWithAggregatesFilter<"DunningState"> | number
    status?: EnumDunningStatusWithAggregatesFilter<"DunningState"> | $Enums.DunningStatus
    lastAttempt?: DateTimeNullableWithAggregatesFilter<"DunningState"> | Date | string | null
    nextAttempt?: DateTimeNullableWithAggregatesFilter<"DunningState"> | Date | string | null
    recoveredAt?: DateTimeNullableWithAggregatesFilter<"DunningState"> | Date | string | null
    writeOffAt?: DateTimeNullableWithAggregatesFilter<"DunningState"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"DunningState">
    createdAt?: DateTimeWithAggregatesFilter<"DunningState"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DunningState"> | Date | string
  }

  export type PaymentAttemptWhereInput = {
    AND?: PaymentAttemptWhereInput | PaymentAttemptWhereInput[]
    OR?: PaymentAttemptWhereInput[]
    NOT?: PaymentAttemptWhereInput | PaymentAttemptWhereInput[]
    id?: StringFilter<"PaymentAttempt"> | string
    invoiceId?: StringFilter<"PaymentAttempt"> | string
    attemptNumber?: IntFilter<"PaymentAttempt"> | number
    status?: StringFilter<"PaymentAttempt"> | string
    errorCode?: StringNullableFilter<"PaymentAttempt"> | string | null
    errorMessage?: StringNullableFilter<"PaymentAttempt"> | string | null
    paymentMethodId?: StringNullableFilter<"PaymentAttempt"> | string | null
    amount?: BigIntFilter<"PaymentAttempt"> | bigint | number
    currency?: StringFilter<"PaymentAttempt"> | string
    createdAt?: DateTimeFilter<"PaymentAttempt"> | Date | string
  }

  export type PaymentAttemptOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    attemptNumber?: SortOrder
    status?: SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    paymentMethodId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentAttemptWhereInput | PaymentAttemptWhereInput[]
    OR?: PaymentAttemptWhereInput[]
    NOT?: PaymentAttemptWhereInput | PaymentAttemptWhereInput[]
    invoiceId?: StringFilter<"PaymentAttempt"> | string
    attemptNumber?: IntFilter<"PaymentAttempt"> | number
    status?: StringFilter<"PaymentAttempt"> | string
    errorCode?: StringNullableFilter<"PaymentAttempt"> | string | null
    errorMessage?: StringNullableFilter<"PaymentAttempt"> | string | null
    paymentMethodId?: StringNullableFilter<"PaymentAttempt"> | string | null
    amount?: BigIntFilter<"PaymentAttempt"> | bigint | number
    currency?: StringFilter<"PaymentAttempt"> | string
    createdAt?: DateTimeFilter<"PaymentAttempt"> | Date | string
  }, "id">

  export type PaymentAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    attemptNumber?: SortOrder
    status?: SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    paymentMethodId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentAttemptCountOrderByAggregateInput
    _avg?: PaymentAttemptAvgOrderByAggregateInput
    _max?: PaymentAttemptMaxOrderByAggregateInput
    _min?: PaymentAttemptMinOrderByAggregateInput
    _sum?: PaymentAttemptSumOrderByAggregateInput
  }

  export type PaymentAttemptScalarWhereWithAggregatesInput = {
    AND?: PaymentAttemptScalarWhereWithAggregatesInput | PaymentAttemptScalarWhereWithAggregatesInput[]
    OR?: PaymentAttemptScalarWhereWithAggregatesInput[]
    NOT?: PaymentAttemptScalarWhereWithAggregatesInput | PaymentAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentAttempt"> | string
    invoiceId?: StringWithAggregatesFilter<"PaymentAttempt"> | string
    attemptNumber?: IntWithAggregatesFilter<"PaymentAttempt"> | number
    status?: StringWithAggregatesFilter<"PaymentAttempt"> | string
    errorCode?: StringNullableWithAggregatesFilter<"PaymentAttempt"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"PaymentAttempt"> | string | null
    paymentMethodId?: StringNullableWithAggregatesFilter<"PaymentAttempt"> | string | null
    amount?: BigIntWithAggregatesFilter<"PaymentAttempt"> | bigint | number
    currency?: StringWithAggregatesFilter<"PaymentAttempt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentAttempt"> | Date | string
  }

  export type AutomationWhereInput = {
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    id?: StringFilter<"Automation"> | string
    creatorId?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    triggerType?: EnumAutomationTriggerFilter<"Automation"> | $Enums.AutomationTrigger
    conditions?: JsonNullableFilter<"Automation">
    actions?: JsonFilter<"Automation">
    status?: EnumAutomationStatusFilter<"Automation"> | $Enums.AutomationStatus
    lastRun?: DateTimeNullableFilter<"Automation"> | Date | string | null
    runCount?: IntFilter<"Automation"> | number
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
  }

  export type AutomationOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    conditions?: SortOrderInput | SortOrder
    actions?: SortOrder
    status?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    creatorId?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    triggerType?: EnumAutomationTriggerFilter<"Automation"> | $Enums.AutomationTrigger
    conditions?: JsonNullableFilter<"Automation">
    actions?: JsonFilter<"Automation">
    status?: EnumAutomationStatusFilter<"Automation"> | $Enums.AutomationStatus
    lastRun?: DateTimeNullableFilter<"Automation"> | Date | string | null
    runCount?: IntFilter<"Automation"> | number
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
  }, "id">

  export type AutomationOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    conditions?: SortOrderInput | SortOrder
    actions?: SortOrder
    status?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AutomationCountOrderByAggregateInput
    _avg?: AutomationAvgOrderByAggregateInput
    _max?: AutomationMaxOrderByAggregateInput
    _min?: AutomationMinOrderByAggregateInput
    _sum?: AutomationSumOrderByAggregateInput
  }

  export type AutomationScalarWhereWithAggregatesInput = {
    AND?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    OR?: AutomationScalarWhereWithAggregatesInput[]
    NOT?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Automation"> | string
    creatorId?: StringWithAggregatesFilter<"Automation"> | string
    name?: StringWithAggregatesFilter<"Automation"> | string
    triggerType?: EnumAutomationTriggerWithAggregatesFilter<"Automation"> | $Enums.AutomationTrigger
    conditions?: JsonNullableWithAggregatesFilter<"Automation">
    actions?: JsonWithAggregatesFilter<"Automation">
    status?: EnumAutomationStatusWithAggregatesFilter<"Automation"> | $Enums.AutomationStatus
    lastRun?: DateTimeNullableWithAggregatesFilter<"Automation"> | Date | string | null
    runCount?: IntWithAggregatesFilter<"Automation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
  }

  export type BackupLogWhereInput = {
    AND?: BackupLogWhereInput | BackupLogWhereInput[]
    OR?: BackupLogWhereInput[]
    NOT?: BackupLogWhereInput | BackupLogWhereInput[]
    id?: StringFilter<"BackupLog"> | string
    status?: StringFilter<"BackupLog"> | string
    duration?: IntNullableFilter<"BackupLog"> | number | null
    error?: StringNullableFilter<"BackupLog"> | string | null
    metadata?: JsonNullableFilter<"BackupLog">
    createdAt?: DateTimeFilter<"BackupLog"> | Date | string
  }

  export type BackupLogOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type BackupLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BackupLogWhereInput | BackupLogWhereInput[]
    OR?: BackupLogWhereInput[]
    NOT?: BackupLogWhereInput | BackupLogWhereInput[]
    status?: StringFilter<"BackupLog"> | string
    duration?: IntNullableFilter<"BackupLog"> | number | null
    error?: StringNullableFilter<"BackupLog"> | string | null
    metadata?: JsonNullableFilter<"BackupLog">
    createdAt?: DateTimeFilter<"BackupLog"> | Date | string
  }, "id">

  export type BackupLogOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BackupLogCountOrderByAggregateInput
    _avg?: BackupLogAvgOrderByAggregateInput
    _max?: BackupLogMaxOrderByAggregateInput
    _min?: BackupLogMinOrderByAggregateInput
    _sum?: BackupLogSumOrderByAggregateInput
  }

  export type BackupLogScalarWhereWithAggregatesInput = {
    AND?: BackupLogScalarWhereWithAggregatesInput | BackupLogScalarWhereWithAggregatesInput[]
    OR?: BackupLogScalarWhereWithAggregatesInput[]
    NOT?: BackupLogScalarWhereWithAggregatesInput | BackupLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BackupLog"> | string
    status?: StringWithAggregatesFilter<"BackupLog"> | string
    duration?: IntNullableWithAggregatesFilter<"BackupLog"> | number | null
    error?: StringNullableWithAggregatesFilter<"BackupLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"BackupLog">
    createdAt?: DateTimeWithAggregatesFilter<"BackupLog"> | Date | string
  }

  export type BackupValidationWhereInput = {
    AND?: BackupValidationWhereInput | BackupValidationWhereInput[]
    OR?: BackupValidationWhereInput[]
    NOT?: BackupValidationWhereInput | BackupValidationWhereInput[]
    id?: StringFilter<"BackupValidation"> | string
    timestamp?: DateTimeFilter<"BackupValidation"> | Date | string
    results?: JsonFilter<"BackupValidation">
    summary?: JsonFilter<"BackupValidation">
    status?: StringFilter<"BackupValidation"> | string
    createdAt?: DateTimeFilter<"BackupValidation"> | Date | string
  }

  export type BackupValidationOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    results?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupValidationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BackupValidationWhereInput | BackupValidationWhereInput[]
    OR?: BackupValidationWhereInput[]
    NOT?: BackupValidationWhereInput | BackupValidationWhereInput[]
    timestamp?: DateTimeFilter<"BackupValidation"> | Date | string
    results?: JsonFilter<"BackupValidation">
    summary?: JsonFilter<"BackupValidation">
    status?: StringFilter<"BackupValidation"> | string
    createdAt?: DateTimeFilter<"BackupValidation"> | Date | string
  }, "id">

  export type BackupValidationOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    results?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: BackupValidationCountOrderByAggregateInput
    _max?: BackupValidationMaxOrderByAggregateInput
    _min?: BackupValidationMinOrderByAggregateInput
  }

  export type BackupValidationScalarWhereWithAggregatesInput = {
    AND?: BackupValidationScalarWhereWithAggregatesInput | BackupValidationScalarWhereWithAggregatesInput[]
    OR?: BackupValidationScalarWhereWithAggregatesInput[]
    NOT?: BackupValidationScalarWhereWithAggregatesInput | BackupValidationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BackupValidation"> | string
    timestamp?: DateTimeWithAggregatesFilter<"BackupValidation"> | Date | string
    results?: JsonWithAggregatesFilter<"BackupValidation">
    summary?: JsonWithAggregatesFilter<"BackupValidation">
    status?: StringWithAggregatesFilter<"BackupValidation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BackupValidation"> | Date | string
  }

  export type BackupIndexWhereInput = {
    AND?: BackupIndexWhereInput | BackupIndexWhereInput[]
    OR?: BackupIndexWhereInput[]
    NOT?: BackupIndexWhereInput | BackupIndexWhereInput[]
    id?: StringFilter<"BackupIndex"> | string
    backupId?: StringFilter<"BackupIndex"> | string
    timestamp?: DateTimeFilter<"BackupIndex"> | Date | string
    metadata?: JsonFilter<"BackupIndex">
    tables?: JsonFilter<"BackupIndex">
    createdAt?: DateTimeFilter<"BackupIndex"> | Date | string
  }

  export type BackupIndexOrderByWithRelationInput = {
    id?: SortOrder
    backupId?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    tables?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupIndexWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    backupId?: string
    AND?: BackupIndexWhereInput | BackupIndexWhereInput[]
    OR?: BackupIndexWhereInput[]
    NOT?: BackupIndexWhereInput | BackupIndexWhereInput[]
    timestamp?: DateTimeFilter<"BackupIndex"> | Date | string
    metadata?: JsonFilter<"BackupIndex">
    tables?: JsonFilter<"BackupIndex">
    createdAt?: DateTimeFilter<"BackupIndex"> | Date | string
  }, "id" | "backupId">

  export type BackupIndexOrderByWithAggregationInput = {
    id?: SortOrder
    backupId?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    tables?: SortOrder
    createdAt?: SortOrder
    _count?: BackupIndexCountOrderByAggregateInput
    _max?: BackupIndexMaxOrderByAggregateInput
    _min?: BackupIndexMinOrderByAggregateInput
  }

  export type BackupIndexScalarWhereWithAggregatesInput = {
    AND?: BackupIndexScalarWhereWithAggregatesInput | BackupIndexScalarWhereWithAggregatesInput[]
    OR?: BackupIndexScalarWhereWithAggregatesInput[]
    NOT?: BackupIndexScalarWhereWithAggregatesInput | BackupIndexScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BackupIndex"> | string
    backupId?: StringWithAggregatesFilter<"BackupIndex"> | string
    timestamp?: DateTimeWithAggregatesFilter<"BackupIndex"> | Date | string
    metadata?: JsonWithAggregatesFilter<"BackupIndex">
    tables?: JsonWithAggregatesFilter<"BackupIndex">
    createdAt?: DateTimeWithAggregatesFilter<"BackupIndex"> | Date | string
  }

  export type AIUsageLogWhereInput = {
    AND?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    OR?: AIUsageLogWhereInput[]
    NOT?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    id?: StringFilter<"AIUsageLog"> | string
    provider?: StringFilter<"AIUsageLog"> | string
    model?: StringFilter<"AIUsageLog"> | string
    purpose?: StringFilter<"AIUsageLog"> | string
    userId?: StringFilter<"AIUsageLog"> | string
    promptTokens?: IntFilter<"AIUsageLog"> | number
    completionTokens?: IntFilter<"AIUsageLog"> | number
    totalTokens?: IntFilter<"AIUsageLog"> | number
    cost?: FloatFilter<"AIUsageLog"> | number
    cached?: BoolFilter<"AIUsageLog"> | boolean
    timestamp?: DateTimeFilter<"AIUsageLog"> | Date | string
  }

  export type AIUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    purpose?: SortOrder
    userId?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    cost?: SortOrder
    cached?: SortOrder
    timestamp?: SortOrder
  }

  export type AIUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    OR?: AIUsageLogWhereInput[]
    NOT?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    provider?: StringFilter<"AIUsageLog"> | string
    model?: StringFilter<"AIUsageLog"> | string
    purpose?: StringFilter<"AIUsageLog"> | string
    userId?: StringFilter<"AIUsageLog"> | string
    promptTokens?: IntFilter<"AIUsageLog"> | number
    completionTokens?: IntFilter<"AIUsageLog"> | number
    totalTokens?: IntFilter<"AIUsageLog"> | number
    cost?: FloatFilter<"AIUsageLog"> | number
    cached?: BoolFilter<"AIUsageLog"> | boolean
    timestamp?: DateTimeFilter<"AIUsageLog"> | Date | string
  }, "id">

  export type AIUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    purpose?: SortOrder
    userId?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    cost?: SortOrder
    cached?: SortOrder
    timestamp?: SortOrder
    _count?: AIUsageLogCountOrderByAggregateInput
    _avg?: AIUsageLogAvgOrderByAggregateInput
    _max?: AIUsageLogMaxOrderByAggregateInput
    _min?: AIUsageLogMinOrderByAggregateInput
    _sum?: AIUsageLogSumOrderByAggregateInput
  }

  export type AIUsageLogScalarWhereWithAggregatesInput = {
    AND?: AIUsageLogScalarWhereWithAggregatesInput | AIUsageLogScalarWhereWithAggregatesInput[]
    OR?: AIUsageLogScalarWhereWithAggregatesInput[]
    NOT?: AIUsageLogScalarWhereWithAggregatesInput | AIUsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIUsageLog"> | string
    provider?: StringWithAggregatesFilter<"AIUsageLog"> | string
    model?: StringWithAggregatesFilter<"AIUsageLog"> | string
    purpose?: StringWithAggregatesFilter<"AIUsageLog"> | string
    userId?: StringWithAggregatesFilter<"AIUsageLog"> | string
    promptTokens?: IntWithAggregatesFilter<"AIUsageLog"> | number
    completionTokens?: IntWithAggregatesFilter<"AIUsageLog"> | number
    totalTokens?: IntWithAggregatesFilter<"AIUsageLog"> | number
    cost?: FloatWithAggregatesFilter<"AIUsageLog"> | number
    cached?: BoolWithAggregatesFilter<"AIUsageLog"> | boolean
    timestamp?: DateTimeWithAggregatesFilter<"AIUsageLog"> | Date | string
  }

  export type CostReservationWhereInput = {
    AND?: CostReservationWhereInput | CostReservationWhereInput[]
    OR?: CostReservationWhereInput[]
    NOT?: CostReservationWhereInput | CostReservationWhereInput[]
    id?: StringFilter<"CostReservation"> | string
    provider?: StringFilter<"CostReservation"> | string
    service?: StringFilter<"CostReservation"> | string
    commitment?: StringFilter<"CostReservation"> | string
    units?: FloatFilter<"CostReservation"> | number
    unitPrice?: FloatFilter<"CostReservation"> | number
    savings?: FloatFilter<"CostReservation"> | number
    startDate?: DateTimeFilter<"CostReservation"> | Date | string
    endDate?: DateTimeFilter<"CostReservation"> | Date | string
    status?: StringFilter<"CostReservation"> | string
    createdAt?: DateTimeFilter<"CostReservation"> | Date | string
    updatedAt?: DateTimeFilter<"CostReservation"> | Date | string
  }

  export type CostReservationOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    service?: SortOrder
    commitment?: SortOrder
    units?: SortOrder
    unitPrice?: SortOrder
    savings?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CostReservationWhereInput | CostReservationWhereInput[]
    OR?: CostReservationWhereInput[]
    NOT?: CostReservationWhereInput | CostReservationWhereInput[]
    provider?: StringFilter<"CostReservation"> | string
    service?: StringFilter<"CostReservation"> | string
    commitment?: StringFilter<"CostReservation"> | string
    units?: FloatFilter<"CostReservation"> | number
    unitPrice?: FloatFilter<"CostReservation"> | number
    savings?: FloatFilter<"CostReservation"> | number
    startDate?: DateTimeFilter<"CostReservation"> | Date | string
    endDate?: DateTimeFilter<"CostReservation"> | Date | string
    status?: StringFilter<"CostReservation"> | string
    createdAt?: DateTimeFilter<"CostReservation"> | Date | string
    updatedAt?: DateTimeFilter<"CostReservation"> | Date | string
  }, "id">

  export type CostReservationOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    service?: SortOrder
    commitment?: SortOrder
    units?: SortOrder
    unitPrice?: SortOrder
    savings?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostReservationCountOrderByAggregateInput
    _avg?: CostReservationAvgOrderByAggregateInput
    _max?: CostReservationMaxOrderByAggregateInput
    _min?: CostReservationMinOrderByAggregateInput
    _sum?: CostReservationSumOrderByAggregateInput
  }

  export type CostReservationScalarWhereWithAggregatesInput = {
    AND?: CostReservationScalarWhereWithAggregatesInput | CostReservationScalarWhereWithAggregatesInput[]
    OR?: CostReservationScalarWhereWithAggregatesInput[]
    NOT?: CostReservationScalarWhereWithAggregatesInput | CostReservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostReservation"> | string
    provider?: StringWithAggregatesFilter<"CostReservation"> | string
    service?: StringWithAggregatesFilter<"CostReservation"> | string
    commitment?: StringWithAggregatesFilter<"CostReservation"> | string
    units?: FloatWithAggregatesFilter<"CostReservation"> | number
    unitPrice?: FloatWithAggregatesFilter<"CostReservation"> | number
    savings?: FloatWithAggregatesFilter<"CostReservation"> | number
    startDate?: DateTimeWithAggregatesFilter<"CostReservation"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"CostReservation"> | Date | string
    status?: StringWithAggregatesFilter<"CostReservation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CostReservation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostReservation"> | Date | string
  }

  export type PromptOptimizationWhereInput = {
    AND?: PromptOptimizationWhereInput | PromptOptimizationWhereInput[]
    OR?: PromptOptimizationWhereInput[]
    NOT?: PromptOptimizationWhereInput | PromptOptimizationWhereInput[]
    id?: StringFilter<"PromptOptimization"> | string
    userId?: StringFilter<"PromptOptimization"> | string
    originalPrompt?: StringFilter<"PromptOptimization"> | string
    optimizedPrompt?: StringFilter<"PromptOptimization"> | string
    originalTokens?: IntFilter<"PromptOptimization"> | number
    optimizedTokens?: IntFilter<"PromptOptimization"> | number
    tokenReduction?: FloatFilter<"PromptOptimization"> | number
    qualityScore?: FloatNullableFilter<"PromptOptimization"> | number | null
    abTestResults?: JsonNullableFilter<"PromptOptimization">
    timestamp?: DateTimeFilter<"PromptOptimization"> | Date | string
  }

  export type PromptOptimizationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    originalPrompt?: SortOrder
    optimizedPrompt?: SortOrder
    originalTokens?: SortOrder
    optimizedTokens?: SortOrder
    tokenReduction?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    abTestResults?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type PromptOptimizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromptOptimizationWhereInput | PromptOptimizationWhereInput[]
    OR?: PromptOptimizationWhereInput[]
    NOT?: PromptOptimizationWhereInput | PromptOptimizationWhereInput[]
    userId?: StringFilter<"PromptOptimization"> | string
    originalPrompt?: StringFilter<"PromptOptimization"> | string
    optimizedPrompt?: StringFilter<"PromptOptimization"> | string
    originalTokens?: IntFilter<"PromptOptimization"> | number
    optimizedTokens?: IntFilter<"PromptOptimization"> | number
    tokenReduction?: FloatFilter<"PromptOptimization"> | number
    qualityScore?: FloatNullableFilter<"PromptOptimization"> | number | null
    abTestResults?: JsonNullableFilter<"PromptOptimization">
    timestamp?: DateTimeFilter<"PromptOptimization"> | Date | string
  }, "id">

  export type PromptOptimizationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    originalPrompt?: SortOrder
    optimizedPrompt?: SortOrder
    originalTokens?: SortOrder
    optimizedTokens?: SortOrder
    tokenReduction?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    abTestResults?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: PromptOptimizationCountOrderByAggregateInput
    _avg?: PromptOptimizationAvgOrderByAggregateInput
    _max?: PromptOptimizationMaxOrderByAggregateInput
    _min?: PromptOptimizationMinOrderByAggregateInput
    _sum?: PromptOptimizationSumOrderByAggregateInput
  }

  export type PromptOptimizationScalarWhereWithAggregatesInput = {
    AND?: PromptOptimizationScalarWhereWithAggregatesInput | PromptOptimizationScalarWhereWithAggregatesInput[]
    OR?: PromptOptimizationScalarWhereWithAggregatesInput[]
    NOT?: PromptOptimizationScalarWhereWithAggregatesInput | PromptOptimizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromptOptimization"> | string
    userId?: StringWithAggregatesFilter<"PromptOptimization"> | string
    originalPrompt?: StringWithAggregatesFilter<"PromptOptimization"> | string
    optimizedPrompt?: StringWithAggregatesFilter<"PromptOptimization"> | string
    originalTokens?: IntWithAggregatesFilter<"PromptOptimization"> | number
    optimizedTokens?: IntWithAggregatesFilter<"PromptOptimization"> | number
    tokenReduction?: FloatWithAggregatesFilter<"PromptOptimization"> | number
    qualityScore?: FloatNullableWithAggregatesFilter<"PromptOptimization"> | number | null
    abTestResults?: JsonNullableWithAggregatesFilter<"PromptOptimization">
    timestamp?: DateTimeWithAggregatesFilter<"PromptOptimization"> | Date | string
  }

  export type CostAlertWhereInput = {
    AND?: CostAlertWhereInput | CostAlertWhereInput[]
    OR?: CostAlertWhereInput[]
    NOT?: CostAlertWhereInput | CostAlertWhereInput[]
    id?: StringFilter<"CostAlert"> | string
    type?: StringFilter<"CostAlert"> | string
    service?: StringFilter<"CostAlert"> | string
    threshold?: FloatFilter<"CostAlert"> | number
    current?: FloatFilter<"CostAlert"> | number
    message?: StringFilter<"CostAlert"> | string
    resolved?: BoolFilter<"CostAlert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"CostAlert"> | Date | string | null
    createdAt?: DateTimeFilter<"CostAlert"> | Date | string
  }

  export type CostAlertOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    service?: SortOrder
    threshold?: SortOrder
    current?: SortOrder
    message?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type CostAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CostAlertWhereInput | CostAlertWhereInput[]
    OR?: CostAlertWhereInput[]
    NOT?: CostAlertWhereInput | CostAlertWhereInput[]
    type?: StringFilter<"CostAlert"> | string
    service?: StringFilter<"CostAlert"> | string
    threshold?: FloatFilter<"CostAlert"> | number
    current?: FloatFilter<"CostAlert"> | number
    message?: StringFilter<"CostAlert"> | string
    resolved?: BoolFilter<"CostAlert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"CostAlert"> | Date | string | null
    createdAt?: DateTimeFilter<"CostAlert"> | Date | string
  }, "id">

  export type CostAlertOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    service?: SortOrder
    threshold?: SortOrder
    current?: SortOrder
    message?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CostAlertCountOrderByAggregateInput
    _avg?: CostAlertAvgOrderByAggregateInput
    _max?: CostAlertMaxOrderByAggregateInput
    _min?: CostAlertMinOrderByAggregateInput
    _sum?: CostAlertSumOrderByAggregateInput
  }

  export type CostAlertScalarWhereWithAggregatesInput = {
    AND?: CostAlertScalarWhereWithAggregatesInput | CostAlertScalarWhereWithAggregatesInput[]
    OR?: CostAlertScalarWhereWithAggregatesInput[]
    NOT?: CostAlertScalarWhereWithAggregatesInput | CostAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostAlert"> | string
    type?: StringWithAggregatesFilter<"CostAlert"> | string
    service?: StringWithAggregatesFilter<"CostAlert"> | string
    threshold?: FloatWithAggregatesFilter<"CostAlert"> | number
    current?: FloatWithAggregatesFilter<"CostAlert"> | number
    message?: StringWithAggregatesFilter<"CostAlert"> | string
    resolved?: BoolWithAggregatesFilter<"CostAlert"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"CostAlert"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CostAlert"> | Date | string
  }

  export type CreatorCreateInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutCreatorInput
    products?: ProductCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionCreateNestedManyWithoutCreatorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    payouts?: PayoutCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput
    products?: ProductUncheckedCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionUncheckedCreateNestedManyWithoutCreatorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutCreatorNestedInput
    products?: ProductUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorCreateManyInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorSettingsCreateInput = {
    id?: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    showPublicProfile?: boolean
    allowDMs?: boolean
    minPayout?: Decimal | DecimalJsLike | number | string
    payoutFrequency?: $Enums.PayoutFrequency
    taxFormSubmitted?: boolean
    w9Submitted?: boolean
    defaultContentAccess?: $Enums.ContentAccess
    watermarkContent?: boolean
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutSettingsInput
  }

  export type CreatorSettingsUncheckedCreateInput = {
    id?: string
    creatorId: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    showPublicProfile?: boolean
    allowDMs?: boolean
    minPayout?: Decimal | DecimalJsLike | number | string
    payoutFrequency?: $Enums.PayoutFrequency
    taxFormSubmitted?: boolean
    w9Submitted?: boolean
    defaultContentAccess?: $Enums.ContentAccess
    watermarkContent?: boolean
    updatedAt?: Date | string
  }

  export type CreatorSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    showPublicProfile?: BoolFieldUpdateOperationsInput | boolean
    allowDMs?: BoolFieldUpdateOperationsInput | boolean
    minPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutFrequency?: EnumPayoutFrequencyFieldUpdateOperationsInput | $Enums.PayoutFrequency
    taxFormSubmitted?: BoolFieldUpdateOperationsInput | boolean
    w9Submitted?: BoolFieldUpdateOperationsInput | boolean
    defaultContentAccess?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    watermarkContent?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type CreatorSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    showPublicProfile?: BoolFieldUpdateOperationsInput | boolean
    allowDMs?: BoolFieldUpdateOperationsInput | boolean
    minPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutFrequency?: EnumPayoutFrequencyFieldUpdateOperationsInput | $Enums.PayoutFrequency
    taxFormSubmitted?: BoolFieldUpdateOperationsInput | boolean
    w9Submitted?: BoolFieldUpdateOperationsInput | boolean
    defaultContentAccess?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    watermarkContent?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorSettingsCreateManyInput = {
    id?: string
    creatorId: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    showPublicProfile?: boolean
    allowDMs?: boolean
    minPayout?: Decimal | DecimalJsLike | number | string
    payoutFrequency?: $Enums.PayoutFrequency
    taxFormSubmitted?: boolean
    w9Submitted?: boolean
    defaultContentAccess?: $Enums.ContentAccess
    watermarkContent?: boolean
    updatedAt?: Date | string
  }

  export type CreatorSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    showPublicProfile?: BoolFieldUpdateOperationsInput | boolean
    allowDMs?: BoolFieldUpdateOperationsInput | boolean
    minPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutFrequency?: EnumPayoutFrequencyFieldUpdateOperationsInput | $Enums.PayoutFrequency
    taxFormSubmitted?: BoolFieldUpdateOperationsInput | boolean
    w9Submitted?: BoolFieldUpdateOperationsInput | boolean
    defaultContentAccess?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    watermarkContent?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    showPublicProfile?: BoolFieldUpdateOperationsInput | boolean
    allowDMs?: BoolFieldUpdateOperationsInput | boolean
    minPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutFrequency?: EnumPayoutFrequencyFieldUpdateOperationsInput | $Enums.PayoutFrequency
    taxFormSubmitted?: BoolFieldUpdateOperationsInput | boolean
    w9Submitted?: BoolFieldUpdateOperationsInput | boolean
    defaultContentAccess?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    watermarkContent?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    interval: $Enums.BillingInterval
    intervalCount?: number
    features: JsonNullValueInput | InputJsonValue
    maxDownloads?: number | null
    earlyAccess?: boolean
    exclusiveContent?: boolean
    trialPeriodDays?: number | null
    stripePriceId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutSubscriptionPlansInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string
    creatorId: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    interval: $Enums.BillingInterval
    intervalCount?: number
    features: JsonNullValueInput | InputJsonValue
    maxDownloads?: number | null
    earlyAccess?: boolean
    exclusiveContent?: boolean
    trialPeriodDays?: number | null
    stripePriceId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    maxDownloads?: NullableIntFieldUpdateOperationsInput | number | null
    earlyAccess?: BoolFieldUpdateOperationsInput | boolean
    exclusiveContent?: BoolFieldUpdateOperationsInput | boolean
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutSubscriptionPlansNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    maxDownloads?: NullableIntFieldUpdateOperationsInput | number | null
    earlyAccess?: BoolFieldUpdateOperationsInput | boolean
    exclusiveContent?: BoolFieldUpdateOperationsInput | boolean
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: string
    creatorId: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    interval: $Enums.BillingInterval
    intervalCount?: number
    features: JsonNullValueInput | InputJsonValue
    maxDownloads?: number | null
    earlyAccess?: boolean
    exclusiveContent?: boolean
    trialPeriodDays?: number | null
    stripePriceId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    maxDownloads?: NullableIntFieldUpdateOperationsInput | number | null
    earlyAccess?: BoolFieldUpdateOperationsInput | boolean
    exclusiveContent?: BoolFieldUpdateOperationsInput | boolean
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    maxDownloads?: NullableIntFieldUpdateOperationsInput | number | null
    earlyAccess?: BoolFieldUpdateOperationsInput | boolean
    exclusiveContent?: BoolFieldUpdateOperationsInput | boolean
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    type: $Enums.ProductType
    title: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    contentUrl?: string | null
    thumbnailUrl?: string | null
    previewUrl?: string | null
    accessType: $Enums.ContentAccess
    requiresSubscription?: boolean
    tags?: ProductCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    purchaseCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutProductsInput
    purchases?: PurchaseCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    creatorId: string
    type: $Enums.ProductType
    title: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    contentUrl?: string | null
    thumbnailUrl?: string | null
    previewUrl?: string | null
    accessType: $Enums.ContentAccess
    requiresSubscription?: boolean
    tags?: ProductCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    purchaseCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    requiresSubscription?: BoolFieldUpdateOperationsInput | boolean
    tags?: ProductUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    purchaseCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutProductsNestedInput
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    requiresSubscription?: BoolFieldUpdateOperationsInput | boolean
    tags?: ProductUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    purchaseCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    creatorId: string
    type: $Enums.ProductType
    title: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    contentUrl?: string | null
    thumbnailUrl?: string | null
    previewUrl?: string | null
    accessType: $Enums.ContentAccess
    requiresSubscription?: boolean
    tags?: ProductCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    purchaseCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    requiresSubscription?: BoolFieldUpdateOperationsInput | boolean
    tags?: ProductUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    purchaseCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    requiresSubscription?: BoolFieldUpdateOperationsInput | boolean
    tags?: ProductUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    purchaseCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanCreateInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutFanInput
    purchases?: PurchaseCreateNestedManyWithoutFanInput
    transactions?: TransactionCreateNestedManyWithoutFanInput
    fanRelations?: FanRelationCreateNestedManyWithoutFanInput
    campaignRecipients?: CampaignRecipientCreateNestedManyWithoutFanInput
  }

  export type FanUncheckedCreateInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutFanInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutFanInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFanInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutFanInput
    campaignRecipients?: CampaignRecipientUncheckedCreateNestedManyWithoutFanInput
  }

  export type FanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutFanNestedInput
    purchases?: PurchaseUpdateManyWithoutFanNestedInput
    transactions?: TransactionUpdateManyWithoutFanNestedInput
    fanRelations?: FanRelationUpdateManyWithoutFanNestedInput
    campaignRecipients?: CampaignRecipientUpdateManyWithoutFanNestedInput
  }

  export type FanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutFanNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutFanNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFanNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutFanNestedInput
    campaignRecipients?: CampaignRecipientUncheckedUpdateManyWithoutFanNestedInput
  }

  export type FanCreateManyInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fan: FanCreateNestedOneWithoutSubscriptionsInput
    creator: CreatorCreateNestedOneWithoutSubscribersInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    fanId: string
    creatorId: string
    planId: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fan?: FanUpdateOneRequiredWithoutSubscriptionsNestedInput
    creator?: CreatorUpdateOneRequiredWithoutSubscribersNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    fanId: string
    creatorId: string
    planId: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId?: string | null
    downloadCount?: number
    lastDownloadAt?: Date | string | null
    createdAt?: Date | string
    fan: FanCreateNestedOneWithoutPurchasesInput
    product: ProductCreateNestedOneWithoutPurchasesInput
    transaction?: TransactionCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    fanId: string
    productId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId?: string | null
    downloadCount?: number
    lastDownloadAt?: Date | string | null
    createdAt?: Date | string
    transaction?: TransactionUncheckedCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fan?: FanUpdateOneRequiredWithoutPurchasesNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchasesNestedInput
    transaction?: TransactionUpdateOneWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUncheckedUpdateOneWithoutPurchaseNestedInput
  }

  export type PurchaseCreateManyInput = {
    id?: string
    fanId: string
    productId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId?: string | null
    downloadCount?: number
    lastDownloadAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    creator: CreatorCreateNestedOneWithoutTransactionsInput
    fan?: FanCreateNestedOneWithoutTransactionsInput
    purchase?: PurchaseCreateNestedOneWithoutTransactionInput
    payout?: PayoutCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    creatorId: string
    fanId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    purchaseId?: string | null
    payoutId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutTransactionsNestedInput
    fan?: FanUpdateOneWithoutTransactionsNestedInput
    purchase?: PurchaseUpdateOneWithoutTransactionNestedInput
    payout?: PayoutUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fanId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    creatorId: string
    fanId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    purchaseId?: string | null
    payoutId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fanId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PayoutStatus
    method: $Enums.PayoutMethod
    destination?: string | null
    stripePayoutId?: string | null
    processedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutPayoutsInput
    transactions?: TransactionCreateNestedManyWithoutPayoutInput
  }

  export type PayoutUncheckedCreateInput = {
    id?: string
    creatorId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PayoutStatus
    method: $Enums.PayoutMethod
    destination?: string | null
    stripePayoutId?: string | null
    processedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutPayoutInput
  }

  export type PayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    stripePayoutId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutPayoutsNestedInput
    transactions?: TransactionUpdateManyWithoutPayoutNestedInput
  }

  export type PayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    stripePayoutId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutPayoutNestedInput
  }

  export type PayoutCreateManyInput = {
    id?: string
    creatorId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PayoutStatus
    method: $Enums.PayoutMethod
    destination?: string | null
    stripePayoutId?: string | null
    processedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    stripePayoutId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    stripePayoutId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCreateInput = {
    id?: string
    date: Date | string
    revenue?: Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: Decimal | DecimalJsLike | number | string
    productRevenue?: Decimal | DecimalJsLike | number | string
    newSubscribers?: number
    churned?: number
    activeSubscribers?: number
    pageViews?: number
    uniqueVisitors?: number
    contentViews?: number
    conversionRate?: Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    creator: CreatorCreateNestedOneWithoutAnalyticsInput
  }

  export type AnalyticsUncheckedCreateInput = {
    id?: string
    creatorId: string
    date: Date | string
    revenue?: Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: Decimal | DecimalJsLike | number | string
    productRevenue?: Decimal | DecimalJsLike | number | string
    newSubscribers?: number
    churned?: number
    activeSubscribers?: number
    pageViews?: number
    uniqueVisitors?: number
    contentViews?: number
    conversionRate?: Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newSubscribers?: IntFieldUpdateOperationsInput | number
    churned?: IntFieldUpdateOperationsInput | number
    activeSubscribers?: IntFieldUpdateOperationsInput | number
    pageViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    contentViews?: IntFieldUpdateOperationsInput | number
    conversionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type AnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newSubscribers?: IntFieldUpdateOperationsInput | number
    churned?: IntFieldUpdateOperationsInput | number
    activeSubscribers?: IntFieldUpdateOperationsInput | number
    pageViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    contentViews?: IntFieldUpdateOperationsInput | number
    conversionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCreateManyInput = {
    id?: string
    creatorId: string
    date: Date | string
    revenue?: Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: Decimal | DecimalJsLike | number | string
    productRevenue?: Decimal | DecimalJsLike | number | string
    newSubscribers?: number
    churned?: number
    activeSubscribers?: number
    pageViews?: number
    uniqueVisitors?: number
    contentViews?: number
    conversionRate?: Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newSubscribers?: IntFieldUpdateOperationsInput | number
    churned?: IntFieldUpdateOperationsInput | number
    activeSubscribers?: IntFieldUpdateOperationsInput | number
    pageViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    contentViews?: IntFieldUpdateOperationsInput | number
    conversionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newSubscribers?: IntFieldUpdateOperationsInput | number
    churned?: IntFieldUpdateOperationsInput | number
    activeSubscribers?: IntFieldUpdateOperationsInput | number
    pageViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    contentViews?: IntFieldUpdateOperationsInput | number
    conversionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanRelationCreateInput = {
    id?: string
    tags?: FanRelationCreatetagsInput | string[]
    notes?: string | null
    engagementScore?: number
    lifetimeValue?: Decimal | DecimalJsLike | number | string
    lastInteraction?: Date | string | null
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutFanRelationsInput
    fan: FanCreateNestedOneWithoutFanRelationsInput
  }

  export type FanRelationUncheckedCreateInput = {
    id?: string
    creatorId: string
    fanId: string
    tags?: FanRelationCreatetagsInput | string[]
    notes?: string | null
    engagementScore?: number
    lifetimeValue?: Decimal | DecimalJsLike | number | string
    lastInteraction?: Date | string | null
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FanRelationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: FanRelationUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOptIn?: BoolFieldUpdateOperationsInput | boolean
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutFanRelationsNestedInput
    fan?: FanUpdateOneRequiredWithoutFanRelationsNestedInput
  }

  export type FanRelationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    tags?: FanRelationUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOptIn?: BoolFieldUpdateOperationsInput | boolean
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanRelationCreateManyInput = {
    id?: string
    creatorId: string
    fanId: string
    tags?: FanRelationCreatetagsInput | string[]
    notes?: string | null
    engagementScore?: number
    lifetimeValue?: Decimal | DecimalJsLike | number | string
    lastInteraction?: Date | string | null
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FanRelationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: FanRelationUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOptIn?: BoolFieldUpdateOperationsInput | boolean
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanRelationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    tags?: FanRelationUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOptIn?: BoolFieldUpdateOperationsInput | boolean
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    type: $Enums.CampaignType
    status: $Enums.CampaignStatus
    subject?: string | null
    content: string
    targetTags?: CampaignCreatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutCampaignsInput
    recipients?: CampaignRecipientCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    creatorId: string
    name: string
    type: $Enums.CampaignType
    status: $Enums.CampaignStatus
    subject?: string | null
    content: string
    targetTags?: CampaignCreatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: CampaignRecipientUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    targetTags?: CampaignUpdatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutCampaignsNestedInput
    recipients?: CampaignRecipientUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    targetTags?: CampaignUpdatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: CampaignRecipientUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    creatorId: string
    name: string
    type: $Enums.CampaignType
    status: $Enums.CampaignStatus
    subject?: string | null
    content: string
    targetTags?: CampaignCreatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    targetTags?: CampaignUpdatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    targetTags?: CampaignUpdatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRecipientCreateInput = {
    id?: string
    status: $Enums.RecipientStatus
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutRecipientsInput
    fan: FanCreateNestedOneWithoutCampaignRecipientsInput
  }

  export type CampaignRecipientUncheckedCreateInput = {
    id?: string
    campaignId: string
    fanId: string
    status: $Enums.RecipientStatus
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
  }

  export type CampaignRecipientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutRecipientsNestedInput
    fan?: FanUpdateOneRequiredWithoutCampaignRecipientsNestedInput
  }

  export type CampaignRecipientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignRecipientCreateManyInput = {
    id?: string
    campaignId: string
    fanId: string
    status: $Enums.RecipientStatus
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
  }

  export type CampaignRecipientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignRecipientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppCreateInput = {
    id?: string
    name: string
    slug: string
    description: string
    icon?: string | null
    developer: string
    website?: string | null
    category: $Enums.AppCategory
    pricing: $Enums.AppPricing
    price?: Decimal | DecimalJsLike | number | string | null
    webhookUrl?: string | null
    scopes?: AppCreatescopesInput | string[]
    isPublished?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    installations?: InstalledAppCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description: string
    icon?: string | null
    developer: string
    website?: string | null
    category: $Enums.AppCategory
    pricing: $Enums.AppPricing
    price?: Decimal | DecimalJsLike | number | string | null
    webhookUrl?: string | null
    scopes?: AppCreatescopesInput | string[]
    isPublished?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    installations?: InstalledAppUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAppCategoryFieldUpdateOperationsInput | $Enums.AppCategory
    pricing?: EnumAppPricingFieldUpdateOperationsInput | $Enums.AppPricing
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AppUpdatescopesInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installations?: InstalledAppUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAppCategoryFieldUpdateOperationsInput | $Enums.AppCategory
    pricing?: EnumAppPricingFieldUpdateOperationsInput | $Enums.AppPricing
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AppUpdatescopesInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installations?: InstalledAppUncheckedUpdateManyWithoutAppNestedInput
  }

  export type AppCreateManyInput = {
    id?: string
    name: string
    slug: string
    description: string
    icon?: string | null
    developer: string
    website?: string | null
    category: $Enums.AppCategory
    pricing: $Enums.AppPricing
    price?: Decimal | DecimalJsLike | number | string | null
    webhookUrl?: string | null
    scopes?: AppCreatescopesInput | string[]
    isPublished?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAppCategoryFieldUpdateOperationsInput | $Enums.AppCategory
    pricing?: EnumAppPricingFieldUpdateOperationsInput | $Enums.AppPricing
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AppUpdatescopesInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAppCategoryFieldUpdateOperationsInput | $Enums.AppCategory
    pricing?: EnumAppPricingFieldUpdateOperationsInput | $Enums.AppPricing
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AppUpdatescopesInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalledAppCreateInput = {
    id?: string
    status: $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: $Enums.BillingInterval | null
    nextBilling?: Date | string | null
    installedAt?: Date | string
    uninstalledAt?: Date | string | null
    creator: CreatorCreateNestedOneWithoutInstalledAppsInput
    app: AppCreateNestedOneWithoutInstallationsInput
  }

  export type InstalledAppUncheckedCreateInput = {
    id?: string
    creatorId: string
    appId: string
    status: $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: $Enums.BillingInterval | null
    nextBilling?: Date | string | null
    installedAt?: Date | string
    uninstalledAt?: Date | string | null
  }

  export type InstalledAppUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: NullableEnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval | null
    nextBilling?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uninstalledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: CreatorUpdateOneRequiredWithoutInstalledAppsNestedInput
    app?: AppUpdateOneRequiredWithoutInstallationsNestedInput
  }

  export type InstalledAppUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: NullableEnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval | null
    nextBilling?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uninstalledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstalledAppCreateManyInput = {
    id?: string
    creatorId: string
    appId: string
    status: $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: $Enums.BillingInterval | null
    nextBilling?: Date | string | null
    installedAt?: Date | string
    uninstalledAt?: Date | string | null
  }

  export type InstalledAppUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: NullableEnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval | null
    nextBilling?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uninstalledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstalledAppUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: NullableEnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval | null
    nextBilling?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uninstalledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    actorId: string
    actorType: $Enums.ActorType
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    creator?: CreatorCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    creatorId?: string | null
    actorId: string
    actorType: $Enums.ActorType
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: StringFieldUpdateOperationsInput | string
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    creatorId?: string | null
    actorId: string
    actorType: $Enums.ActorType
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: StringFieldUpdateOperationsInput | string
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerAccountCreateInput = {
    id?: string
    tenantId?: string
    type: $Enums.LedgerAccountType
    currency: string
    ownerId?: string | null
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: LedgerEntryCreateNestedManyWithoutAccountInput
  }

  export type LedgerAccountUncheckedCreateInput = {
    id?: string
    tenantId?: string
    type: $Enums.LedgerAccountType
    currency: string
    ownerId?: string | null
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: LedgerEntryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type LedgerAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerAccountTypeFieldUpdateOperationsInput | $Enums.LedgerAccountType
    currency?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: LedgerEntryUpdateManyWithoutAccountNestedInput
  }

  export type LedgerAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerAccountTypeFieldUpdateOperationsInput | $Enums.LedgerAccountType
    currency?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type LedgerAccountCreateManyInput = {
    id?: string
    tenantId?: string
    type: $Enums.LedgerAccountType
    currency: string
    ownerId?: string | null
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerAccountTypeFieldUpdateOperationsInput | $Enums.LedgerAccountType
    currency?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerAccountTypeFieldUpdateOperationsInput | $Enums.LedgerAccountType
    currency?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerTransactionCreateInput = {
    id?: string
    tenantId?: string
    kind: $Enums.LedgerTransactionKind
    currency: string
    occurredAt: Date | string
    memo?: string | null
    source?: string | null
    extRef?: string | null
    stripeEventId?: string | null
    idempotencyKey?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    entries?: LedgerEntryCreateNestedManyWithoutTransactionInput
  }

  export type LedgerTransactionUncheckedCreateInput = {
    id?: string
    tenantId?: string
    kind: $Enums.LedgerTransactionKind
    currency: string
    occurredAt: Date | string
    memo?: string | null
    source?: string | null
    extRef?: string | null
    stripeEventId?: string | null
    idempotencyKey?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    entries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type LedgerTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLedgerTransactionKindFieldUpdateOperationsInput | $Enums.LedgerTransactionKind
    currency?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEventId?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
  }

  export type LedgerTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLedgerTransactionKindFieldUpdateOperationsInput | $Enums.LedgerTransactionKind
    currency?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEventId?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type LedgerTransactionCreateManyInput = {
    id?: string
    tenantId?: string
    kind: $Enums.LedgerTransactionKind
    currency: string
    occurredAt: Date | string
    memo?: string | null
    source?: string | null
    extRef?: string | null
    stripeEventId?: string | null
    idempotencyKey?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
  }

  export type LedgerTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLedgerTransactionKindFieldUpdateOperationsInput | $Enums.LedgerTransactionKind
    currency?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEventId?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLedgerTransactionKindFieldUpdateOperationsInput | $Enums.LedgerTransactionKind
    currency?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEventId?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateInput = {
    id?: string
    direction: $Enums.LedgerDirection
    amountCents: bigint | number
    currency: string
    createdAt?: Date | string
    transaction: LedgerTransactionCreateNestedOneWithoutEntriesInput
    account: LedgerAccountCreateNestedOneWithoutEntriesInput
  }

  export type LedgerEntryUncheckedCreateInput = {
    id?: string
    txId: string
    accountId: string
    direction: $Enums.LedgerDirection
    amountCents: bigint | number
    currency: string
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: LedgerTransactionUpdateOneRequiredWithoutEntriesNestedInput
    account?: LedgerAccountUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    txId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyInput = {
    id?: string
    txId: string
    accountId: string
    direction: $Enums.LedgerDirection
    amountCents: bigint | number
    currency: string
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    txId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionCapMonthlyCreateInput = {
    id?: string
    creatorId: string
    yearMonth: string
    currency: string
    capCents: bigint | number
    appliedCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionCapMonthlyUncheckedCreateInput = {
    id?: string
    creatorId: string
    yearMonth: string
    currency: string
    capCents: bigint | number
    appliedCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionCapMonthlyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    yearMonth?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    capCents?: BigIntFieldUpdateOperationsInput | bigint | number
    appliedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionCapMonthlyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    yearMonth?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    capCents?: BigIntFieldUpdateOperationsInput | bigint | number
    appliedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionCapMonthlyCreateManyInput = {
    id?: string
    creatorId: string
    yearMonth: string
    currency: string
    capCents: bigint | number
    appliedCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionCapMonthlyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    yearMonth?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    capCents?: BigIntFieldUpdateOperationsInput | bigint | number
    appliedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionCapMonthlyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    yearMonth?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    capCents?: BigIntFieldUpdateOperationsInput | bigint | number
    appliedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalEarningsSourceCreateInput = {
    id?: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    externalHandle: string
    currency: string
    connectedAt?: Date | string
    active?: boolean
    lastSync?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imports?: ExternalEarningsImportCreateNestedManyWithoutSourceInput
    earnings?: NormalizedEarningCreateNestedManyWithoutSourceInput
  }

  export type ExternalEarningsSourceUncheckedCreateInput = {
    id?: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    externalHandle: string
    currency: string
    connectedAt?: Date | string
    active?: boolean
    lastSync?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imports?: ExternalEarningsImportUncheckedCreateNestedManyWithoutSourceInput
    earnings?: NormalizedEarningUncheckedCreateNestedManyWithoutSourceInput
  }

  export type ExternalEarningsSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    externalHandle?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imports?: ExternalEarningsImportUpdateManyWithoutSourceNestedInput
    earnings?: NormalizedEarningUpdateManyWithoutSourceNestedInput
  }

  export type ExternalEarningsSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    externalHandle?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imports?: ExternalEarningsImportUncheckedUpdateManyWithoutSourceNestedInput
    earnings?: NormalizedEarningUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type ExternalEarningsSourceCreateManyInput = {
    id?: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    externalHandle: string
    currency: string
    connectedAt?: Date | string
    active?: boolean
    lastSync?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExternalEarningsSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    externalHandle?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExternalEarningsSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    externalHandle?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExternalEarningsImportCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    rawHash: string
    rawJson: JsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    source: ExternalEarningsSourceCreateNestedOneWithoutImportsInput
  }

  export type ExternalEarningsImportUncheckedCreateInput = {
    id?: string
    sourceId: string
    periodStart: Date | string
    periodEnd: Date | string
    rawHash: string
    rawJson: JsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type ExternalEarningsImportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    rawHash?: StringFieldUpdateOperationsInput | string
    rawJson?: JsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: ExternalEarningsSourceUpdateOneRequiredWithoutImportsNestedInput
  }

  export type ExternalEarningsImportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    rawHash?: StringFieldUpdateOperationsInput | string
    rawJson?: JsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalEarningsImportCreateManyInput = {
    id?: string
    sourceId: string
    periodStart: Date | string
    periodEnd: Date | string
    rawHash: string
    rawJson: JsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type ExternalEarningsImportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    rawHash?: StringFieldUpdateOperationsInput | string
    rawJson?: JsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalEarningsImportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    rawHash?: StringFieldUpdateOperationsInput | string
    rawJson?: JsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NormalizedEarningCreateInput = {
    id?: string
    occurredAt: Date | string
    currency: string
    grossCents: bigint | number
    feesCents: bigint | number
    netCents: bigint | number
    payoutId?: string | null
    extRef?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    source: ExternalEarningsSourceCreateNestedOneWithoutEarningsInput
  }

  export type NormalizedEarningUncheckedCreateInput = {
    id?: string
    sourceId: string
    occurredAt: Date | string
    currency: string
    grossCents: bigint | number
    feesCents: bigint | number
    netCents: bigint | number
    payoutId?: string | null
    extRef?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NormalizedEarningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    grossCents?: BigIntFieldUpdateOperationsInput | bigint | number
    feesCents?: BigIntFieldUpdateOperationsInput | bigint | number
    netCents?: BigIntFieldUpdateOperationsInput | bigint | number
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: ExternalEarningsSourceUpdateOneRequiredWithoutEarningsNestedInput
  }

  export type NormalizedEarningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    grossCents?: BigIntFieldUpdateOperationsInput | bigint | number
    feesCents?: BigIntFieldUpdateOperationsInput | bigint | number
    netCents?: BigIntFieldUpdateOperationsInput | bigint | number
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NormalizedEarningCreateManyInput = {
    id?: string
    sourceId: string
    occurredAt: Date | string
    currency: string
    grossCents: bigint | number
    feesCents: bigint | number
    netCents: bigint | number
    payoutId?: string | null
    extRef?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NormalizedEarningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    grossCents?: BigIntFieldUpdateOperationsInput | bigint | number
    feesCents?: BigIntFieldUpdateOperationsInput | bigint | number
    netCents?: BigIntFieldUpdateOperationsInput | bigint | number
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NormalizedEarningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    grossCents?: BigIntFieldUpdateOperationsInput | bigint | number
    feesCents?: BigIntFieldUpdateOperationsInput | bigint | number
    netCents?: BigIntFieldUpdateOperationsInput | bigint | number
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionStatementCreateInput = {
    id?: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    yearMonth: string
    currency: string
    baseNetCents: bigint | number
    rateBps: number
    commissionCents: bigint | number
    capAppliedCents: bigint | number
    finalCents: bigint | number
    closedAt?: Date | string | null
    invoicedAt?: Date | string | null
    stripeInvoiceId?: string | null
    paidAt?: Date | string | null
    writeOffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionStatementUncheckedCreateInput = {
    id?: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    yearMonth: string
    currency: string
    baseNetCents: bigint | number
    rateBps: number
    commissionCents: bigint | number
    capAppliedCents: bigint | number
    finalCents: bigint | number
    closedAt?: Date | string | null
    invoicedAt?: Date | string | null
    stripeInvoiceId?: string | null
    paidAt?: Date | string | null
    writeOffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionStatementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    yearMonth?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    baseNetCents?: BigIntFieldUpdateOperationsInput | bigint | number
    rateBps?: IntFieldUpdateOperationsInput | number
    commissionCents?: BigIntFieldUpdateOperationsInput | bigint | number
    capAppliedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    finalCents?: BigIntFieldUpdateOperationsInput | bigint | number
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    writeOffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionStatementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    yearMonth?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    baseNetCents?: BigIntFieldUpdateOperationsInput | bigint | number
    rateBps?: IntFieldUpdateOperationsInput | number
    commissionCents?: BigIntFieldUpdateOperationsInput | bigint | number
    capAppliedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    finalCents?: BigIntFieldUpdateOperationsInput | bigint | number
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    writeOffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionStatementCreateManyInput = {
    id?: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    yearMonth: string
    currency: string
    baseNetCents: bigint | number
    rateBps: number
    commissionCents: bigint | number
    capAppliedCents: bigint | number
    finalCents: bigint | number
    closedAt?: Date | string | null
    invoicedAt?: Date | string | null
    stripeInvoiceId?: string | null
    paidAt?: Date | string | null
    writeOffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionStatementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    yearMonth?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    baseNetCents?: BigIntFieldUpdateOperationsInput | bigint | number
    rateBps?: IntFieldUpdateOperationsInput | number
    commissionCents?: BigIntFieldUpdateOperationsInput | bigint | number
    capAppliedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    finalCents?: BigIntFieldUpdateOperationsInput | bigint | number
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    writeOffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionStatementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    yearMonth?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    baseNetCents?: BigIntFieldUpdateOperationsInput | bigint | number
    rateBps?: IntFieldUpdateOperationsInput | number
    commissionCents?: BigIntFieldUpdateOperationsInput | bigint | number
    capAppliedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    finalCents?: BigIntFieldUpdateOperationsInput | bigint | number
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    writeOffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DunningStateCreateInput = {
    id?: string
    invoiceId: string
    creatorId: string
    attemptCount?: number
    status: $Enums.DunningStatus
    lastAttempt?: Date | string | null
    nextAttempt?: Date | string | null
    recoveredAt?: Date | string | null
    writeOffAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DunningStateUncheckedCreateInput = {
    id?: string
    invoiceId: string
    creatorId: string
    attemptCount?: number
    status: $Enums.DunningStatus
    lastAttempt?: Date | string | null
    nextAttempt?: Date | string | null
    recoveredAt?: Date | string | null
    writeOffAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DunningStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    status?: EnumDunningStatusFieldUpdateOperationsInput | $Enums.DunningStatus
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    writeOffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DunningStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    status?: EnumDunningStatusFieldUpdateOperationsInput | $Enums.DunningStatus
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    writeOffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DunningStateCreateManyInput = {
    id?: string
    invoiceId: string
    creatorId: string
    attemptCount?: number
    status: $Enums.DunningStatus
    lastAttempt?: Date | string | null
    nextAttempt?: Date | string | null
    recoveredAt?: Date | string | null
    writeOffAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DunningStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    status?: EnumDunningStatusFieldUpdateOperationsInput | $Enums.DunningStatus
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    writeOffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DunningStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    status?: EnumDunningStatusFieldUpdateOperationsInput | $Enums.DunningStatus
    lastAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    writeOffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAttemptCreateInput = {
    id?: string
    invoiceId: string
    attemptNumber: number
    status: string
    errorCode?: string | null
    errorMessage?: string | null
    paymentMethodId?: string | null
    amount: bigint | number
    currency: string
    createdAt?: Date | string
  }

  export type PaymentAttemptUncheckedCreateInput = {
    id?: string
    invoiceId: string
    attemptNumber: number
    status: string
    errorCode?: string | null
    errorMessage?: string | null
    paymentMethodId?: string | null
    amount: bigint | number
    currency: string
    createdAt?: Date | string
  }

  export type PaymentAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAttemptCreateManyInput = {
    id?: string
    invoiceId: string
    attemptNumber: number
    status: string
    errorCode?: string | null
    errorMessage?: string | null
    paymentMethodId?: string | null
    amount: bigint | number
    currency: string
    createdAt?: Date | string
  }

  export type PaymentAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationCreateInput = {
    id?: string
    creatorId: string
    name: string
    triggerType: $Enums.AutomationTrigger
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    status?: $Enums.AutomationStatus
    lastRun?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationUncheckedCreateInput = {
    id?: string
    creatorId: string
    name: string
    triggerType: $Enums.AutomationTrigger
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    status?: $Enums.AutomationStatus
    lastRun?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: EnumAutomationTriggerFieldUpdateOperationsInput | $Enums.AutomationTrigger
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: EnumAutomationTriggerFieldUpdateOperationsInput | $Enums.AutomationTrigger
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationCreateManyInput = {
    id?: string
    creatorId: string
    name: string
    triggerType: $Enums.AutomationTrigger
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    status?: $Enums.AutomationStatus
    lastRun?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: EnumAutomationTriggerFieldUpdateOperationsInput | $Enums.AutomationTrigger
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: EnumAutomationTriggerFieldUpdateOperationsInput | $Enums.AutomationTrigger
    conditions?: NullableJsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupLogCreateInput = {
    id?: string
    status: string
    duration?: number | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BackupLogUncheckedCreateInput = {
    id?: string
    status: string
    duration?: number | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BackupLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupLogCreateManyInput = {
    id?: string
    status: string
    duration?: number | null
    error?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BackupLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupValidationCreateInput = {
    id?: string
    timestamp?: Date | string
    results: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
  }

  export type BackupValidationUncheckedCreateInput = {
    id?: string
    timestamp?: Date | string
    results: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
  }

  export type BackupValidationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupValidationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupValidationCreateManyInput = {
    id?: string
    timestamp?: Date | string
    results: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
  }

  export type BackupValidationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupValidationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupIndexCreateInput = {
    id?: string
    backupId: string
    timestamp: Date | string
    metadata: JsonNullValueInput | InputJsonValue
    tables: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BackupIndexUncheckedCreateInput = {
    id?: string
    backupId: string
    timestamp: Date | string
    metadata: JsonNullValueInput | InputJsonValue
    tables: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BackupIndexUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    backupId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    tables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupIndexUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    backupId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    tables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupIndexCreateManyInput = {
    id?: string
    backupId: string
    timestamp: Date | string
    metadata: JsonNullValueInput | InputJsonValue
    tables: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BackupIndexUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    backupId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    tables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupIndexUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    backupId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    tables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogCreateInput = {
    id?: string
    provider: string
    model: string
    purpose: string
    userId: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    cost: number
    cached?: boolean
    timestamp?: Date | string
  }

  export type AIUsageLogUncheckedCreateInput = {
    id?: string
    provider: string
    model: string
    purpose: string
    userId: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    cost: number
    cached?: boolean
    timestamp?: Date | string
  }

  export type AIUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    cached?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    cached?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogCreateManyInput = {
    id?: string
    provider: string
    model: string
    purpose: string
    userId: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    cost: number
    cached?: boolean
    timestamp?: Date | string
  }

  export type AIUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    cached?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    cached?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostReservationCreateInput = {
    id?: string
    provider: string
    service: string
    commitment: string
    units: number
    unitPrice: number
    savings: number
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostReservationUncheckedCreateInput = {
    id?: string
    provider: string
    service: string
    commitment: string
    units: number
    unitPrice: number
    savings: number
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    commitment?: StringFieldUpdateOperationsInput | string
    units?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    savings?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    commitment?: StringFieldUpdateOperationsInput | string
    units?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    savings?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostReservationCreateManyInput = {
    id?: string
    provider: string
    service: string
    commitment: string
    units: number
    unitPrice: number
    savings: number
    startDate: Date | string
    endDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    commitment?: StringFieldUpdateOperationsInput | string
    units?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    savings?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    commitment?: StringFieldUpdateOperationsInput | string
    units?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    savings?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptOptimizationCreateInput = {
    id?: string
    userId: string
    originalPrompt: string
    optimizedPrompt: string
    originalTokens: number
    optimizedTokens: number
    tokenReduction: number
    qualityScore?: number | null
    abTestResults?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type PromptOptimizationUncheckedCreateInput = {
    id?: string
    userId: string
    originalPrompt: string
    optimizedPrompt: string
    originalTokens: number
    optimizedTokens: number
    tokenReduction: number
    qualityScore?: number | null
    abTestResults?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type PromptOptimizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    originalPrompt?: StringFieldUpdateOperationsInput | string
    optimizedPrompt?: StringFieldUpdateOperationsInput | string
    originalTokens?: IntFieldUpdateOperationsInput | number
    optimizedTokens?: IntFieldUpdateOperationsInput | number
    tokenReduction?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    abTestResults?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptOptimizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    originalPrompt?: StringFieldUpdateOperationsInput | string
    optimizedPrompt?: StringFieldUpdateOperationsInput | string
    originalTokens?: IntFieldUpdateOperationsInput | number
    optimizedTokens?: IntFieldUpdateOperationsInput | number
    tokenReduction?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    abTestResults?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptOptimizationCreateManyInput = {
    id?: string
    userId: string
    originalPrompt: string
    optimizedPrompt: string
    originalTokens: number
    optimizedTokens: number
    tokenReduction: number
    qualityScore?: number | null
    abTestResults?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type PromptOptimizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    originalPrompt?: StringFieldUpdateOperationsInput | string
    optimizedPrompt?: StringFieldUpdateOperationsInput | string
    originalTokens?: IntFieldUpdateOperationsInput | number
    optimizedTokens?: IntFieldUpdateOperationsInput | number
    tokenReduction?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    abTestResults?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptOptimizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    originalPrompt?: StringFieldUpdateOperationsInput | string
    optimizedPrompt?: StringFieldUpdateOperationsInput | string
    originalTokens?: IntFieldUpdateOperationsInput | number
    optimizedTokens?: IntFieldUpdateOperationsInput | number
    tokenReduction?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    abTestResults?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostAlertCreateInput = {
    id?: string
    type: string
    service: string
    threshold: number
    current: number
    message: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CostAlertUncheckedCreateInput = {
    id?: string
    type: string
    service: string
    threshold: number
    current: number
    message: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CostAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    current?: FloatFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    current?: FloatFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostAlertCreateManyInput = {
    id?: string
    type: string
    service: string
    threshold: number
    current: number
    message: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CostAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    current?: FloatFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    current?: FloatFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumKycStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusFilter<$PrismaModel> | $Enums.KycStatus
  }

  export type EnumCommissionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionTier | EnumCommissionTierFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionTier[] | ListEnumCommissionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionTier[] | ListEnumCommissionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionTierFilter<$PrismaModel> | $Enums.CommissionTier
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SubscriptionPlanListRelationFilter = {
    every?: SubscriptionPlanWhereInput
    some?: SubscriptionPlanWhereInput
    none?: SubscriptionPlanWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type PayoutListRelationFilter = {
    every?: PayoutWhereInput
    some?: PayoutWhereInput
    none?: PayoutWhereInput
  }

  export type AnalyticsListRelationFilter = {
    every?: AnalyticsWhereInput
    some?: AnalyticsWhereInput
    none?: AnalyticsWhereInput
  }

  export type InstalledAppListRelationFilter = {
    every?: InstalledAppWhereInput
    some?: InstalledAppWhereInput
    none?: InstalledAppWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type CreatorSettingsNullableRelationFilter = {
    is?: CreatorSettingsWhereInput | null
    isNot?: CreatorSettingsWhereInput | null
  }

  export type FanRelationListRelationFilter = {
    every?: FanRelationWhereInput
    some?: FanRelationWhereInput
    none?: FanRelationWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SubscriptionPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstalledAppOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FanRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatorCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    stripeAccountId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeConnected?: SortOrder
    kycStatus?: SortOrder
    commissionTier?: SortOrder
    totalRevenue?: SortOrder
    availableBalance?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    onboardingCompleted?: SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    phoneNumber?: SortOrder
    smsOptIn?: SortOrder
    currentPlan?: SortOrder
    accountStatus?: SortOrder
    planDowngradedAt?: SortOrder
    planDowngradeReason?: SortOrder
    suspendedAt?: SortOrder
    suspensionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreatorAvgOrderByAggregateInput = {
    totalRevenue?: SortOrder
    availableBalance?: SortOrder
  }

  export type CreatorMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    stripeAccountId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeConnected?: SortOrder
    kycStatus?: SortOrder
    commissionTier?: SortOrder
    totalRevenue?: SortOrder
    availableBalance?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    onboardingCompleted?: SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    phoneNumber?: SortOrder
    smsOptIn?: SortOrder
    currentPlan?: SortOrder
    accountStatus?: SortOrder
    planDowngradedAt?: SortOrder
    planDowngradeReason?: SortOrder
    suspendedAt?: SortOrder
    suspensionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreatorMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    stripeAccountId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeConnected?: SortOrder
    kycStatus?: SortOrder
    commissionTier?: SortOrder
    totalRevenue?: SortOrder
    availableBalance?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    onboardingCompleted?: SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    phoneNumber?: SortOrder
    smsOptIn?: SortOrder
    currentPlan?: SortOrder
    accountStatus?: SortOrder
    planDowngradedAt?: SortOrder
    planDowngradeReason?: SortOrder
    suspendedAt?: SortOrder
    suspensionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreatorSumOrderByAggregateInput = {
    totalRevenue?: SortOrder
    availableBalance?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumKycStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusWithAggregatesFilter<$PrismaModel> | $Enums.KycStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKycStatusFilter<$PrismaModel>
    _max?: NestedEnumKycStatusFilter<$PrismaModel>
  }

  export type EnumCommissionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionTier | EnumCommissionTierFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionTier[] | ListEnumCommissionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionTier[] | ListEnumCommissionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionTierWithAggregatesFilter<$PrismaModel> | $Enums.CommissionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommissionTierFilter<$PrismaModel>
    _max?: NestedEnumCommissionTierFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPayoutFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutFrequency | EnumPayoutFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutFrequency[] | ListEnumPayoutFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutFrequency[] | ListEnumPayoutFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutFrequencyFilter<$PrismaModel> | $Enums.PayoutFrequency
  }

  export type EnumContentAccessFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentAccess | EnumContentAccessFieldRefInput<$PrismaModel>
    in?: $Enums.ContentAccess[] | ListEnumContentAccessFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentAccess[] | ListEnumContentAccessFieldRefInput<$PrismaModel>
    not?: NestedEnumContentAccessFilter<$PrismaModel> | $Enums.ContentAccess
  }

  export type CreatorRelationFilter = {
    is?: CreatorWhereInput
    isNot?: CreatorWhereInput
  }

  export type CreatorSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    showPublicProfile?: SortOrder
    allowDMs?: SortOrder
    minPayout?: SortOrder
    payoutFrequency?: SortOrder
    taxFormSubmitted?: SortOrder
    w9Submitted?: SortOrder
    defaultContentAccess?: SortOrder
    watermarkContent?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreatorSettingsAvgOrderByAggregateInput = {
    minPayout?: SortOrder
  }

  export type CreatorSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    showPublicProfile?: SortOrder
    allowDMs?: SortOrder
    minPayout?: SortOrder
    payoutFrequency?: SortOrder
    taxFormSubmitted?: SortOrder
    w9Submitted?: SortOrder
    defaultContentAccess?: SortOrder
    watermarkContent?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreatorSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    showPublicProfile?: SortOrder
    allowDMs?: SortOrder
    minPayout?: SortOrder
    payoutFrequency?: SortOrder
    taxFormSubmitted?: SortOrder
    w9Submitted?: SortOrder
    defaultContentAccess?: SortOrder
    watermarkContent?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreatorSettingsSumOrderByAggregateInput = {
    minPayout?: SortOrder
  }

  export type EnumPayoutFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutFrequency | EnumPayoutFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutFrequency[] | ListEnumPayoutFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutFrequency[] | ListEnumPayoutFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.PayoutFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutFrequencyFilter<$PrismaModel>
    _max?: NestedEnumPayoutFrequencyFilter<$PrismaModel>
  }

  export type EnumContentAccessWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentAccess | EnumContentAccessFieldRefInput<$PrismaModel>
    in?: $Enums.ContentAccess[] | ListEnumContentAccessFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentAccess[] | ListEnumContentAccessFieldRefInput<$PrismaModel>
    not?: NestedEnumContentAccessWithAggregatesFilter<$PrismaModel> | $Enums.ContentAccess
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentAccessFilter<$PrismaModel>
    _max?: NestedEnumContentAccessFilter<$PrismaModel>
  }

  export type EnumBillingIntervalFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingInterval | EnumBillingIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingIntervalFilter<$PrismaModel> | $Enums.BillingInterval
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SubscriptionPlanCreatorIdNameCompoundUniqueInput = {
    creatorId: string
    name: string
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    features?: SortOrder
    maxDownloads?: SortOrder
    earlyAccess?: SortOrder
    exclusiveContent?: SortOrder
    trialPeriodDays?: SortOrder
    stripePriceId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    price?: SortOrder
    intervalCount?: SortOrder
    maxDownloads?: SortOrder
    trialPeriodDays?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    maxDownloads?: SortOrder
    earlyAccess?: SortOrder
    exclusiveContent?: SortOrder
    trialPeriodDays?: SortOrder
    stripePriceId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    maxDownloads?: SortOrder
    earlyAccess?: SortOrder
    exclusiveContent?: SortOrder
    trialPeriodDays?: SortOrder
    stripePriceId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    price?: SortOrder
    intervalCount?: SortOrder
    maxDownloads?: SortOrder
    trialPeriodDays?: SortOrder
  }

  export type EnumBillingIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingInterval | EnumBillingIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingIntervalWithAggregatesFilter<$PrismaModel> | $Enums.BillingInterval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingIntervalFilter<$PrismaModel>
    _max?: NestedEnumBillingIntervalFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    contentUrl?: SortOrder
    thumbnailUrl?: SortOrder
    previewUrl?: SortOrder
    accessType?: SortOrder
    requiresSubscription?: SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    purchaseCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    viewCount?: SortOrder
    purchaseCount?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    contentUrl?: SortOrder
    thumbnailUrl?: SortOrder
    previewUrl?: SortOrder
    accessType?: SortOrder
    requiresSubscription?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    purchaseCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    contentUrl?: SortOrder
    thumbnailUrl?: SortOrder
    previewUrl?: SortOrder
    accessType?: SortOrder
    requiresSubscription?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    purchaseCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    viewCount?: SortOrder
    purchaseCount?: SortOrder
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type CampaignRecipientListRelationFilter = {
    every?: CampaignRecipientWhereInput
    some?: CampaignRecipientWhereInput
    none?: CampaignRecipientWhereInput
  }

  export type CampaignRecipientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FanCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    stripeCustomerId?: SortOrder
    emailVerified?: SortOrder
    phoneNumber?: SortOrder
    phoneVerified?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FanMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    stripeCustomerId?: SortOrder
    emailVerified?: SortOrder
    phoneNumber?: SortOrder
    phoneVerified?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FanMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    stripeCustomerId?: SortOrder
    emailVerified?: SortOrder
    phoneNumber?: SortOrder
    phoneVerified?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type FanRelationFilter = {
    is?: FanWhereInput
    isNot?: FanWhereInput
  }

  export type SubscriptionPlanRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type SubscriptionFanIdCreatorIdPlanIdCompoundUniqueInput = {
    fanId: string
    creatorId: string
    planId: string
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    fanId?: SortOrder
    creatorId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    endedAt?: SortOrder
    stripeSubscriptionId?: SortOrder
    totalSpent?: SortOrder
    renewalCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    totalSpent?: SortOrder
    renewalCount?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    fanId?: SortOrder
    creatorId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    endedAt?: SortOrder
    stripeSubscriptionId?: SortOrder
    totalSpent?: SortOrder
    renewalCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    fanId?: SortOrder
    creatorId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    endedAt?: SortOrder
    stripeSubscriptionId?: SortOrder
    totalSpent?: SortOrder
    renewalCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    totalSpent?: SortOrder
    renewalCount?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type TransactionNullableRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    fanId?: SortOrder
    productId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrder
    downloadCount?: SortOrder
    lastDownloadAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    amount?: SortOrder
    downloadCount?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    fanId?: SortOrder
    productId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrder
    downloadCount?: SortOrder
    lastDownloadAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    fanId?: SortOrder
    productId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrder
    downloadCount?: SortOrder
    lastDownloadAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    amount?: SortOrder
    downloadCount?: SortOrder
  }

  export type EnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FanNullableRelationFilter = {
    is?: FanWhereInput | null
    isNot?: FanWhereInput | null
  }

  export type PurchaseNullableRelationFilter = {
    is?: PurchaseWhereInput | null
    isNot?: PurchaseWhereInput | null
  }

  export type PayoutNullableRelationFilter = {
    is?: PayoutWhereInput | null
    isNot?: PayoutWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    fanId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    platformFee?: SortOrder
    platformFeeRate?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    subscriptionId?: SortOrder
    purchaseId?: SortOrder
    payoutId?: SortOrder
    stripeTransferId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    platformFee?: SortOrder
    platformFeeRate?: SortOrder
    netAmount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    fanId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    platformFee?: SortOrder
    platformFeeRate?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    subscriptionId?: SortOrder
    purchaseId?: SortOrder
    payoutId?: SortOrder
    stripeTransferId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    fanId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    platformFee?: SortOrder
    platformFeeRate?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    subscriptionId?: SortOrder
    purchaseId?: SortOrder
    payoutId?: SortOrder
    stripeTransferId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    platformFee?: SortOrder
    platformFeeRate?: SortOrder
    netAmount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type EnumPayoutMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutMethod | EnumPayoutMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutMethodFilter<$PrismaModel> | $Enums.PayoutMethod
  }

  export type PayoutCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    destination?: SortOrder
    stripePayoutId?: SortOrder
    processedAt?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayoutAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    destination?: SortOrder
    stripePayoutId?: SortOrder
    processedAt?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayoutMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    destination?: SortOrder
    stripePayoutId?: SortOrder
    processedAt?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayoutSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type EnumPayoutMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutMethod | EnumPayoutMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutMethodWithAggregatesFilter<$PrismaModel> | $Enums.PayoutMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutMethodFilter<$PrismaModel>
    _max?: NestedEnumPayoutMethodFilter<$PrismaModel>
  }

  export type AnalyticsCreatorIdDateCompoundUniqueInput = {
    creatorId: string
    date: Date | string
  }

  export type AnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    subscriptionRevenue?: SortOrder
    productRevenue?: SortOrder
    newSubscribers?: SortOrder
    churned?: SortOrder
    activeSubscribers?: SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    contentViews?: SortOrder
    conversionRate?: SortOrder
    avgOrderValue?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAvgOrderByAggregateInput = {
    revenue?: SortOrder
    subscriptionRevenue?: SortOrder
    productRevenue?: SortOrder
    newSubscribers?: SortOrder
    churned?: SortOrder
    activeSubscribers?: SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    contentViews?: SortOrder
    conversionRate?: SortOrder
    avgOrderValue?: SortOrder
  }

  export type AnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    subscriptionRevenue?: SortOrder
    productRevenue?: SortOrder
    newSubscribers?: SortOrder
    churned?: SortOrder
    activeSubscribers?: SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    contentViews?: SortOrder
    conversionRate?: SortOrder
    avgOrderValue?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    subscriptionRevenue?: SortOrder
    productRevenue?: SortOrder
    newSubscribers?: SortOrder
    churned?: SortOrder
    activeSubscribers?: SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    contentViews?: SortOrder
    conversionRate?: SortOrder
    avgOrderValue?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsSumOrderByAggregateInput = {
    revenue?: SortOrder
    subscriptionRevenue?: SortOrder
    productRevenue?: SortOrder
    newSubscribers?: SortOrder
    churned?: SortOrder
    activeSubscribers?: SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    contentViews?: SortOrder
    conversionRate?: SortOrder
    avgOrderValue?: SortOrder
  }

  export type FanRelationCreatorIdFanIdCompoundUniqueInput = {
    creatorId: string
    fanId: string
  }

  export type FanRelationCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    fanId?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    engagementScore?: SortOrder
    lifetimeValue?: SortOrder
    lastInteraction?: SortOrder
    emailOptIn?: SortOrder
    smsOptIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FanRelationAvgOrderByAggregateInput = {
    engagementScore?: SortOrder
    lifetimeValue?: SortOrder
  }

  export type FanRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    fanId?: SortOrder
    notes?: SortOrder
    engagementScore?: SortOrder
    lifetimeValue?: SortOrder
    lastInteraction?: SortOrder
    emailOptIn?: SortOrder
    smsOptIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FanRelationMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    fanId?: SortOrder
    notes?: SortOrder
    engagementScore?: SortOrder
    lifetimeValue?: SortOrder
    lastInteraction?: SortOrder
    emailOptIn?: SortOrder
    smsOptIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FanRelationSumOrderByAggregateInput = {
    engagementScore?: SortOrder
    lifetimeValue?: SortOrder
  }

  export type EnumCampaignTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignTypeFilter<$PrismaModel> | $Enums.CampaignType
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    targetTags?: SortOrder
    targetSegment?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
  }

  export type EnumCampaignTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignTypeFilter<$PrismaModel>
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type EnumRecipientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipientStatus | EnumRecipientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipientStatusFilter<$PrismaModel> | $Enums.RecipientStatus
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignRecipientCampaignIdFanIdCompoundUniqueInput = {
    campaignId: string
    fanId: string
  }

  export type CampaignRecipientCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    fanId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
  }

  export type CampaignRecipientMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    fanId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
  }

  export type CampaignRecipientMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    fanId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    openedAt?: SortOrder
    clickedAt?: SortOrder
  }

  export type EnumRecipientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipientStatus | EnumRecipientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipientStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecipientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecipientStatusFilter<$PrismaModel>
    _max?: NestedEnumRecipientStatusFilter<$PrismaModel>
  }

  export type EnumAppCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AppCategory | EnumAppCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AppCategory[] | ListEnumAppCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppCategory[] | ListEnumAppCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAppCategoryFilter<$PrismaModel> | $Enums.AppCategory
  }

  export type EnumAppPricingFilter<$PrismaModel = never> = {
    equals?: $Enums.AppPricing | EnumAppPricingFieldRefInput<$PrismaModel>
    in?: $Enums.AppPricing[] | ListEnumAppPricingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppPricing[] | ListEnumAppPricingFieldRefInput<$PrismaModel>
    not?: NestedEnumAppPricingFilter<$PrismaModel> | $Enums.AppPricing
  }

  export type AppCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    developer?: SortOrder
    website?: SortOrder
    category?: SortOrder
    pricing?: SortOrder
    price?: SortOrder
    webhookUrl?: SortOrder
    scopes?: SortOrder
    isPublished?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type AppMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    developer?: SortOrder
    website?: SortOrder
    category?: SortOrder
    pricing?: SortOrder
    price?: SortOrder
    webhookUrl?: SortOrder
    isPublished?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    developer?: SortOrder
    website?: SortOrder
    category?: SortOrder
    pricing?: SortOrder
    price?: SortOrder
    webhookUrl?: SortOrder
    isPublished?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumAppCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppCategory | EnumAppCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AppCategory[] | ListEnumAppCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppCategory[] | ListEnumAppCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAppCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AppCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppCategoryFilter<$PrismaModel>
    _max?: NestedEnumAppCategoryFilter<$PrismaModel>
  }

  export type EnumAppPricingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppPricing | EnumAppPricingFieldRefInput<$PrismaModel>
    in?: $Enums.AppPricing[] | ListEnumAppPricingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppPricing[] | ListEnumAppPricingFieldRefInput<$PrismaModel>
    not?: NestedEnumAppPricingWithAggregatesFilter<$PrismaModel> | $Enums.AppPricing
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppPricingFilter<$PrismaModel>
    _max?: NestedEnumAppPricingFilter<$PrismaModel>
  }

  export type EnumAppStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusFilter<$PrismaModel> | $Enums.AppStatus
  }

  export type EnumBillingIntervalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingInterval | EnumBillingIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBillingIntervalNullableFilter<$PrismaModel> | $Enums.BillingInterval | null
  }

  export type AppRelationFilter = {
    is?: AppWhereInput
    isNot?: AppWhereInput
  }

  export type InstalledAppCreatorIdAppIdCompoundUniqueInput = {
    creatorId: string
    appId: string
  }

  export type InstalledAppCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    appId?: SortOrder
    status?: SortOrder
    settings?: SortOrder
    billingCycle?: SortOrder
    nextBilling?: SortOrder
    installedAt?: SortOrder
    uninstalledAt?: SortOrder
  }

  export type InstalledAppMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    appId?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    nextBilling?: SortOrder
    installedAt?: SortOrder
    uninstalledAt?: SortOrder
  }

  export type InstalledAppMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    appId?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    nextBilling?: SortOrder
    installedAt?: SortOrder
    uninstalledAt?: SortOrder
  }

  export type EnumAppStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppStatusFilter<$PrismaModel>
    _max?: NestedEnumAppStatusFilter<$PrismaModel>
  }

  export type EnumBillingIntervalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingInterval | EnumBillingIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBillingIntervalNullableWithAggregatesFilter<$PrismaModel> | $Enums.BillingInterval | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBillingIntervalNullableFilter<$PrismaModel>
    _max?: NestedEnumBillingIntervalNullableFilter<$PrismaModel>
  }

  export type EnumActorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeFilter<$PrismaModel> | $Enums.ActorType
  }

  export type CreatorNullableRelationFilter = {
    is?: CreatorWhereInput | null
    isNot?: CreatorWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    actorId?: SortOrder
    actorType?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    actorId?: SortOrder
    actorType?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    actorId?: SortOrder
    actorType?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActorTypeFilter<$PrismaModel>
    _max?: NestedEnumActorTypeFilter<$PrismaModel>
  }

  export type EnumLedgerAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerAccountType | EnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerAccountType[] | ListEnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerAccountType[] | ListEnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerAccountTypeFilter<$PrismaModel> | $Enums.LedgerAccountType
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type LedgerEntryListRelationFilter = {
    every?: LedgerEntryWhereInput
    some?: LedgerEntryWhereInput
    none?: LedgerEntryWhereInput
  }

  export type LedgerEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LedgerAccountTenantIdTypeCurrencyOwnerIdCompoundUniqueInput = {
    tenantId: string
    type: $Enums.LedgerAccountType
    currency: string
    ownerId: string
  }

  export type LedgerAccountCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerAccountAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type LedgerAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerAccountMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerAccountSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumLedgerAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerAccountType | EnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerAccountType[] | ListEnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerAccountType[] | ListEnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerAccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerAccountTypeFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumLedgerTransactionKindFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerTransactionKind | EnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerTransactionKind[] | ListEnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerTransactionKind[] | ListEnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTransactionKindFilter<$PrismaModel> | $Enums.LedgerTransactionKind
  }

  export type LedgerTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kind?: SortOrder
    currency?: SortOrder
    occurredAt?: SortOrder
    memo?: SortOrder
    source?: SortOrder
    extRef?: SortOrder
    stripeEventId?: SortOrder
    idempotencyKey?: SortOrder
    reversedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kind?: SortOrder
    currency?: SortOrder
    occurredAt?: SortOrder
    memo?: SortOrder
    source?: SortOrder
    extRef?: SortOrder
    stripeEventId?: SortOrder
    idempotencyKey?: SortOrder
    reversedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kind?: SortOrder
    currency?: SortOrder
    occurredAt?: SortOrder
    memo?: SortOrder
    source?: SortOrder
    extRef?: SortOrder
    stripeEventId?: SortOrder
    idempotencyKey?: SortOrder
    reversedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLedgerTransactionKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerTransactionKind | EnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerTransactionKind[] | ListEnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerTransactionKind[] | ListEnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTransactionKindWithAggregatesFilter<$PrismaModel> | $Enums.LedgerTransactionKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerTransactionKindFilter<$PrismaModel>
    _max?: NestedEnumLedgerTransactionKindFilter<$PrismaModel>
  }

  export type EnumLedgerDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerDirection | EnumLedgerDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerDirectionFilter<$PrismaModel> | $Enums.LedgerDirection
  }

  export type LedgerTransactionRelationFilter = {
    is?: LedgerTransactionWhereInput
    isNot?: LedgerTransactionWhereInput
  }

  export type LedgerAccountRelationFilter = {
    is?: LedgerAccountWhereInput
    isNot?: LedgerAccountWhereInput
  }

  export type LedgerEntryCountOrderByAggregateInput = {
    id?: SortOrder
    txId?: SortOrder
    accountId?: SortOrder
    direction?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type LedgerEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    txId?: SortOrder
    accountId?: SortOrder
    direction?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryMinOrderByAggregateInput = {
    id?: SortOrder
    txId?: SortOrder
    accountId?: SortOrder
    direction?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntrySumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type EnumLedgerDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerDirection | EnumLedgerDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerDirectionWithAggregatesFilter<$PrismaModel> | $Enums.LedgerDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerDirectionFilter<$PrismaModel>
    _max?: NestedEnumLedgerDirectionFilter<$PrismaModel>
  }

  export type CommissionCapMonthlyCreatorIdYearMonthCurrencyCompoundUniqueInput = {
    creatorId: string
    yearMonth: string
    currency: string
  }

  export type CommissionCapMonthlyCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    yearMonth?: SortOrder
    currency?: SortOrder
    capCents?: SortOrder
    appliedCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionCapMonthlyAvgOrderByAggregateInput = {
    capCents?: SortOrder
    appliedCents?: SortOrder
  }

  export type CommissionCapMonthlyMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    yearMonth?: SortOrder
    currency?: SortOrder
    capCents?: SortOrder
    appliedCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionCapMonthlyMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    yearMonth?: SortOrder
    currency?: SortOrder
    capCents?: SortOrder
    appliedCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionCapMonthlySumOrderByAggregateInput = {
    capCents?: SortOrder
    appliedCents?: SortOrder
  }

  export type EnumExternalPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalPlatform | EnumExternalPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalPlatform[] | ListEnumExternalPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalPlatform[] | ListEnumExternalPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalPlatformFilter<$PrismaModel> | $Enums.ExternalPlatform
  }

  export type ExternalEarningsImportListRelationFilter = {
    every?: ExternalEarningsImportWhereInput
    some?: ExternalEarningsImportWhereInput
    none?: ExternalEarningsImportWhereInput
  }

  export type NormalizedEarningListRelationFilter = {
    every?: NormalizedEarningWhereInput
    some?: NormalizedEarningWhereInput
    none?: NormalizedEarningWhereInput
  }

  export type ExternalEarningsImportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NormalizedEarningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExternalEarningsSourceCreatorIdPlatformExternalHandleCompoundUniqueInput = {
    creatorId: string
    platform: $Enums.ExternalPlatform
    externalHandle: string
  }

  export type ExternalEarningsSourceCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    platform?: SortOrder
    externalHandle?: SortOrder
    currency?: SortOrder
    connectedAt?: SortOrder
    active?: SortOrder
    lastSync?: SortOrder
    metadata?: SortOrder
  }

  export type ExternalEarningsSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    platform?: SortOrder
    externalHandle?: SortOrder
    currency?: SortOrder
    connectedAt?: SortOrder
    active?: SortOrder
    lastSync?: SortOrder
  }

  export type ExternalEarningsSourceMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    platform?: SortOrder
    externalHandle?: SortOrder
    currency?: SortOrder
    connectedAt?: SortOrder
    active?: SortOrder
    lastSync?: SortOrder
  }

  export type EnumExternalPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalPlatform | EnumExternalPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalPlatform[] | ListEnumExternalPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalPlatform[] | ListEnumExternalPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalPlatformWithAggregatesFilter<$PrismaModel> | $Enums.ExternalPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExternalPlatformFilter<$PrismaModel>
    _max?: NestedEnumExternalPlatformFilter<$PrismaModel>
  }

  export type ExternalEarningsSourceRelationFilter = {
    is?: ExternalEarningsSourceWhereInput
    isNot?: ExternalEarningsSourceWhereInput
  }

  export type ExternalEarningsImportSourceIdPeriodStartPeriodEndRawHashCompoundUniqueInput = {
    sourceId: string
    periodStart: Date | string
    periodEnd: Date | string
    rawHash: string
  }

  export type ExternalEarningsImportCountOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    rawHash?: SortOrder
    rawJson?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type ExternalEarningsImportMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    rawHash?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type ExternalEarningsImportMinOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    rawHash?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type NormalizedEarningCountOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    occurredAt?: SortOrder
    currency?: SortOrder
    grossCents?: SortOrder
    feesCents?: SortOrder
    netCents?: SortOrder
    payoutId?: SortOrder
    extRef?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NormalizedEarningAvgOrderByAggregateInput = {
    grossCents?: SortOrder
    feesCents?: SortOrder
    netCents?: SortOrder
  }

  export type NormalizedEarningMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    occurredAt?: SortOrder
    currency?: SortOrder
    grossCents?: SortOrder
    feesCents?: SortOrder
    netCents?: SortOrder
    payoutId?: SortOrder
    extRef?: SortOrder
    createdAt?: SortOrder
  }

  export type NormalizedEarningMinOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    occurredAt?: SortOrder
    currency?: SortOrder
    grossCents?: SortOrder
    feesCents?: SortOrder
    netCents?: SortOrder
    payoutId?: SortOrder
    extRef?: SortOrder
    createdAt?: SortOrder
  }

  export type NormalizedEarningSumOrderByAggregateInput = {
    grossCents?: SortOrder
    feesCents?: SortOrder
    netCents?: SortOrder
  }

  export type CommissionStatementCreatorIdPlatformYearMonthCurrencyCompoundUniqueInput = {
    creatorId: string
    platform: $Enums.ExternalPlatform
    yearMonth: string
    currency: string
  }

  export type CommissionStatementCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    platform?: SortOrder
    yearMonth?: SortOrder
    currency?: SortOrder
    baseNetCents?: SortOrder
    rateBps?: SortOrder
    commissionCents?: SortOrder
    capAppliedCents?: SortOrder
    finalCents?: SortOrder
    closedAt?: SortOrder
    invoicedAt?: SortOrder
    stripeInvoiceId?: SortOrder
    paidAt?: SortOrder
    writeOffAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionStatementAvgOrderByAggregateInput = {
    baseNetCents?: SortOrder
    rateBps?: SortOrder
    commissionCents?: SortOrder
    capAppliedCents?: SortOrder
    finalCents?: SortOrder
  }

  export type CommissionStatementMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    platform?: SortOrder
    yearMonth?: SortOrder
    currency?: SortOrder
    baseNetCents?: SortOrder
    rateBps?: SortOrder
    commissionCents?: SortOrder
    capAppliedCents?: SortOrder
    finalCents?: SortOrder
    closedAt?: SortOrder
    invoicedAt?: SortOrder
    stripeInvoiceId?: SortOrder
    paidAt?: SortOrder
    writeOffAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionStatementMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    platform?: SortOrder
    yearMonth?: SortOrder
    currency?: SortOrder
    baseNetCents?: SortOrder
    rateBps?: SortOrder
    commissionCents?: SortOrder
    capAppliedCents?: SortOrder
    finalCents?: SortOrder
    closedAt?: SortOrder
    invoicedAt?: SortOrder
    stripeInvoiceId?: SortOrder
    paidAt?: SortOrder
    writeOffAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionStatementSumOrderByAggregateInput = {
    baseNetCents?: SortOrder
    rateBps?: SortOrder
    commissionCents?: SortOrder
    capAppliedCents?: SortOrder
    finalCents?: SortOrder
  }

  export type EnumDunningStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DunningStatus | EnumDunningStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DunningStatus[] | ListEnumDunningStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DunningStatus[] | ListEnumDunningStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDunningStatusFilter<$PrismaModel> | $Enums.DunningStatus
  }

  export type DunningStateCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    creatorId?: SortOrder
    attemptCount?: SortOrder
    status?: SortOrder
    lastAttempt?: SortOrder
    nextAttempt?: SortOrder
    recoveredAt?: SortOrder
    writeOffAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DunningStateAvgOrderByAggregateInput = {
    attemptCount?: SortOrder
  }

  export type DunningStateMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    creatorId?: SortOrder
    attemptCount?: SortOrder
    status?: SortOrder
    lastAttempt?: SortOrder
    nextAttempt?: SortOrder
    recoveredAt?: SortOrder
    writeOffAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DunningStateMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    creatorId?: SortOrder
    attemptCount?: SortOrder
    status?: SortOrder
    lastAttempt?: SortOrder
    nextAttempt?: SortOrder
    recoveredAt?: SortOrder
    writeOffAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DunningStateSumOrderByAggregateInput = {
    attemptCount?: SortOrder
  }

  export type EnumDunningStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DunningStatus | EnumDunningStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DunningStatus[] | ListEnumDunningStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DunningStatus[] | ListEnumDunningStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDunningStatusWithAggregatesFilter<$PrismaModel> | $Enums.DunningStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDunningStatusFilter<$PrismaModel>
    _max?: NestedEnumDunningStatusFilter<$PrismaModel>
  }

  export type PaymentAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    attemptNumber?: SortOrder
    status?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAttemptAvgOrderByAggregateInput = {
    attemptNumber?: SortOrder
    amount?: SortOrder
  }

  export type PaymentAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    attemptNumber?: SortOrder
    status?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    attemptNumber?: SortOrder
    status?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAttemptSumOrderByAggregateInput = {
    attemptNumber?: SortOrder
    amount?: SortOrder
  }

  export type EnumAutomationTriggerFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTrigger | EnumAutomationTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTrigger[] | ListEnumAutomationTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTrigger[] | ListEnumAutomationTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerFilter<$PrismaModel> | $Enums.AutomationTrigger
  }

  export type EnumAutomationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusFilter<$PrismaModel> | $Enums.AutomationStatus
  }

  export type AutomationCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    status?: SortOrder
    lastRun?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationAvgOrderByAggregateInput = {
    runCount?: SortOrder
  }

  export type AutomationMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    status?: SortOrder
    lastRun?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    status?: SortOrder
    lastRun?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationSumOrderByAggregateInput = {
    runCount?: SortOrder
  }

  export type EnumAutomationTriggerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTrigger | EnumAutomationTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTrigger[] | ListEnumAutomationTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTrigger[] | ListEnumAutomationTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerWithAggregatesFilter<$PrismaModel> | $Enums.AutomationTrigger
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationTriggerFilter<$PrismaModel>
    _max?: NestedEnumAutomationTriggerFilter<$PrismaModel>
  }

  export type EnumAutomationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationStatusFilter<$PrismaModel>
  }

  export type BackupLogCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupLogAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type BackupLogMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupLogMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupLogSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type BackupValidationCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    results?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupValidationMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupValidationMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupIndexCountOrderByAggregateInput = {
    id?: SortOrder
    backupId?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    tables?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupIndexMaxOrderByAggregateInput = {
    id?: SortOrder
    backupId?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupIndexMinOrderByAggregateInput = {
    id?: SortOrder
    backupId?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AIUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    purpose?: SortOrder
    userId?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    cost?: SortOrder
    cached?: SortOrder
    timestamp?: SortOrder
  }

  export type AIUsageLogAvgOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    cost?: SortOrder
  }

  export type AIUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    purpose?: SortOrder
    userId?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    cost?: SortOrder
    cached?: SortOrder
    timestamp?: SortOrder
  }

  export type AIUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    purpose?: SortOrder
    userId?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    cost?: SortOrder
    cached?: SortOrder
    timestamp?: SortOrder
  }

  export type AIUsageLogSumOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    cost?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CostReservationCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    service?: SortOrder
    commitment?: SortOrder
    units?: SortOrder
    unitPrice?: SortOrder
    savings?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostReservationAvgOrderByAggregateInput = {
    units?: SortOrder
    unitPrice?: SortOrder
    savings?: SortOrder
  }

  export type CostReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    service?: SortOrder
    commitment?: SortOrder
    units?: SortOrder
    unitPrice?: SortOrder
    savings?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostReservationMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    service?: SortOrder
    commitment?: SortOrder
    units?: SortOrder
    unitPrice?: SortOrder
    savings?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostReservationSumOrderByAggregateInput = {
    units?: SortOrder
    unitPrice?: SortOrder
    savings?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PromptOptimizationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    originalPrompt?: SortOrder
    optimizedPrompt?: SortOrder
    originalTokens?: SortOrder
    optimizedTokens?: SortOrder
    tokenReduction?: SortOrder
    qualityScore?: SortOrder
    abTestResults?: SortOrder
    timestamp?: SortOrder
  }

  export type PromptOptimizationAvgOrderByAggregateInput = {
    originalTokens?: SortOrder
    optimizedTokens?: SortOrder
    tokenReduction?: SortOrder
    qualityScore?: SortOrder
  }

  export type PromptOptimizationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    originalPrompt?: SortOrder
    optimizedPrompt?: SortOrder
    originalTokens?: SortOrder
    optimizedTokens?: SortOrder
    tokenReduction?: SortOrder
    qualityScore?: SortOrder
    timestamp?: SortOrder
  }

  export type PromptOptimizationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    originalPrompt?: SortOrder
    optimizedPrompt?: SortOrder
    originalTokens?: SortOrder
    optimizedTokens?: SortOrder
    tokenReduction?: SortOrder
    qualityScore?: SortOrder
    timestamp?: SortOrder
  }

  export type PromptOptimizationSumOrderByAggregateInput = {
    originalTokens?: SortOrder
    optimizedTokens?: SortOrder
    tokenReduction?: SortOrder
    qualityScore?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CostAlertCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    service?: SortOrder
    threshold?: SortOrder
    current?: SortOrder
    message?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CostAlertAvgOrderByAggregateInput = {
    threshold?: SortOrder
    current?: SortOrder
  }

  export type CostAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    service?: SortOrder
    threshold?: SortOrder
    current?: SortOrder
    message?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CostAlertMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    service?: SortOrder
    threshold?: SortOrder
    current?: SortOrder
    message?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CostAlertSumOrderByAggregateInput = {
    threshold?: SortOrder
    current?: SortOrder
  }

  export type SubscriptionPlanCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SubscriptionPlanCreateWithoutCreatorInput, SubscriptionPlanUncheckedCreateWithoutCreatorInput> | SubscriptionPlanCreateWithoutCreatorInput[] | SubscriptionPlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutCreatorInput | SubscriptionPlanCreateOrConnectWithoutCreatorInput[]
    createMany?: SubscriptionPlanCreateManyCreatorInputEnvelope
    connect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProductCreateWithoutCreatorInput, ProductUncheckedCreateWithoutCreatorInput> | ProductCreateWithoutCreatorInput[] | ProductUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCreatorInput | ProductCreateOrConnectWithoutCreatorInput[]
    createMany?: ProductCreateManyCreatorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SubscriptionCreateWithoutCreatorInput, SubscriptionUncheckedCreateWithoutCreatorInput> | SubscriptionCreateWithoutCreatorInput[] | SubscriptionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreatorInput | SubscriptionCreateOrConnectWithoutCreatorInput[]
    createMany?: SubscriptionCreateManyCreatorInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PayoutCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PayoutCreateWithoutCreatorInput, PayoutUncheckedCreateWithoutCreatorInput> | PayoutCreateWithoutCreatorInput[] | PayoutUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutCreatorInput | PayoutCreateOrConnectWithoutCreatorInput[]
    createMany?: PayoutCreateManyCreatorInputEnvelope
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
  }

  export type AnalyticsCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AnalyticsCreateWithoutCreatorInput, AnalyticsUncheckedCreateWithoutCreatorInput> | AnalyticsCreateWithoutCreatorInput[] | AnalyticsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutCreatorInput | AnalyticsCreateOrConnectWithoutCreatorInput[]
    createMany?: AnalyticsCreateManyCreatorInputEnvelope
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
  }

  export type InstalledAppCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InstalledAppCreateWithoutCreatorInput, InstalledAppUncheckedCreateWithoutCreatorInput> | InstalledAppCreateWithoutCreatorInput[] | InstalledAppUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InstalledAppCreateOrConnectWithoutCreatorInput | InstalledAppCreateOrConnectWithoutCreatorInput[]
    createMany?: InstalledAppCreateManyCreatorInputEnvelope
    connect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AuditLogCreateWithoutCreatorInput, AuditLogUncheckedCreateWithoutCreatorInput> | AuditLogCreateWithoutCreatorInput[] | AuditLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCreatorInput | AuditLogCreateOrConnectWithoutCreatorInput[]
    createMany?: AuditLogCreateManyCreatorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CreatorSettingsCreateNestedOneWithoutCreatorInput = {
    create?: XOR<CreatorSettingsCreateWithoutCreatorInput, CreatorSettingsUncheckedCreateWithoutCreatorInput>
    connectOrCreate?: CreatorSettingsCreateOrConnectWithoutCreatorInput
    connect?: CreatorSettingsWhereUniqueInput
  }

  export type FanRelationCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FanRelationCreateWithoutCreatorInput, FanRelationUncheckedCreateWithoutCreatorInput> | FanRelationCreateWithoutCreatorInput[] | FanRelationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FanRelationCreateOrConnectWithoutCreatorInput | FanRelationCreateOrConnectWithoutCreatorInput[]
    createMany?: FanRelationCreateManyCreatorInputEnvelope
    connect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SubscriptionPlanCreateWithoutCreatorInput, SubscriptionPlanUncheckedCreateWithoutCreatorInput> | SubscriptionPlanCreateWithoutCreatorInput[] | SubscriptionPlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutCreatorInput | SubscriptionPlanCreateOrConnectWithoutCreatorInput[]
    createMany?: SubscriptionPlanCreateManyCreatorInputEnvelope
    connect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProductCreateWithoutCreatorInput, ProductUncheckedCreateWithoutCreatorInput> | ProductCreateWithoutCreatorInput[] | ProductUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCreatorInput | ProductCreateOrConnectWithoutCreatorInput[]
    createMany?: ProductCreateManyCreatorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SubscriptionCreateWithoutCreatorInput, SubscriptionUncheckedCreateWithoutCreatorInput> | SubscriptionCreateWithoutCreatorInput[] | SubscriptionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreatorInput | SubscriptionCreateOrConnectWithoutCreatorInput[]
    createMany?: SubscriptionCreateManyCreatorInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PayoutUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PayoutCreateWithoutCreatorInput, PayoutUncheckedCreateWithoutCreatorInput> | PayoutCreateWithoutCreatorInput[] | PayoutUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutCreatorInput | PayoutCreateOrConnectWithoutCreatorInput[]
    createMany?: PayoutCreateManyCreatorInputEnvelope
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
  }

  export type AnalyticsUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AnalyticsCreateWithoutCreatorInput, AnalyticsUncheckedCreateWithoutCreatorInput> | AnalyticsCreateWithoutCreatorInput[] | AnalyticsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutCreatorInput | AnalyticsCreateOrConnectWithoutCreatorInput[]
    createMany?: AnalyticsCreateManyCreatorInputEnvelope
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
  }

  export type InstalledAppUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InstalledAppCreateWithoutCreatorInput, InstalledAppUncheckedCreateWithoutCreatorInput> | InstalledAppCreateWithoutCreatorInput[] | InstalledAppUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InstalledAppCreateOrConnectWithoutCreatorInput | InstalledAppCreateOrConnectWithoutCreatorInput[]
    createMany?: InstalledAppCreateManyCreatorInputEnvelope
    connect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AuditLogCreateWithoutCreatorInput, AuditLogUncheckedCreateWithoutCreatorInput> | AuditLogCreateWithoutCreatorInput[] | AuditLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCreatorInput | AuditLogCreateOrConnectWithoutCreatorInput[]
    createMany?: AuditLogCreateManyCreatorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput = {
    create?: XOR<CreatorSettingsCreateWithoutCreatorInput, CreatorSettingsUncheckedCreateWithoutCreatorInput>
    connectOrCreate?: CreatorSettingsCreateOrConnectWithoutCreatorInput
    connect?: CreatorSettingsWhereUniqueInput
  }

  export type FanRelationUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FanRelationCreateWithoutCreatorInput, FanRelationUncheckedCreateWithoutCreatorInput> | FanRelationCreateWithoutCreatorInput[] | FanRelationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FanRelationCreateOrConnectWithoutCreatorInput | FanRelationCreateOrConnectWithoutCreatorInput[]
    createMany?: FanRelationCreateManyCreatorInputEnvelope
    connect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumKycStatusFieldUpdateOperationsInput = {
    set?: $Enums.KycStatus
  }

  export type EnumCommissionTierFieldUpdateOperationsInput = {
    set?: $Enums.CommissionTier
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SubscriptionPlanUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutCreatorInput, SubscriptionPlanUncheckedCreateWithoutCreatorInput> | SubscriptionPlanCreateWithoutCreatorInput[] | SubscriptionPlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutCreatorInput | SubscriptionPlanCreateOrConnectWithoutCreatorInput[]
    upsert?: SubscriptionPlanUpsertWithWhereUniqueWithoutCreatorInput | SubscriptionPlanUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SubscriptionPlanCreateManyCreatorInputEnvelope
    set?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    disconnect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    delete?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    connect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    update?: SubscriptionPlanUpdateWithWhereUniqueWithoutCreatorInput | SubscriptionPlanUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SubscriptionPlanUpdateManyWithWhereWithoutCreatorInput | SubscriptionPlanUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SubscriptionPlanScalarWhereInput | SubscriptionPlanScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProductCreateWithoutCreatorInput, ProductUncheckedCreateWithoutCreatorInput> | ProductCreateWithoutCreatorInput[] | ProductUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCreatorInput | ProductCreateOrConnectWithoutCreatorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCreatorInput | ProductUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProductCreateManyCreatorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCreatorInput | ProductUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCreatorInput | ProductUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCreatorInput, SubscriptionUncheckedCreateWithoutCreatorInput> | SubscriptionCreateWithoutCreatorInput[] | SubscriptionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreatorInput | SubscriptionCreateOrConnectWithoutCreatorInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCreatorInput | SubscriptionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SubscriptionCreateManyCreatorInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCreatorInput | SubscriptionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCreatorInput | SubscriptionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreatorInput | TransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreatorInput | TransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreatorInput | TransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PayoutUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PayoutCreateWithoutCreatorInput, PayoutUncheckedCreateWithoutCreatorInput> | PayoutCreateWithoutCreatorInput[] | PayoutUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutCreatorInput | PayoutCreateOrConnectWithoutCreatorInput[]
    upsert?: PayoutUpsertWithWhereUniqueWithoutCreatorInput | PayoutUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PayoutCreateManyCreatorInputEnvelope
    set?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    disconnect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    delete?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    update?: PayoutUpdateWithWhereUniqueWithoutCreatorInput | PayoutUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PayoutUpdateManyWithWhereWithoutCreatorInput | PayoutUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
  }

  export type AnalyticsUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AnalyticsCreateWithoutCreatorInput, AnalyticsUncheckedCreateWithoutCreatorInput> | AnalyticsCreateWithoutCreatorInput[] | AnalyticsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutCreatorInput | AnalyticsCreateOrConnectWithoutCreatorInput[]
    upsert?: AnalyticsUpsertWithWhereUniqueWithoutCreatorInput | AnalyticsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AnalyticsCreateManyCreatorInputEnvelope
    set?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    disconnect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    delete?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    update?: AnalyticsUpdateWithWhereUniqueWithoutCreatorInput | AnalyticsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AnalyticsUpdateManyWithWhereWithoutCreatorInput | AnalyticsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
  }

  export type InstalledAppUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InstalledAppCreateWithoutCreatorInput, InstalledAppUncheckedCreateWithoutCreatorInput> | InstalledAppCreateWithoutCreatorInput[] | InstalledAppUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InstalledAppCreateOrConnectWithoutCreatorInput | InstalledAppCreateOrConnectWithoutCreatorInput[]
    upsert?: InstalledAppUpsertWithWhereUniqueWithoutCreatorInput | InstalledAppUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InstalledAppCreateManyCreatorInputEnvelope
    set?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    disconnect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    delete?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    connect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    update?: InstalledAppUpdateWithWhereUniqueWithoutCreatorInput | InstalledAppUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InstalledAppUpdateManyWithWhereWithoutCreatorInput | InstalledAppUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InstalledAppScalarWhereInput | InstalledAppScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AuditLogCreateWithoutCreatorInput, AuditLogUncheckedCreateWithoutCreatorInput> | AuditLogCreateWithoutCreatorInput[] | AuditLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCreatorInput | AuditLogCreateOrConnectWithoutCreatorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCreatorInput | AuditLogUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AuditLogCreateManyCreatorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCreatorInput | AuditLogUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCreatorInput | AuditLogUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CreatorSettingsUpdateOneWithoutCreatorNestedInput = {
    create?: XOR<CreatorSettingsCreateWithoutCreatorInput, CreatorSettingsUncheckedCreateWithoutCreatorInput>
    connectOrCreate?: CreatorSettingsCreateOrConnectWithoutCreatorInput
    upsert?: CreatorSettingsUpsertWithoutCreatorInput
    disconnect?: CreatorSettingsWhereInput | boolean
    delete?: CreatorSettingsWhereInput | boolean
    connect?: CreatorSettingsWhereUniqueInput
    update?: XOR<XOR<CreatorSettingsUpdateToOneWithWhereWithoutCreatorInput, CreatorSettingsUpdateWithoutCreatorInput>, CreatorSettingsUncheckedUpdateWithoutCreatorInput>
  }

  export type FanRelationUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FanRelationCreateWithoutCreatorInput, FanRelationUncheckedCreateWithoutCreatorInput> | FanRelationCreateWithoutCreatorInput[] | FanRelationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FanRelationCreateOrConnectWithoutCreatorInput | FanRelationCreateOrConnectWithoutCreatorInput[]
    upsert?: FanRelationUpsertWithWhereUniqueWithoutCreatorInput | FanRelationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FanRelationCreateManyCreatorInputEnvelope
    set?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    disconnect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    delete?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    connect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    update?: FanRelationUpdateWithWhereUniqueWithoutCreatorInput | FanRelationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FanRelationUpdateManyWithWhereWithoutCreatorInput | FanRelationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FanRelationScalarWhereInput | FanRelationScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutCreatorInput | CampaignUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutCreatorInput | CampaignUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutCreatorInput | CampaignUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutCreatorInput, SubscriptionPlanUncheckedCreateWithoutCreatorInput> | SubscriptionPlanCreateWithoutCreatorInput[] | SubscriptionPlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutCreatorInput | SubscriptionPlanCreateOrConnectWithoutCreatorInput[]
    upsert?: SubscriptionPlanUpsertWithWhereUniqueWithoutCreatorInput | SubscriptionPlanUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SubscriptionPlanCreateManyCreatorInputEnvelope
    set?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    disconnect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    delete?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    connect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    update?: SubscriptionPlanUpdateWithWhereUniqueWithoutCreatorInput | SubscriptionPlanUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SubscriptionPlanUpdateManyWithWhereWithoutCreatorInput | SubscriptionPlanUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SubscriptionPlanScalarWhereInput | SubscriptionPlanScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProductCreateWithoutCreatorInput, ProductUncheckedCreateWithoutCreatorInput> | ProductCreateWithoutCreatorInput[] | ProductUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCreatorInput | ProductCreateOrConnectWithoutCreatorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCreatorInput | ProductUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProductCreateManyCreatorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCreatorInput | ProductUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCreatorInput | ProductUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCreatorInput, SubscriptionUncheckedCreateWithoutCreatorInput> | SubscriptionCreateWithoutCreatorInput[] | SubscriptionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCreatorInput | SubscriptionCreateOrConnectWithoutCreatorInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCreatorInput | SubscriptionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SubscriptionCreateManyCreatorInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCreatorInput | SubscriptionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCreatorInput | SubscriptionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreatorInput | TransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreatorInput | TransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreatorInput | TransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PayoutUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PayoutCreateWithoutCreatorInput, PayoutUncheckedCreateWithoutCreatorInput> | PayoutCreateWithoutCreatorInput[] | PayoutUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutCreatorInput | PayoutCreateOrConnectWithoutCreatorInput[]
    upsert?: PayoutUpsertWithWhereUniqueWithoutCreatorInput | PayoutUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PayoutCreateManyCreatorInputEnvelope
    set?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    disconnect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    delete?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    update?: PayoutUpdateWithWhereUniqueWithoutCreatorInput | PayoutUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PayoutUpdateManyWithWhereWithoutCreatorInput | PayoutUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
  }

  export type AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AnalyticsCreateWithoutCreatorInput, AnalyticsUncheckedCreateWithoutCreatorInput> | AnalyticsCreateWithoutCreatorInput[] | AnalyticsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutCreatorInput | AnalyticsCreateOrConnectWithoutCreatorInput[]
    upsert?: AnalyticsUpsertWithWhereUniqueWithoutCreatorInput | AnalyticsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AnalyticsCreateManyCreatorInputEnvelope
    set?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    disconnect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    delete?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    update?: AnalyticsUpdateWithWhereUniqueWithoutCreatorInput | AnalyticsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AnalyticsUpdateManyWithWhereWithoutCreatorInput | AnalyticsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
  }

  export type InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InstalledAppCreateWithoutCreatorInput, InstalledAppUncheckedCreateWithoutCreatorInput> | InstalledAppCreateWithoutCreatorInput[] | InstalledAppUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InstalledAppCreateOrConnectWithoutCreatorInput | InstalledAppCreateOrConnectWithoutCreatorInput[]
    upsert?: InstalledAppUpsertWithWhereUniqueWithoutCreatorInput | InstalledAppUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InstalledAppCreateManyCreatorInputEnvelope
    set?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    disconnect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    delete?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    connect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    update?: InstalledAppUpdateWithWhereUniqueWithoutCreatorInput | InstalledAppUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InstalledAppUpdateManyWithWhereWithoutCreatorInput | InstalledAppUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InstalledAppScalarWhereInput | InstalledAppScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AuditLogCreateWithoutCreatorInput, AuditLogUncheckedCreateWithoutCreatorInput> | AuditLogCreateWithoutCreatorInput[] | AuditLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCreatorInput | AuditLogCreateOrConnectWithoutCreatorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCreatorInput | AuditLogUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AuditLogCreateManyCreatorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCreatorInput | AuditLogUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCreatorInput | AuditLogUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput = {
    create?: XOR<CreatorSettingsCreateWithoutCreatorInput, CreatorSettingsUncheckedCreateWithoutCreatorInput>
    connectOrCreate?: CreatorSettingsCreateOrConnectWithoutCreatorInput
    upsert?: CreatorSettingsUpsertWithoutCreatorInput
    disconnect?: CreatorSettingsWhereInput | boolean
    delete?: CreatorSettingsWhereInput | boolean
    connect?: CreatorSettingsWhereUniqueInput
    update?: XOR<XOR<CreatorSettingsUpdateToOneWithWhereWithoutCreatorInput, CreatorSettingsUpdateWithoutCreatorInput>, CreatorSettingsUncheckedUpdateWithoutCreatorInput>
  }

  export type FanRelationUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FanRelationCreateWithoutCreatorInput, FanRelationUncheckedCreateWithoutCreatorInput> | FanRelationCreateWithoutCreatorInput[] | FanRelationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FanRelationCreateOrConnectWithoutCreatorInput | FanRelationCreateOrConnectWithoutCreatorInput[]
    upsert?: FanRelationUpsertWithWhereUniqueWithoutCreatorInput | FanRelationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FanRelationCreateManyCreatorInputEnvelope
    set?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    disconnect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    delete?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    connect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    update?: FanRelationUpdateWithWhereUniqueWithoutCreatorInput | FanRelationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FanRelationUpdateManyWithWhereWithoutCreatorInput | FanRelationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FanRelationScalarWhereInput | FanRelationScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutCreatorInput | CampaignUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutCreatorInput | CampaignUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutCreatorInput | CampaignUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CreatorCreateNestedOneWithoutSettingsInput = {
    create?: XOR<CreatorCreateWithoutSettingsInput, CreatorUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutSettingsInput
    connect?: CreatorWhereUniqueInput
  }

  export type EnumPayoutFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.PayoutFrequency
  }

  export type EnumContentAccessFieldUpdateOperationsInput = {
    set?: $Enums.ContentAccess
  }

  export type CreatorUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<CreatorCreateWithoutSettingsInput, CreatorUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutSettingsInput
    upsert?: CreatorUpsertWithoutSettingsInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutSettingsInput, CreatorUpdateWithoutSettingsInput>, CreatorUncheckedUpdateWithoutSettingsInput>
  }

  export type CreatorCreateNestedOneWithoutSubscriptionPlansInput = {
    create?: XOR<CreatorCreateWithoutSubscriptionPlansInput, CreatorUncheckedCreateWithoutSubscriptionPlansInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutSubscriptionPlansInput
    connect?: CreatorWhereUniqueInput
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type EnumBillingIntervalFieldUpdateOperationsInput = {
    set?: $Enums.BillingInterval
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CreatorUpdateOneRequiredWithoutSubscriptionPlansNestedInput = {
    create?: XOR<CreatorCreateWithoutSubscriptionPlansInput, CreatorUncheckedCreateWithoutSubscriptionPlansInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutSubscriptionPlansInput
    upsert?: CreatorUpsertWithoutSubscriptionPlansInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutSubscriptionPlansInput, CreatorUpdateWithoutSubscriptionPlansInput>, CreatorUncheckedUpdateWithoutSubscriptionPlansInput>
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type ProductCreatetagsInput = {
    set: string[]
  }

  export type CreatorCreateNestedOneWithoutProductsInput = {
    create?: XOR<CreatorCreateWithoutProductsInput, CreatorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutProductsInput
    connect?: CreatorWhereUniqueInput
  }

  export type PurchaseCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProductUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CreatorUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CreatorCreateWithoutProductsInput, CreatorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutProductsInput
    upsert?: CreatorUpsertWithoutProductsInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutProductsInput, CreatorUpdateWithoutProductsInput>, CreatorUncheckedUpdateWithoutProductsInput>
  }

  export type PurchaseUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutProductInput | PurchaseUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutProductInput | PurchaseUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutProductInput | PurchaseUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutProductInput | PurchaseUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutProductInput | PurchaseUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutProductInput | PurchaseUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type SubscriptionCreateNestedManyWithoutFanInput = {
    create?: XOR<SubscriptionCreateWithoutFanInput, SubscriptionUncheckedCreateWithoutFanInput> | SubscriptionCreateWithoutFanInput[] | SubscriptionUncheckedCreateWithoutFanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutFanInput | SubscriptionCreateOrConnectWithoutFanInput[]
    createMany?: SubscriptionCreateManyFanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutFanInput = {
    create?: XOR<PurchaseCreateWithoutFanInput, PurchaseUncheckedCreateWithoutFanInput> | PurchaseCreateWithoutFanInput[] | PurchaseUncheckedCreateWithoutFanInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutFanInput | PurchaseCreateOrConnectWithoutFanInput[]
    createMany?: PurchaseCreateManyFanInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutFanInput = {
    create?: XOR<TransactionCreateWithoutFanInput, TransactionUncheckedCreateWithoutFanInput> | TransactionCreateWithoutFanInput[] | TransactionUncheckedCreateWithoutFanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFanInput | TransactionCreateOrConnectWithoutFanInput[]
    createMany?: TransactionCreateManyFanInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type FanRelationCreateNestedManyWithoutFanInput = {
    create?: XOR<FanRelationCreateWithoutFanInput, FanRelationUncheckedCreateWithoutFanInput> | FanRelationCreateWithoutFanInput[] | FanRelationUncheckedCreateWithoutFanInput[]
    connectOrCreate?: FanRelationCreateOrConnectWithoutFanInput | FanRelationCreateOrConnectWithoutFanInput[]
    createMany?: FanRelationCreateManyFanInputEnvelope
    connect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
  }

  export type CampaignRecipientCreateNestedManyWithoutFanInput = {
    create?: XOR<CampaignRecipientCreateWithoutFanInput, CampaignRecipientUncheckedCreateWithoutFanInput> | CampaignRecipientCreateWithoutFanInput[] | CampaignRecipientUncheckedCreateWithoutFanInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutFanInput | CampaignRecipientCreateOrConnectWithoutFanInput[]
    createMany?: CampaignRecipientCreateManyFanInputEnvelope
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutFanInput = {
    create?: XOR<SubscriptionCreateWithoutFanInput, SubscriptionUncheckedCreateWithoutFanInput> | SubscriptionCreateWithoutFanInput[] | SubscriptionUncheckedCreateWithoutFanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutFanInput | SubscriptionCreateOrConnectWithoutFanInput[]
    createMany?: SubscriptionCreateManyFanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutFanInput = {
    create?: XOR<PurchaseCreateWithoutFanInput, PurchaseUncheckedCreateWithoutFanInput> | PurchaseCreateWithoutFanInput[] | PurchaseUncheckedCreateWithoutFanInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutFanInput | PurchaseCreateOrConnectWithoutFanInput[]
    createMany?: PurchaseCreateManyFanInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutFanInput = {
    create?: XOR<TransactionCreateWithoutFanInput, TransactionUncheckedCreateWithoutFanInput> | TransactionCreateWithoutFanInput[] | TransactionUncheckedCreateWithoutFanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFanInput | TransactionCreateOrConnectWithoutFanInput[]
    createMany?: TransactionCreateManyFanInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type FanRelationUncheckedCreateNestedManyWithoutFanInput = {
    create?: XOR<FanRelationCreateWithoutFanInput, FanRelationUncheckedCreateWithoutFanInput> | FanRelationCreateWithoutFanInput[] | FanRelationUncheckedCreateWithoutFanInput[]
    connectOrCreate?: FanRelationCreateOrConnectWithoutFanInput | FanRelationCreateOrConnectWithoutFanInput[]
    createMany?: FanRelationCreateManyFanInputEnvelope
    connect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
  }

  export type CampaignRecipientUncheckedCreateNestedManyWithoutFanInput = {
    create?: XOR<CampaignRecipientCreateWithoutFanInput, CampaignRecipientUncheckedCreateWithoutFanInput> | CampaignRecipientCreateWithoutFanInput[] | CampaignRecipientUncheckedCreateWithoutFanInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutFanInput | CampaignRecipientCreateOrConnectWithoutFanInput[]
    createMany?: CampaignRecipientCreateManyFanInputEnvelope
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
  }

  export type SubscriptionUpdateManyWithoutFanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutFanInput, SubscriptionUncheckedCreateWithoutFanInput> | SubscriptionCreateWithoutFanInput[] | SubscriptionUncheckedCreateWithoutFanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutFanInput | SubscriptionCreateOrConnectWithoutFanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutFanInput | SubscriptionUpsertWithWhereUniqueWithoutFanInput[]
    createMany?: SubscriptionCreateManyFanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutFanInput | SubscriptionUpdateWithWhereUniqueWithoutFanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutFanInput | SubscriptionUpdateManyWithWhereWithoutFanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutFanNestedInput = {
    create?: XOR<PurchaseCreateWithoutFanInput, PurchaseUncheckedCreateWithoutFanInput> | PurchaseCreateWithoutFanInput[] | PurchaseUncheckedCreateWithoutFanInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutFanInput | PurchaseCreateOrConnectWithoutFanInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutFanInput | PurchaseUpsertWithWhereUniqueWithoutFanInput[]
    createMany?: PurchaseCreateManyFanInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutFanInput | PurchaseUpdateWithWhereUniqueWithoutFanInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutFanInput | PurchaseUpdateManyWithWhereWithoutFanInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutFanNestedInput = {
    create?: XOR<TransactionCreateWithoutFanInput, TransactionUncheckedCreateWithoutFanInput> | TransactionCreateWithoutFanInput[] | TransactionUncheckedCreateWithoutFanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFanInput | TransactionCreateOrConnectWithoutFanInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFanInput | TransactionUpsertWithWhereUniqueWithoutFanInput[]
    createMany?: TransactionCreateManyFanInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFanInput | TransactionUpdateWithWhereUniqueWithoutFanInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFanInput | TransactionUpdateManyWithWhereWithoutFanInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type FanRelationUpdateManyWithoutFanNestedInput = {
    create?: XOR<FanRelationCreateWithoutFanInput, FanRelationUncheckedCreateWithoutFanInput> | FanRelationCreateWithoutFanInput[] | FanRelationUncheckedCreateWithoutFanInput[]
    connectOrCreate?: FanRelationCreateOrConnectWithoutFanInput | FanRelationCreateOrConnectWithoutFanInput[]
    upsert?: FanRelationUpsertWithWhereUniqueWithoutFanInput | FanRelationUpsertWithWhereUniqueWithoutFanInput[]
    createMany?: FanRelationCreateManyFanInputEnvelope
    set?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    disconnect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    delete?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    connect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    update?: FanRelationUpdateWithWhereUniqueWithoutFanInput | FanRelationUpdateWithWhereUniqueWithoutFanInput[]
    updateMany?: FanRelationUpdateManyWithWhereWithoutFanInput | FanRelationUpdateManyWithWhereWithoutFanInput[]
    deleteMany?: FanRelationScalarWhereInput | FanRelationScalarWhereInput[]
  }

  export type CampaignRecipientUpdateManyWithoutFanNestedInput = {
    create?: XOR<CampaignRecipientCreateWithoutFanInput, CampaignRecipientUncheckedCreateWithoutFanInput> | CampaignRecipientCreateWithoutFanInput[] | CampaignRecipientUncheckedCreateWithoutFanInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutFanInput | CampaignRecipientCreateOrConnectWithoutFanInput[]
    upsert?: CampaignRecipientUpsertWithWhereUniqueWithoutFanInput | CampaignRecipientUpsertWithWhereUniqueWithoutFanInput[]
    createMany?: CampaignRecipientCreateManyFanInputEnvelope
    set?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    disconnect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    delete?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    update?: CampaignRecipientUpdateWithWhereUniqueWithoutFanInput | CampaignRecipientUpdateWithWhereUniqueWithoutFanInput[]
    updateMany?: CampaignRecipientUpdateManyWithWhereWithoutFanInput | CampaignRecipientUpdateManyWithWhereWithoutFanInput[]
    deleteMany?: CampaignRecipientScalarWhereInput | CampaignRecipientScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutFanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutFanInput, SubscriptionUncheckedCreateWithoutFanInput> | SubscriptionCreateWithoutFanInput[] | SubscriptionUncheckedCreateWithoutFanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutFanInput | SubscriptionCreateOrConnectWithoutFanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutFanInput | SubscriptionUpsertWithWhereUniqueWithoutFanInput[]
    createMany?: SubscriptionCreateManyFanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutFanInput | SubscriptionUpdateWithWhereUniqueWithoutFanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutFanInput | SubscriptionUpdateManyWithWhereWithoutFanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutFanNestedInput = {
    create?: XOR<PurchaseCreateWithoutFanInput, PurchaseUncheckedCreateWithoutFanInput> | PurchaseCreateWithoutFanInput[] | PurchaseUncheckedCreateWithoutFanInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutFanInput | PurchaseCreateOrConnectWithoutFanInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutFanInput | PurchaseUpsertWithWhereUniqueWithoutFanInput[]
    createMany?: PurchaseCreateManyFanInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutFanInput | PurchaseUpdateWithWhereUniqueWithoutFanInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutFanInput | PurchaseUpdateManyWithWhereWithoutFanInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutFanNestedInput = {
    create?: XOR<TransactionCreateWithoutFanInput, TransactionUncheckedCreateWithoutFanInput> | TransactionCreateWithoutFanInput[] | TransactionUncheckedCreateWithoutFanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFanInput | TransactionCreateOrConnectWithoutFanInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFanInput | TransactionUpsertWithWhereUniqueWithoutFanInput[]
    createMany?: TransactionCreateManyFanInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFanInput | TransactionUpdateWithWhereUniqueWithoutFanInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFanInput | TransactionUpdateManyWithWhereWithoutFanInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type FanRelationUncheckedUpdateManyWithoutFanNestedInput = {
    create?: XOR<FanRelationCreateWithoutFanInput, FanRelationUncheckedCreateWithoutFanInput> | FanRelationCreateWithoutFanInput[] | FanRelationUncheckedCreateWithoutFanInput[]
    connectOrCreate?: FanRelationCreateOrConnectWithoutFanInput | FanRelationCreateOrConnectWithoutFanInput[]
    upsert?: FanRelationUpsertWithWhereUniqueWithoutFanInput | FanRelationUpsertWithWhereUniqueWithoutFanInput[]
    createMany?: FanRelationCreateManyFanInputEnvelope
    set?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    disconnect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    delete?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    connect?: FanRelationWhereUniqueInput | FanRelationWhereUniqueInput[]
    update?: FanRelationUpdateWithWhereUniqueWithoutFanInput | FanRelationUpdateWithWhereUniqueWithoutFanInput[]
    updateMany?: FanRelationUpdateManyWithWhereWithoutFanInput | FanRelationUpdateManyWithWhereWithoutFanInput[]
    deleteMany?: FanRelationScalarWhereInput | FanRelationScalarWhereInput[]
  }

  export type CampaignRecipientUncheckedUpdateManyWithoutFanNestedInput = {
    create?: XOR<CampaignRecipientCreateWithoutFanInput, CampaignRecipientUncheckedCreateWithoutFanInput> | CampaignRecipientCreateWithoutFanInput[] | CampaignRecipientUncheckedCreateWithoutFanInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutFanInput | CampaignRecipientCreateOrConnectWithoutFanInput[]
    upsert?: CampaignRecipientUpsertWithWhereUniqueWithoutFanInput | CampaignRecipientUpsertWithWhereUniqueWithoutFanInput[]
    createMany?: CampaignRecipientCreateManyFanInputEnvelope
    set?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    disconnect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    delete?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    update?: CampaignRecipientUpdateWithWhereUniqueWithoutFanInput | CampaignRecipientUpdateWithWhereUniqueWithoutFanInput[]
    updateMany?: CampaignRecipientUpdateManyWithWhereWithoutFanInput | CampaignRecipientUpdateManyWithWhereWithoutFanInput[]
    deleteMany?: CampaignRecipientScalarWhereInput | CampaignRecipientScalarWhereInput[]
  }

  export type FanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<FanCreateWithoutSubscriptionsInput, FanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: FanCreateOrConnectWithoutSubscriptionsInput
    connect?: FanWhereUniqueInput
  }

  export type CreatorCreateNestedOneWithoutSubscribersInput = {
    create?: XOR<CreatorCreateWithoutSubscribersInput, CreatorUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutSubscribersInput
    connect?: CreatorWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type FanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<FanCreateWithoutSubscriptionsInput, FanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: FanCreateOrConnectWithoutSubscriptionsInput
    upsert?: FanUpsertWithoutSubscriptionsInput
    connect?: FanWhereUniqueInput
    update?: XOR<XOR<FanUpdateToOneWithWhereWithoutSubscriptionsInput, FanUpdateWithoutSubscriptionsInput>, FanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CreatorUpdateOneRequiredWithoutSubscribersNestedInput = {
    create?: XOR<CreatorCreateWithoutSubscribersInput, CreatorUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutSubscribersInput
    upsert?: CreatorUpsertWithoutSubscribersInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutSubscribersInput, CreatorUpdateWithoutSubscribersInput>, CreatorUncheckedUpdateWithoutSubscribersInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlanUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlanUpdateWithoutSubscriptionsInput>, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type FanCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<FanCreateWithoutPurchasesInput, FanUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: FanCreateOrConnectWithoutPurchasesInput
    connect?: FanWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchasesInput
    connect?: ProductWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<TransactionCreateWithoutPurchaseInput, TransactionUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPurchaseInput
    connect?: TransactionWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<TransactionCreateWithoutPurchaseInput, TransactionUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPurchaseInput
    connect?: TransactionWhereUniqueInput
  }

  export type EnumPurchaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseStatus
  }

  export type FanUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<FanCreateWithoutPurchasesInput, FanUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: FanCreateOrConnectWithoutPurchasesInput
    upsert?: FanUpsertWithoutPurchasesInput
    connect?: FanWhereUniqueInput
    update?: XOR<XOR<FanUpdateToOneWithWhereWithoutPurchasesInput, FanUpdateWithoutPurchasesInput>, FanUncheckedUpdateWithoutPurchasesInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchasesInput
    upsert?: ProductUpsertWithoutPurchasesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchasesInput, ProductUpdateWithoutPurchasesInput>, ProductUncheckedUpdateWithoutPurchasesInput>
  }

  export type TransactionUpdateOneWithoutPurchaseNestedInput = {
    create?: XOR<TransactionCreateWithoutPurchaseInput, TransactionUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPurchaseInput
    upsert?: TransactionUpsertWithoutPurchaseInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutPurchaseInput, TransactionUpdateWithoutPurchaseInput>, TransactionUncheckedUpdateWithoutPurchaseInput>
  }

  export type TransactionUncheckedUpdateOneWithoutPurchaseNestedInput = {
    create?: XOR<TransactionCreateWithoutPurchaseInput, TransactionUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPurchaseInput
    upsert?: TransactionUpsertWithoutPurchaseInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutPurchaseInput, TransactionUpdateWithoutPurchaseInput>, TransactionUncheckedUpdateWithoutPurchaseInput>
  }

  export type CreatorCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CreatorCreateWithoutTransactionsInput, CreatorUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutTransactionsInput
    connect?: CreatorWhereUniqueInput
  }

  export type FanCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<FanCreateWithoutTransactionsInput, FanUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: FanCreateOrConnectWithoutTransactionsInput
    connect?: FanWhereUniqueInput
  }

  export type PurchaseCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PurchaseCreateWithoutTransactionInput, PurchaseUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutTransactionInput
    connect?: PurchaseWhereUniqueInput
  }

  export type PayoutCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<PayoutCreateWithoutTransactionsInput, PayoutUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PayoutCreateOrConnectWithoutTransactionsInput
    connect?: PayoutWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type CreatorUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CreatorCreateWithoutTransactionsInput, CreatorUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutTransactionsInput
    upsert?: CreatorUpsertWithoutTransactionsInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutTransactionsInput, CreatorUpdateWithoutTransactionsInput>, CreatorUncheckedUpdateWithoutTransactionsInput>
  }

  export type FanUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<FanCreateWithoutTransactionsInput, FanUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: FanCreateOrConnectWithoutTransactionsInput
    upsert?: FanUpsertWithoutTransactionsInput
    disconnect?: FanWhereInput | boolean
    delete?: FanWhereInput | boolean
    connect?: FanWhereUniqueInput
    update?: XOR<XOR<FanUpdateToOneWithWhereWithoutTransactionsInput, FanUpdateWithoutTransactionsInput>, FanUncheckedUpdateWithoutTransactionsInput>
  }

  export type PurchaseUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<PurchaseCreateWithoutTransactionInput, PurchaseUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutTransactionInput
    upsert?: PurchaseUpsertWithoutTransactionInput
    disconnect?: PurchaseWhereInput | boolean
    delete?: PurchaseWhereInput | boolean
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutTransactionInput, PurchaseUpdateWithoutTransactionInput>, PurchaseUncheckedUpdateWithoutTransactionInput>
  }

  export type PayoutUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<PayoutCreateWithoutTransactionsInput, PayoutUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PayoutCreateOrConnectWithoutTransactionsInput
    upsert?: PayoutUpsertWithoutTransactionsInput
    disconnect?: PayoutWhereInput | boolean
    delete?: PayoutWhereInput | boolean
    connect?: PayoutWhereUniqueInput
    update?: XOR<XOR<PayoutUpdateToOneWithWhereWithoutTransactionsInput, PayoutUpdateWithoutTransactionsInput>, PayoutUncheckedUpdateWithoutTransactionsInput>
  }

  export type CreatorCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<CreatorCreateWithoutPayoutsInput, CreatorUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutPayoutsInput
    connect?: CreatorWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutPayoutInput = {
    create?: XOR<TransactionCreateWithoutPayoutInput, TransactionUncheckedCreateWithoutPayoutInput> | TransactionCreateWithoutPayoutInput[] | TransactionUncheckedCreateWithoutPayoutInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPayoutInput | TransactionCreateOrConnectWithoutPayoutInput[]
    createMany?: TransactionCreateManyPayoutInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutPayoutInput = {
    create?: XOR<TransactionCreateWithoutPayoutInput, TransactionUncheckedCreateWithoutPayoutInput> | TransactionCreateWithoutPayoutInput[] | TransactionUncheckedCreateWithoutPayoutInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPayoutInput | TransactionCreateOrConnectWithoutPayoutInput[]
    createMany?: TransactionCreateManyPayoutInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumPayoutStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayoutStatus
  }

  export type EnumPayoutMethodFieldUpdateOperationsInput = {
    set?: $Enums.PayoutMethod
  }

  export type CreatorUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<CreatorCreateWithoutPayoutsInput, CreatorUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutPayoutsInput
    upsert?: CreatorUpsertWithoutPayoutsInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutPayoutsInput, CreatorUpdateWithoutPayoutsInput>, CreatorUncheckedUpdateWithoutPayoutsInput>
  }

  export type TransactionUpdateManyWithoutPayoutNestedInput = {
    create?: XOR<TransactionCreateWithoutPayoutInput, TransactionUncheckedCreateWithoutPayoutInput> | TransactionCreateWithoutPayoutInput[] | TransactionUncheckedCreateWithoutPayoutInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPayoutInput | TransactionCreateOrConnectWithoutPayoutInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPayoutInput | TransactionUpsertWithWhereUniqueWithoutPayoutInput[]
    createMany?: TransactionCreateManyPayoutInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPayoutInput | TransactionUpdateWithWhereUniqueWithoutPayoutInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPayoutInput | TransactionUpdateManyWithWhereWithoutPayoutInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutPayoutNestedInput = {
    create?: XOR<TransactionCreateWithoutPayoutInput, TransactionUncheckedCreateWithoutPayoutInput> | TransactionCreateWithoutPayoutInput[] | TransactionUncheckedCreateWithoutPayoutInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPayoutInput | TransactionCreateOrConnectWithoutPayoutInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPayoutInput | TransactionUpsertWithWhereUniqueWithoutPayoutInput[]
    createMany?: TransactionCreateManyPayoutInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPayoutInput | TransactionUpdateWithWhereUniqueWithoutPayoutInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPayoutInput | TransactionUpdateManyWithWhereWithoutPayoutInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CreatorCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<CreatorCreateWithoutAnalyticsInput, CreatorUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutAnalyticsInput
    connect?: CreatorWhereUniqueInput
  }

  export type CreatorUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<CreatorCreateWithoutAnalyticsInput, CreatorUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutAnalyticsInput
    upsert?: CreatorUpsertWithoutAnalyticsInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutAnalyticsInput, CreatorUpdateWithoutAnalyticsInput>, CreatorUncheckedUpdateWithoutAnalyticsInput>
  }

  export type FanRelationCreatetagsInput = {
    set: string[]
  }

  export type CreatorCreateNestedOneWithoutFanRelationsInput = {
    create?: XOR<CreatorCreateWithoutFanRelationsInput, CreatorUncheckedCreateWithoutFanRelationsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutFanRelationsInput
    connect?: CreatorWhereUniqueInput
  }

  export type FanCreateNestedOneWithoutFanRelationsInput = {
    create?: XOR<FanCreateWithoutFanRelationsInput, FanUncheckedCreateWithoutFanRelationsInput>
    connectOrCreate?: FanCreateOrConnectWithoutFanRelationsInput
    connect?: FanWhereUniqueInput
  }

  export type FanRelationUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CreatorUpdateOneRequiredWithoutFanRelationsNestedInput = {
    create?: XOR<CreatorCreateWithoutFanRelationsInput, CreatorUncheckedCreateWithoutFanRelationsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutFanRelationsInput
    upsert?: CreatorUpsertWithoutFanRelationsInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutFanRelationsInput, CreatorUpdateWithoutFanRelationsInput>, CreatorUncheckedUpdateWithoutFanRelationsInput>
  }

  export type FanUpdateOneRequiredWithoutFanRelationsNestedInput = {
    create?: XOR<FanCreateWithoutFanRelationsInput, FanUncheckedCreateWithoutFanRelationsInput>
    connectOrCreate?: FanCreateOrConnectWithoutFanRelationsInput
    upsert?: FanUpsertWithoutFanRelationsInput
    connect?: FanWhereUniqueInput
    update?: XOR<XOR<FanUpdateToOneWithWhereWithoutFanRelationsInput, FanUpdateWithoutFanRelationsInput>, FanUncheckedUpdateWithoutFanRelationsInput>
  }

  export type CampaignCreatetargetTagsInput = {
    set: string[]
  }

  export type CreatorCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<CreatorCreateWithoutCampaignsInput, CreatorUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutCampaignsInput
    connect?: CreatorWhereUniqueInput
  }

  export type CampaignRecipientCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput> | CampaignRecipientCreateWithoutCampaignInput[] | CampaignRecipientUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutCampaignInput | CampaignRecipientCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignRecipientCreateManyCampaignInputEnvelope
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
  }

  export type CampaignRecipientUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput> | CampaignRecipientCreateWithoutCampaignInput[] | CampaignRecipientUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutCampaignInput | CampaignRecipientCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignRecipientCreateManyCampaignInputEnvelope
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
  }

  export type EnumCampaignTypeFieldUpdateOperationsInput = {
    set?: $Enums.CampaignType
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type CampaignUpdatetargetTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CreatorUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<CreatorCreateWithoutCampaignsInput, CreatorUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutCampaignsInput
    upsert?: CreatorUpsertWithoutCampaignsInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutCampaignsInput, CreatorUpdateWithoutCampaignsInput>, CreatorUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignRecipientUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput> | CampaignRecipientCreateWithoutCampaignInput[] | CampaignRecipientUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutCampaignInput | CampaignRecipientCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignRecipientUpsertWithWhereUniqueWithoutCampaignInput | CampaignRecipientUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignRecipientCreateManyCampaignInputEnvelope
    set?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    disconnect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    delete?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    update?: CampaignRecipientUpdateWithWhereUniqueWithoutCampaignInput | CampaignRecipientUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignRecipientUpdateManyWithWhereWithoutCampaignInput | CampaignRecipientUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignRecipientScalarWhereInput | CampaignRecipientScalarWhereInput[]
  }

  export type CampaignRecipientUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput> | CampaignRecipientCreateWithoutCampaignInput[] | CampaignRecipientUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutCampaignInput | CampaignRecipientCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignRecipientUpsertWithWhereUniqueWithoutCampaignInput | CampaignRecipientUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignRecipientCreateManyCampaignInputEnvelope
    set?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    disconnect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    delete?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    update?: CampaignRecipientUpdateWithWhereUniqueWithoutCampaignInput | CampaignRecipientUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignRecipientUpdateManyWithWhereWithoutCampaignInput | CampaignRecipientUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignRecipientScalarWhereInput | CampaignRecipientScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutRecipientsInput = {
    create?: XOR<CampaignCreateWithoutRecipientsInput, CampaignUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRecipientsInput
    connect?: CampaignWhereUniqueInput
  }

  export type FanCreateNestedOneWithoutCampaignRecipientsInput = {
    create?: XOR<FanCreateWithoutCampaignRecipientsInput, FanUncheckedCreateWithoutCampaignRecipientsInput>
    connectOrCreate?: FanCreateOrConnectWithoutCampaignRecipientsInput
    connect?: FanWhereUniqueInput
  }

  export type EnumRecipientStatusFieldUpdateOperationsInput = {
    set?: $Enums.RecipientStatus
  }

  export type CampaignUpdateOneRequiredWithoutRecipientsNestedInput = {
    create?: XOR<CampaignCreateWithoutRecipientsInput, CampaignUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRecipientsInput
    upsert?: CampaignUpsertWithoutRecipientsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutRecipientsInput, CampaignUpdateWithoutRecipientsInput>, CampaignUncheckedUpdateWithoutRecipientsInput>
  }

  export type FanUpdateOneRequiredWithoutCampaignRecipientsNestedInput = {
    create?: XOR<FanCreateWithoutCampaignRecipientsInput, FanUncheckedCreateWithoutCampaignRecipientsInput>
    connectOrCreate?: FanCreateOrConnectWithoutCampaignRecipientsInput
    upsert?: FanUpsertWithoutCampaignRecipientsInput
    connect?: FanWhereUniqueInput
    update?: XOR<XOR<FanUpdateToOneWithWhereWithoutCampaignRecipientsInput, FanUpdateWithoutCampaignRecipientsInput>, FanUncheckedUpdateWithoutCampaignRecipientsInput>
  }

  export type AppCreatescopesInput = {
    set: string[]
  }

  export type InstalledAppCreateNestedManyWithoutAppInput = {
    create?: XOR<InstalledAppCreateWithoutAppInput, InstalledAppUncheckedCreateWithoutAppInput> | InstalledAppCreateWithoutAppInput[] | InstalledAppUncheckedCreateWithoutAppInput[]
    connectOrCreate?: InstalledAppCreateOrConnectWithoutAppInput | InstalledAppCreateOrConnectWithoutAppInput[]
    createMany?: InstalledAppCreateManyAppInputEnvelope
    connect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
  }

  export type InstalledAppUncheckedCreateNestedManyWithoutAppInput = {
    create?: XOR<InstalledAppCreateWithoutAppInput, InstalledAppUncheckedCreateWithoutAppInput> | InstalledAppCreateWithoutAppInput[] | InstalledAppUncheckedCreateWithoutAppInput[]
    connectOrCreate?: InstalledAppCreateOrConnectWithoutAppInput | InstalledAppCreateOrConnectWithoutAppInput[]
    createMany?: InstalledAppCreateManyAppInputEnvelope
    connect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
  }

  export type EnumAppCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AppCategory
  }

  export type EnumAppPricingFieldUpdateOperationsInput = {
    set?: $Enums.AppPricing
  }

  export type AppUpdatescopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstalledAppUpdateManyWithoutAppNestedInput = {
    create?: XOR<InstalledAppCreateWithoutAppInput, InstalledAppUncheckedCreateWithoutAppInput> | InstalledAppCreateWithoutAppInput[] | InstalledAppUncheckedCreateWithoutAppInput[]
    connectOrCreate?: InstalledAppCreateOrConnectWithoutAppInput | InstalledAppCreateOrConnectWithoutAppInput[]
    upsert?: InstalledAppUpsertWithWhereUniqueWithoutAppInput | InstalledAppUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: InstalledAppCreateManyAppInputEnvelope
    set?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    disconnect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    delete?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    connect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    update?: InstalledAppUpdateWithWhereUniqueWithoutAppInput | InstalledAppUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: InstalledAppUpdateManyWithWhereWithoutAppInput | InstalledAppUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: InstalledAppScalarWhereInput | InstalledAppScalarWhereInput[]
  }

  export type InstalledAppUncheckedUpdateManyWithoutAppNestedInput = {
    create?: XOR<InstalledAppCreateWithoutAppInput, InstalledAppUncheckedCreateWithoutAppInput> | InstalledAppCreateWithoutAppInput[] | InstalledAppUncheckedCreateWithoutAppInput[]
    connectOrCreate?: InstalledAppCreateOrConnectWithoutAppInput | InstalledAppCreateOrConnectWithoutAppInput[]
    upsert?: InstalledAppUpsertWithWhereUniqueWithoutAppInput | InstalledAppUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: InstalledAppCreateManyAppInputEnvelope
    set?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    disconnect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    delete?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    connect?: InstalledAppWhereUniqueInput | InstalledAppWhereUniqueInput[]
    update?: InstalledAppUpdateWithWhereUniqueWithoutAppInput | InstalledAppUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: InstalledAppUpdateManyWithWhereWithoutAppInput | InstalledAppUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: InstalledAppScalarWhereInput | InstalledAppScalarWhereInput[]
  }

  export type CreatorCreateNestedOneWithoutInstalledAppsInput = {
    create?: XOR<CreatorCreateWithoutInstalledAppsInput, CreatorUncheckedCreateWithoutInstalledAppsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutInstalledAppsInput
    connect?: CreatorWhereUniqueInput
  }

  export type AppCreateNestedOneWithoutInstallationsInput = {
    create?: XOR<AppCreateWithoutInstallationsInput, AppUncheckedCreateWithoutInstallationsInput>
    connectOrCreate?: AppCreateOrConnectWithoutInstallationsInput
    connect?: AppWhereUniqueInput
  }

  export type EnumAppStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppStatus
  }

  export type NullableEnumBillingIntervalFieldUpdateOperationsInput = {
    set?: $Enums.BillingInterval | null
  }

  export type CreatorUpdateOneRequiredWithoutInstalledAppsNestedInput = {
    create?: XOR<CreatorCreateWithoutInstalledAppsInput, CreatorUncheckedCreateWithoutInstalledAppsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutInstalledAppsInput
    upsert?: CreatorUpsertWithoutInstalledAppsInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutInstalledAppsInput, CreatorUpdateWithoutInstalledAppsInput>, CreatorUncheckedUpdateWithoutInstalledAppsInput>
  }

  export type AppUpdateOneRequiredWithoutInstallationsNestedInput = {
    create?: XOR<AppCreateWithoutInstallationsInput, AppUncheckedCreateWithoutInstallationsInput>
    connectOrCreate?: AppCreateOrConnectWithoutInstallationsInput
    upsert?: AppUpsertWithoutInstallationsInput
    connect?: AppWhereUniqueInput
    update?: XOR<XOR<AppUpdateToOneWithWhereWithoutInstallationsInput, AppUpdateWithoutInstallationsInput>, AppUncheckedUpdateWithoutInstallationsInput>
  }

  export type CreatorCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<CreatorCreateWithoutAuditLogsInput, CreatorUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutAuditLogsInput
    connect?: CreatorWhereUniqueInput
  }

  export type EnumActorTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActorType
  }

  export type CreatorUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<CreatorCreateWithoutAuditLogsInput, CreatorUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutAuditLogsInput
    upsert?: CreatorUpsertWithoutAuditLogsInput
    disconnect?: CreatorWhereInput | boolean
    delete?: CreatorWhereInput | boolean
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutAuditLogsInput, CreatorUpdateWithoutAuditLogsInput>, CreatorUncheckedUpdateWithoutAuditLogsInput>
  }

  export type LedgerEntryCreateNestedManyWithoutAccountInput = {
    create?: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput> | LedgerEntryCreateWithoutAccountInput[] | LedgerEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutAccountInput | LedgerEntryCreateOrConnectWithoutAccountInput[]
    createMany?: LedgerEntryCreateManyAccountInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput> | LedgerEntryCreateWithoutAccountInput[] | LedgerEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutAccountInput | LedgerEntryCreateOrConnectWithoutAccountInput[]
    createMany?: LedgerEntryCreateManyAccountInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EnumLedgerAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.LedgerAccountType
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type LedgerEntryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput> | LedgerEntryCreateWithoutAccountInput[] | LedgerEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutAccountInput | LedgerEntryCreateOrConnectWithoutAccountInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutAccountInput | LedgerEntryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: LedgerEntryCreateManyAccountInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutAccountInput | LedgerEntryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutAccountInput | LedgerEntryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput> | LedgerEntryCreateWithoutAccountInput[] | LedgerEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutAccountInput | LedgerEntryCreateOrConnectWithoutAccountInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutAccountInput | LedgerEntryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: LedgerEntryCreateManyAccountInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutAccountInput | LedgerEntryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutAccountInput | LedgerEntryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutTransactionInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EnumLedgerTransactionKindFieldUpdateOperationsInput = {
    set?: $Enums.LedgerTransactionKind
  }

  export type LedgerEntryUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput | LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput | LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutTransactionInput | LedgerEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput | LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput | LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutTransactionInput | LedgerEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerTransactionCreateNestedOneWithoutEntriesInput = {
    create?: XOR<LedgerTransactionCreateWithoutEntriesInput, LedgerTransactionUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutEntriesInput
    connect?: LedgerTransactionWhereUniqueInput
  }

  export type LedgerAccountCreateNestedOneWithoutEntriesInput = {
    create?: XOR<LedgerAccountCreateWithoutEntriesInput, LedgerAccountUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: LedgerAccountCreateOrConnectWithoutEntriesInput
    connect?: LedgerAccountWhereUniqueInput
  }

  export type EnumLedgerDirectionFieldUpdateOperationsInput = {
    set?: $Enums.LedgerDirection
  }

  export type LedgerTransactionUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<LedgerTransactionCreateWithoutEntriesInput, LedgerTransactionUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutEntriesInput
    upsert?: LedgerTransactionUpsertWithoutEntriesInput
    connect?: LedgerTransactionWhereUniqueInput
    update?: XOR<XOR<LedgerTransactionUpdateToOneWithWhereWithoutEntriesInput, LedgerTransactionUpdateWithoutEntriesInput>, LedgerTransactionUncheckedUpdateWithoutEntriesInput>
  }

  export type LedgerAccountUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<LedgerAccountCreateWithoutEntriesInput, LedgerAccountUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: LedgerAccountCreateOrConnectWithoutEntriesInput
    upsert?: LedgerAccountUpsertWithoutEntriesInput
    connect?: LedgerAccountWhereUniqueInput
    update?: XOR<XOR<LedgerAccountUpdateToOneWithWhereWithoutEntriesInput, LedgerAccountUpdateWithoutEntriesInput>, LedgerAccountUncheckedUpdateWithoutEntriesInput>
  }

  export type ExternalEarningsImportCreateNestedManyWithoutSourceInput = {
    create?: XOR<ExternalEarningsImportCreateWithoutSourceInput, ExternalEarningsImportUncheckedCreateWithoutSourceInput> | ExternalEarningsImportCreateWithoutSourceInput[] | ExternalEarningsImportUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ExternalEarningsImportCreateOrConnectWithoutSourceInput | ExternalEarningsImportCreateOrConnectWithoutSourceInput[]
    createMany?: ExternalEarningsImportCreateManySourceInputEnvelope
    connect?: ExternalEarningsImportWhereUniqueInput | ExternalEarningsImportWhereUniqueInput[]
  }

  export type NormalizedEarningCreateNestedManyWithoutSourceInput = {
    create?: XOR<NormalizedEarningCreateWithoutSourceInput, NormalizedEarningUncheckedCreateWithoutSourceInput> | NormalizedEarningCreateWithoutSourceInput[] | NormalizedEarningUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NormalizedEarningCreateOrConnectWithoutSourceInput | NormalizedEarningCreateOrConnectWithoutSourceInput[]
    createMany?: NormalizedEarningCreateManySourceInputEnvelope
    connect?: NormalizedEarningWhereUniqueInput | NormalizedEarningWhereUniqueInput[]
  }

  export type ExternalEarningsImportUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<ExternalEarningsImportCreateWithoutSourceInput, ExternalEarningsImportUncheckedCreateWithoutSourceInput> | ExternalEarningsImportCreateWithoutSourceInput[] | ExternalEarningsImportUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ExternalEarningsImportCreateOrConnectWithoutSourceInput | ExternalEarningsImportCreateOrConnectWithoutSourceInput[]
    createMany?: ExternalEarningsImportCreateManySourceInputEnvelope
    connect?: ExternalEarningsImportWhereUniqueInput | ExternalEarningsImportWhereUniqueInput[]
  }

  export type NormalizedEarningUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<NormalizedEarningCreateWithoutSourceInput, NormalizedEarningUncheckedCreateWithoutSourceInput> | NormalizedEarningCreateWithoutSourceInput[] | NormalizedEarningUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NormalizedEarningCreateOrConnectWithoutSourceInput | NormalizedEarningCreateOrConnectWithoutSourceInput[]
    createMany?: NormalizedEarningCreateManySourceInputEnvelope
    connect?: NormalizedEarningWhereUniqueInput | NormalizedEarningWhereUniqueInput[]
  }

  export type EnumExternalPlatformFieldUpdateOperationsInput = {
    set?: $Enums.ExternalPlatform
  }

  export type ExternalEarningsImportUpdateManyWithoutSourceNestedInput = {
    create?: XOR<ExternalEarningsImportCreateWithoutSourceInput, ExternalEarningsImportUncheckedCreateWithoutSourceInput> | ExternalEarningsImportCreateWithoutSourceInput[] | ExternalEarningsImportUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ExternalEarningsImportCreateOrConnectWithoutSourceInput | ExternalEarningsImportCreateOrConnectWithoutSourceInput[]
    upsert?: ExternalEarningsImportUpsertWithWhereUniqueWithoutSourceInput | ExternalEarningsImportUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: ExternalEarningsImportCreateManySourceInputEnvelope
    set?: ExternalEarningsImportWhereUniqueInput | ExternalEarningsImportWhereUniqueInput[]
    disconnect?: ExternalEarningsImportWhereUniqueInput | ExternalEarningsImportWhereUniqueInput[]
    delete?: ExternalEarningsImportWhereUniqueInput | ExternalEarningsImportWhereUniqueInput[]
    connect?: ExternalEarningsImportWhereUniqueInput | ExternalEarningsImportWhereUniqueInput[]
    update?: ExternalEarningsImportUpdateWithWhereUniqueWithoutSourceInput | ExternalEarningsImportUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: ExternalEarningsImportUpdateManyWithWhereWithoutSourceInput | ExternalEarningsImportUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: ExternalEarningsImportScalarWhereInput | ExternalEarningsImportScalarWhereInput[]
  }

  export type NormalizedEarningUpdateManyWithoutSourceNestedInput = {
    create?: XOR<NormalizedEarningCreateWithoutSourceInput, NormalizedEarningUncheckedCreateWithoutSourceInput> | NormalizedEarningCreateWithoutSourceInput[] | NormalizedEarningUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NormalizedEarningCreateOrConnectWithoutSourceInput | NormalizedEarningCreateOrConnectWithoutSourceInput[]
    upsert?: NormalizedEarningUpsertWithWhereUniqueWithoutSourceInput | NormalizedEarningUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: NormalizedEarningCreateManySourceInputEnvelope
    set?: NormalizedEarningWhereUniqueInput | NormalizedEarningWhereUniqueInput[]
    disconnect?: NormalizedEarningWhereUniqueInput | NormalizedEarningWhereUniqueInput[]
    delete?: NormalizedEarningWhereUniqueInput | NormalizedEarningWhereUniqueInput[]
    connect?: NormalizedEarningWhereUniqueInput | NormalizedEarningWhereUniqueInput[]
    update?: NormalizedEarningUpdateWithWhereUniqueWithoutSourceInput | NormalizedEarningUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: NormalizedEarningUpdateManyWithWhereWithoutSourceInput | NormalizedEarningUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: NormalizedEarningScalarWhereInput | NormalizedEarningScalarWhereInput[]
  }

  export type ExternalEarningsImportUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<ExternalEarningsImportCreateWithoutSourceInput, ExternalEarningsImportUncheckedCreateWithoutSourceInput> | ExternalEarningsImportCreateWithoutSourceInput[] | ExternalEarningsImportUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ExternalEarningsImportCreateOrConnectWithoutSourceInput | ExternalEarningsImportCreateOrConnectWithoutSourceInput[]
    upsert?: ExternalEarningsImportUpsertWithWhereUniqueWithoutSourceInput | ExternalEarningsImportUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: ExternalEarningsImportCreateManySourceInputEnvelope
    set?: ExternalEarningsImportWhereUniqueInput | ExternalEarningsImportWhereUniqueInput[]
    disconnect?: ExternalEarningsImportWhereUniqueInput | ExternalEarningsImportWhereUniqueInput[]
    delete?: ExternalEarningsImportWhereUniqueInput | ExternalEarningsImportWhereUniqueInput[]
    connect?: ExternalEarningsImportWhereUniqueInput | ExternalEarningsImportWhereUniqueInput[]
    update?: ExternalEarningsImportUpdateWithWhereUniqueWithoutSourceInput | ExternalEarningsImportUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: ExternalEarningsImportUpdateManyWithWhereWithoutSourceInput | ExternalEarningsImportUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: ExternalEarningsImportScalarWhereInput | ExternalEarningsImportScalarWhereInput[]
  }

  export type NormalizedEarningUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<NormalizedEarningCreateWithoutSourceInput, NormalizedEarningUncheckedCreateWithoutSourceInput> | NormalizedEarningCreateWithoutSourceInput[] | NormalizedEarningUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: NormalizedEarningCreateOrConnectWithoutSourceInput | NormalizedEarningCreateOrConnectWithoutSourceInput[]
    upsert?: NormalizedEarningUpsertWithWhereUniqueWithoutSourceInput | NormalizedEarningUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: NormalizedEarningCreateManySourceInputEnvelope
    set?: NormalizedEarningWhereUniqueInput | NormalizedEarningWhereUniqueInput[]
    disconnect?: NormalizedEarningWhereUniqueInput | NormalizedEarningWhereUniqueInput[]
    delete?: NormalizedEarningWhereUniqueInput | NormalizedEarningWhereUniqueInput[]
    connect?: NormalizedEarningWhereUniqueInput | NormalizedEarningWhereUniqueInput[]
    update?: NormalizedEarningUpdateWithWhereUniqueWithoutSourceInput | NormalizedEarningUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: NormalizedEarningUpdateManyWithWhereWithoutSourceInput | NormalizedEarningUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: NormalizedEarningScalarWhereInput | NormalizedEarningScalarWhereInput[]
  }

  export type ExternalEarningsSourceCreateNestedOneWithoutImportsInput = {
    create?: XOR<ExternalEarningsSourceCreateWithoutImportsInput, ExternalEarningsSourceUncheckedCreateWithoutImportsInput>
    connectOrCreate?: ExternalEarningsSourceCreateOrConnectWithoutImportsInput
    connect?: ExternalEarningsSourceWhereUniqueInput
  }

  export type ExternalEarningsSourceUpdateOneRequiredWithoutImportsNestedInput = {
    create?: XOR<ExternalEarningsSourceCreateWithoutImportsInput, ExternalEarningsSourceUncheckedCreateWithoutImportsInput>
    connectOrCreate?: ExternalEarningsSourceCreateOrConnectWithoutImportsInput
    upsert?: ExternalEarningsSourceUpsertWithoutImportsInput
    connect?: ExternalEarningsSourceWhereUniqueInput
    update?: XOR<XOR<ExternalEarningsSourceUpdateToOneWithWhereWithoutImportsInput, ExternalEarningsSourceUpdateWithoutImportsInput>, ExternalEarningsSourceUncheckedUpdateWithoutImportsInput>
  }

  export type ExternalEarningsSourceCreateNestedOneWithoutEarningsInput = {
    create?: XOR<ExternalEarningsSourceCreateWithoutEarningsInput, ExternalEarningsSourceUncheckedCreateWithoutEarningsInput>
    connectOrCreate?: ExternalEarningsSourceCreateOrConnectWithoutEarningsInput
    connect?: ExternalEarningsSourceWhereUniqueInput
  }

  export type ExternalEarningsSourceUpdateOneRequiredWithoutEarningsNestedInput = {
    create?: XOR<ExternalEarningsSourceCreateWithoutEarningsInput, ExternalEarningsSourceUncheckedCreateWithoutEarningsInput>
    connectOrCreate?: ExternalEarningsSourceCreateOrConnectWithoutEarningsInput
    upsert?: ExternalEarningsSourceUpsertWithoutEarningsInput
    connect?: ExternalEarningsSourceWhereUniqueInput
    update?: XOR<XOR<ExternalEarningsSourceUpdateToOneWithWhereWithoutEarningsInput, ExternalEarningsSourceUpdateWithoutEarningsInput>, ExternalEarningsSourceUncheckedUpdateWithoutEarningsInput>
  }

  export type EnumDunningStatusFieldUpdateOperationsInput = {
    set?: $Enums.DunningStatus
  }

  export type EnumAutomationTriggerFieldUpdateOperationsInput = {
    set?: $Enums.AutomationTrigger
  }

  export type EnumAutomationStatusFieldUpdateOperationsInput = {
    set?: $Enums.AutomationStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumKycStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusFilter<$PrismaModel> | $Enums.KycStatus
  }

  export type NestedEnumCommissionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionTier | EnumCommissionTierFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionTier[] | ListEnumCommissionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionTier[] | ListEnumCommissionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionTierFilter<$PrismaModel> | $Enums.CommissionTier
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumKycStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusWithAggregatesFilter<$PrismaModel> | $Enums.KycStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKycStatusFilter<$PrismaModel>
    _max?: NestedEnumKycStatusFilter<$PrismaModel>
  }

  export type NestedEnumCommissionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionTier | EnumCommissionTierFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionTier[] | ListEnumCommissionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionTier[] | ListEnumCommissionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionTierWithAggregatesFilter<$PrismaModel> | $Enums.CommissionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommissionTierFilter<$PrismaModel>
    _max?: NestedEnumCommissionTierFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPayoutFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutFrequency | EnumPayoutFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutFrequency[] | ListEnumPayoutFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutFrequency[] | ListEnumPayoutFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutFrequencyFilter<$PrismaModel> | $Enums.PayoutFrequency
  }

  export type NestedEnumContentAccessFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentAccess | EnumContentAccessFieldRefInput<$PrismaModel>
    in?: $Enums.ContentAccess[] | ListEnumContentAccessFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentAccess[] | ListEnumContentAccessFieldRefInput<$PrismaModel>
    not?: NestedEnumContentAccessFilter<$PrismaModel> | $Enums.ContentAccess
  }

  export type NestedEnumPayoutFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutFrequency | EnumPayoutFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutFrequency[] | ListEnumPayoutFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutFrequency[] | ListEnumPayoutFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.PayoutFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutFrequencyFilter<$PrismaModel>
    _max?: NestedEnumPayoutFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumContentAccessWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentAccess | EnumContentAccessFieldRefInput<$PrismaModel>
    in?: $Enums.ContentAccess[] | ListEnumContentAccessFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentAccess[] | ListEnumContentAccessFieldRefInput<$PrismaModel>
    not?: NestedEnumContentAccessWithAggregatesFilter<$PrismaModel> | $Enums.ContentAccess
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentAccessFilter<$PrismaModel>
    _max?: NestedEnumContentAccessFilter<$PrismaModel>
  }

  export type NestedEnumBillingIntervalFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingInterval | EnumBillingIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingIntervalFilter<$PrismaModel> | $Enums.BillingInterval
  }

  export type NestedEnumBillingIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingInterval | EnumBillingIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingIntervalWithAggregatesFilter<$PrismaModel> | $Enums.BillingInterval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingIntervalFilter<$PrismaModel>
    _max?: NestedEnumBillingIntervalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type NestedEnumPayoutMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutMethod | EnumPayoutMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutMethodFilter<$PrismaModel> | $Enums.PayoutMethod
  }

  export type NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type NestedEnumPayoutMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutMethod | EnumPayoutMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutMethodWithAggregatesFilter<$PrismaModel> | $Enums.PayoutMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutMethodFilter<$PrismaModel>
    _max?: NestedEnumPayoutMethodFilter<$PrismaModel>
  }

  export type NestedEnumCampaignTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignTypeFilter<$PrismaModel> | $Enums.CampaignType
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumCampaignTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignTypeFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type NestedEnumRecipientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipientStatus | EnumRecipientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipientStatusFilter<$PrismaModel> | $Enums.RecipientStatus
  }

  export type NestedEnumRecipientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipientStatus | EnumRecipientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipientStatus[] | ListEnumRecipientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipientStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecipientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecipientStatusFilter<$PrismaModel>
    _max?: NestedEnumRecipientStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AppCategory | EnumAppCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AppCategory[] | ListEnumAppCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppCategory[] | ListEnumAppCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAppCategoryFilter<$PrismaModel> | $Enums.AppCategory
  }

  export type NestedEnumAppPricingFilter<$PrismaModel = never> = {
    equals?: $Enums.AppPricing | EnumAppPricingFieldRefInput<$PrismaModel>
    in?: $Enums.AppPricing[] | ListEnumAppPricingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppPricing[] | ListEnumAppPricingFieldRefInput<$PrismaModel>
    not?: NestedEnumAppPricingFilter<$PrismaModel> | $Enums.AppPricing
  }

  export type NestedEnumAppCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppCategory | EnumAppCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AppCategory[] | ListEnumAppCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppCategory[] | ListEnumAppCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAppCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AppCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppCategoryFilter<$PrismaModel>
    _max?: NestedEnumAppCategoryFilter<$PrismaModel>
  }

  export type NestedEnumAppPricingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppPricing | EnumAppPricingFieldRefInput<$PrismaModel>
    in?: $Enums.AppPricing[] | ListEnumAppPricingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppPricing[] | ListEnumAppPricingFieldRefInput<$PrismaModel>
    not?: NestedEnumAppPricingWithAggregatesFilter<$PrismaModel> | $Enums.AppPricing
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppPricingFilter<$PrismaModel>
    _max?: NestedEnumAppPricingFilter<$PrismaModel>
  }

  export type NestedEnumAppStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusFilter<$PrismaModel> | $Enums.AppStatus
  }

  export type NestedEnumBillingIntervalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingInterval | EnumBillingIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBillingIntervalNullableFilter<$PrismaModel> | $Enums.BillingInterval | null
  }

  export type NestedEnumAppStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppStatusFilter<$PrismaModel>
    _max?: NestedEnumAppStatusFilter<$PrismaModel>
  }

  export type NestedEnumBillingIntervalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingInterval | EnumBillingIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BillingInterval[] | ListEnumBillingIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBillingIntervalNullableWithAggregatesFilter<$PrismaModel> | $Enums.BillingInterval | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBillingIntervalNullableFilter<$PrismaModel>
    _max?: NestedEnumBillingIntervalNullableFilter<$PrismaModel>
  }

  export type NestedEnumActorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeFilter<$PrismaModel> | $Enums.ActorType
  }

  export type NestedEnumActorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActorTypeFilter<$PrismaModel>
    _max?: NestedEnumActorTypeFilter<$PrismaModel>
  }

  export type NestedEnumLedgerAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerAccountType | EnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerAccountType[] | ListEnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerAccountType[] | ListEnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerAccountTypeFilter<$PrismaModel> | $Enums.LedgerAccountType
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumLedgerAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerAccountType | EnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerAccountType[] | ListEnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerAccountType[] | ListEnumLedgerAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerAccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerAccountTypeFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumLedgerTransactionKindFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerTransactionKind | EnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerTransactionKind[] | ListEnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerTransactionKind[] | ListEnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTransactionKindFilter<$PrismaModel> | $Enums.LedgerTransactionKind
  }

  export type NestedEnumLedgerTransactionKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerTransactionKind | EnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerTransactionKind[] | ListEnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerTransactionKind[] | ListEnumLedgerTransactionKindFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTransactionKindWithAggregatesFilter<$PrismaModel> | $Enums.LedgerTransactionKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerTransactionKindFilter<$PrismaModel>
    _max?: NestedEnumLedgerTransactionKindFilter<$PrismaModel>
  }

  export type NestedEnumLedgerDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerDirection | EnumLedgerDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerDirectionFilter<$PrismaModel> | $Enums.LedgerDirection
  }

  export type NestedEnumLedgerDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerDirection | EnumLedgerDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerDirectionWithAggregatesFilter<$PrismaModel> | $Enums.LedgerDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerDirectionFilter<$PrismaModel>
    _max?: NestedEnumLedgerDirectionFilter<$PrismaModel>
  }

  export type NestedEnumExternalPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalPlatform | EnumExternalPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalPlatform[] | ListEnumExternalPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalPlatform[] | ListEnumExternalPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalPlatformFilter<$PrismaModel> | $Enums.ExternalPlatform
  }

  export type NestedEnumExternalPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalPlatform | EnumExternalPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalPlatform[] | ListEnumExternalPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalPlatform[] | ListEnumExternalPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalPlatformWithAggregatesFilter<$PrismaModel> | $Enums.ExternalPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExternalPlatformFilter<$PrismaModel>
    _max?: NestedEnumExternalPlatformFilter<$PrismaModel>
  }

  export type NestedEnumDunningStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DunningStatus | EnumDunningStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DunningStatus[] | ListEnumDunningStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DunningStatus[] | ListEnumDunningStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDunningStatusFilter<$PrismaModel> | $Enums.DunningStatus
  }

  export type NestedEnumDunningStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DunningStatus | EnumDunningStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DunningStatus[] | ListEnumDunningStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DunningStatus[] | ListEnumDunningStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDunningStatusWithAggregatesFilter<$PrismaModel> | $Enums.DunningStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDunningStatusFilter<$PrismaModel>
    _max?: NestedEnumDunningStatusFilter<$PrismaModel>
  }

  export type NestedEnumAutomationTriggerFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTrigger | EnumAutomationTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTrigger[] | ListEnumAutomationTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTrigger[] | ListEnumAutomationTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerFilter<$PrismaModel> | $Enums.AutomationTrigger
  }

  export type NestedEnumAutomationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusFilter<$PrismaModel> | $Enums.AutomationStatus
  }

  export type NestedEnumAutomationTriggerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTrigger | EnumAutomationTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTrigger[] | ListEnumAutomationTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTrigger[] | ListEnumAutomationTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerWithAggregatesFilter<$PrismaModel> | $Enums.AutomationTrigger
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationTriggerFilter<$PrismaModel>
    _max?: NestedEnumAutomationTriggerFilter<$PrismaModel>
  }

  export type NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SubscriptionPlanCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    interval: $Enums.BillingInterval
    intervalCount?: number
    features: JsonNullValueInput | InputJsonValue
    maxDownloads?: number | null
    earlyAccess?: boolean
    exclusiveContent?: boolean
    trialPeriodDays?: number | null
    stripePriceId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    interval: $Enums.BillingInterval
    intervalCount?: number
    features: JsonNullValueInput | InputJsonValue
    maxDownloads?: number | null
    earlyAccess?: boolean
    exclusiveContent?: boolean
    trialPeriodDays?: number | null
    stripePriceId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanCreateOrConnectWithoutCreatorInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutCreatorInput, SubscriptionPlanUncheckedCreateWithoutCreatorInput>
  }

  export type SubscriptionPlanCreateManyCreatorInputEnvelope = {
    data: SubscriptionPlanCreateManyCreatorInput | SubscriptionPlanCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutCreatorInput = {
    id?: string
    type: $Enums.ProductType
    title: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    contentUrl?: string | null
    thumbnailUrl?: string | null
    previewUrl?: string | null
    accessType: $Enums.ContentAccess
    requiresSubscription?: boolean
    tags?: ProductCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    purchaseCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCreatorInput = {
    id?: string
    type: $Enums.ProductType
    title: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    contentUrl?: string | null
    thumbnailUrl?: string | null
    previewUrl?: string | null
    accessType: $Enums.ContentAccess
    requiresSubscription?: boolean
    tags?: ProductCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    purchaseCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCreatorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCreatorInput, ProductUncheckedCreateWithoutCreatorInput>
  }

  export type ProductCreateManyCreatorInputEnvelope = {
    data: ProductCreateManyCreatorInput | ProductCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutCreatorInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fan: FanCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutCreatorInput = {
    id?: string
    fanId: string
    planId: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutCreatorInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCreatorInput, SubscriptionUncheckedCreateWithoutCreatorInput>
  }

  export type SubscriptionCreateManyCreatorInputEnvelope = {
    data: SubscriptionCreateManyCreatorInput | SubscriptionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCreatorInput = {
    id?: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    fan?: FanCreateNestedOneWithoutTransactionsInput
    purchase?: PurchaseCreateNestedOneWithoutTransactionInput
    payout?: PayoutCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutCreatorInput = {
    id?: string
    fanId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    purchaseId?: string | null
    payoutId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput>
  }

  export type TransactionCreateManyCreatorInputEnvelope = {
    data: TransactionCreateManyCreatorInput | TransactionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type PayoutCreateWithoutCreatorInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PayoutStatus
    method: $Enums.PayoutMethod
    destination?: string | null
    stripePayoutId?: string | null
    processedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutPayoutInput
  }

  export type PayoutUncheckedCreateWithoutCreatorInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PayoutStatus
    method: $Enums.PayoutMethod
    destination?: string | null
    stripePayoutId?: string | null
    processedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutPayoutInput
  }

  export type PayoutCreateOrConnectWithoutCreatorInput = {
    where: PayoutWhereUniqueInput
    create: XOR<PayoutCreateWithoutCreatorInput, PayoutUncheckedCreateWithoutCreatorInput>
  }

  export type PayoutCreateManyCreatorInputEnvelope = {
    data: PayoutCreateManyCreatorInput | PayoutCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsCreateWithoutCreatorInput = {
    id?: string
    date: Date | string
    revenue?: Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: Decimal | DecimalJsLike | number | string
    productRevenue?: Decimal | DecimalJsLike | number | string
    newSubscribers?: number
    churned?: number
    activeSubscribers?: number
    pageViews?: number
    uniqueVisitors?: number
    contentViews?: number
    conversionRate?: Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AnalyticsUncheckedCreateWithoutCreatorInput = {
    id?: string
    date: Date | string
    revenue?: Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: Decimal | DecimalJsLike | number | string
    productRevenue?: Decimal | DecimalJsLike | number | string
    newSubscribers?: number
    churned?: number
    activeSubscribers?: number
    pageViews?: number
    uniqueVisitors?: number
    contentViews?: number
    conversionRate?: Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AnalyticsCreateOrConnectWithoutCreatorInput = {
    where: AnalyticsWhereUniqueInput
    create: XOR<AnalyticsCreateWithoutCreatorInput, AnalyticsUncheckedCreateWithoutCreatorInput>
  }

  export type AnalyticsCreateManyCreatorInputEnvelope = {
    data: AnalyticsCreateManyCreatorInput | AnalyticsCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type InstalledAppCreateWithoutCreatorInput = {
    id?: string
    status: $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: $Enums.BillingInterval | null
    nextBilling?: Date | string | null
    installedAt?: Date | string
    uninstalledAt?: Date | string | null
    app: AppCreateNestedOneWithoutInstallationsInput
  }

  export type InstalledAppUncheckedCreateWithoutCreatorInput = {
    id?: string
    appId: string
    status: $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: $Enums.BillingInterval | null
    nextBilling?: Date | string | null
    installedAt?: Date | string
    uninstalledAt?: Date | string | null
  }

  export type InstalledAppCreateOrConnectWithoutCreatorInput = {
    where: InstalledAppWhereUniqueInput
    create: XOR<InstalledAppCreateWithoutCreatorInput, InstalledAppUncheckedCreateWithoutCreatorInput>
  }

  export type InstalledAppCreateManyCreatorInputEnvelope = {
    data: InstalledAppCreateManyCreatorInput | InstalledAppCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutCreatorInput = {
    id?: string
    actorId: string
    actorType: $Enums.ActorType
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutCreatorInput = {
    id?: string
    actorId: string
    actorType: $Enums.ActorType
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutCreatorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCreatorInput, AuditLogUncheckedCreateWithoutCreatorInput>
  }

  export type AuditLogCreateManyCreatorInputEnvelope = {
    data: AuditLogCreateManyCreatorInput | AuditLogCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CreatorSettingsCreateWithoutCreatorInput = {
    id?: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    showPublicProfile?: boolean
    allowDMs?: boolean
    minPayout?: Decimal | DecimalJsLike | number | string
    payoutFrequency?: $Enums.PayoutFrequency
    taxFormSubmitted?: boolean
    w9Submitted?: boolean
    defaultContentAccess?: $Enums.ContentAccess
    watermarkContent?: boolean
    updatedAt?: Date | string
  }

  export type CreatorSettingsUncheckedCreateWithoutCreatorInput = {
    id?: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    showPublicProfile?: boolean
    allowDMs?: boolean
    minPayout?: Decimal | DecimalJsLike | number | string
    payoutFrequency?: $Enums.PayoutFrequency
    taxFormSubmitted?: boolean
    w9Submitted?: boolean
    defaultContentAccess?: $Enums.ContentAccess
    watermarkContent?: boolean
    updatedAt?: Date | string
  }

  export type CreatorSettingsCreateOrConnectWithoutCreatorInput = {
    where: CreatorSettingsWhereUniqueInput
    create: XOR<CreatorSettingsCreateWithoutCreatorInput, CreatorSettingsUncheckedCreateWithoutCreatorInput>
  }

  export type FanRelationCreateWithoutCreatorInput = {
    id?: string
    tags?: FanRelationCreatetagsInput | string[]
    notes?: string | null
    engagementScore?: number
    lifetimeValue?: Decimal | DecimalJsLike | number | string
    lastInteraction?: Date | string | null
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fan: FanCreateNestedOneWithoutFanRelationsInput
  }

  export type FanRelationUncheckedCreateWithoutCreatorInput = {
    id?: string
    fanId: string
    tags?: FanRelationCreatetagsInput | string[]
    notes?: string | null
    engagementScore?: number
    lifetimeValue?: Decimal | DecimalJsLike | number | string
    lastInteraction?: Date | string | null
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FanRelationCreateOrConnectWithoutCreatorInput = {
    where: FanRelationWhereUniqueInput
    create: XOR<FanRelationCreateWithoutCreatorInput, FanRelationUncheckedCreateWithoutCreatorInput>
  }

  export type FanRelationCreateManyCreatorInputEnvelope = {
    data: FanRelationCreateManyCreatorInput | FanRelationCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: $Enums.CampaignType
    status: $Enums.CampaignStatus
    subject?: string | null
    content: string
    targetTags?: CampaignCreatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: CampaignRecipientCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: $Enums.CampaignType
    status: $Enums.CampaignStatus
    subject?: string | null
    content: string
    targetTags?: CampaignCreatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: CampaignRecipientUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCreatorInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput>
  }

  export type CampaignCreateManyCreatorInputEnvelope = {
    data: CampaignCreateManyCreatorInput | CampaignCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionPlanUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SubscriptionPlanWhereUniqueInput
    update: XOR<SubscriptionPlanUpdateWithoutCreatorInput, SubscriptionPlanUncheckedUpdateWithoutCreatorInput>
    create: XOR<SubscriptionPlanCreateWithoutCreatorInput, SubscriptionPlanUncheckedCreateWithoutCreatorInput>
  }

  export type SubscriptionPlanUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SubscriptionPlanWhereUniqueInput
    data: XOR<SubscriptionPlanUpdateWithoutCreatorInput, SubscriptionPlanUncheckedUpdateWithoutCreatorInput>
  }

  export type SubscriptionPlanUpdateManyWithWhereWithoutCreatorInput = {
    where: SubscriptionPlanScalarWhereInput
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SubscriptionPlanScalarWhereInput = {
    AND?: SubscriptionPlanScalarWhereInput | SubscriptionPlanScalarWhereInput[]
    OR?: SubscriptionPlanScalarWhereInput[]
    NOT?: SubscriptionPlanScalarWhereInput | SubscriptionPlanScalarWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    creatorId?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    interval?: EnumBillingIntervalFilter<"SubscriptionPlan"> | $Enums.BillingInterval
    intervalCount?: IntFilter<"SubscriptionPlan"> | number
    features?: JsonFilter<"SubscriptionPlan">
    maxDownloads?: IntNullableFilter<"SubscriptionPlan"> | number | null
    earlyAccess?: BoolFilter<"SubscriptionPlan"> | boolean
    exclusiveContent?: BoolFilter<"SubscriptionPlan"> | boolean
    trialPeriodDays?: IntNullableFilter<"SubscriptionPlan"> | number | null
    stripePriceId?: StringNullableFilter<"SubscriptionPlan"> | string | null
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCreatorInput, ProductUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProductCreateWithoutCreatorInput, ProductUncheckedCreateWithoutCreatorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCreatorInput, ProductUncheckedUpdateWithoutCreatorInput>
  }

  export type ProductUpdateManyWithWhereWithoutCreatorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    creatorId?: StringFilter<"Product"> | string
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    title?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Product"> | string
    contentUrl?: StringNullableFilter<"Product"> | string | null
    thumbnailUrl?: StringNullableFilter<"Product"> | string | null
    previewUrl?: StringNullableFilter<"Product"> | string | null
    accessType?: EnumContentAccessFilter<"Product"> | $Enums.ContentAccess
    requiresSubscription?: BoolFilter<"Product"> | boolean
    tags?: StringNullableListFilter<"Product">
    isPublished?: BoolFilter<"Product"> | boolean
    publishedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    viewCount?: IntFilter<"Product"> | number
    purchaseCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutCreatorInput, SubscriptionUncheckedUpdateWithoutCreatorInput>
    create: XOR<SubscriptionCreateWithoutCreatorInput, SubscriptionUncheckedCreateWithoutCreatorInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutCreatorInput, SubscriptionUncheckedUpdateWithoutCreatorInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutCreatorInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    fanId?: StringFilter<"Subscription"> | string
    creatorId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    totalSpent?: DecimalFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCreatorInput, TransactionUncheckedUpdateWithoutCreatorInput>
    create: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCreatorInput, TransactionUncheckedUpdateWithoutCreatorInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCreatorInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    creatorId?: StringFilter<"Transaction"> | string
    fanId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    platformFee?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    subscriptionId?: StringNullableFilter<"Transaction"> | string | null
    purchaseId?: StringNullableFilter<"Transaction"> | string | null
    payoutId?: StringNullableFilter<"Transaction"> | string | null
    stripeTransferId?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type PayoutUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PayoutWhereUniqueInput
    update: XOR<PayoutUpdateWithoutCreatorInput, PayoutUncheckedUpdateWithoutCreatorInput>
    create: XOR<PayoutCreateWithoutCreatorInput, PayoutUncheckedCreateWithoutCreatorInput>
  }

  export type PayoutUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PayoutWhereUniqueInput
    data: XOR<PayoutUpdateWithoutCreatorInput, PayoutUncheckedUpdateWithoutCreatorInput>
  }

  export type PayoutUpdateManyWithWhereWithoutCreatorInput = {
    where: PayoutScalarWhereInput
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PayoutScalarWhereInput = {
    AND?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
    OR?: PayoutScalarWhereInput[]
    NOT?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
    id?: StringFilter<"Payout"> | string
    creatorId?: StringFilter<"Payout"> | string
    amount?: DecimalFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payout"> | string
    status?: EnumPayoutStatusFilter<"Payout"> | $Enums.PayoutStatus
    method?: EnumPayoutMethodFilter<"Payout"> | $Enums.PayoutMethod
    destination?: StringNullableFilter<"Payout"> | string | null
    stripePayoutId?: StringNullableFilter<"Payout"> | string | null
    processedAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
    failureReason?: StringNullableFilter<"Payout"> | string | null
    createdAt?: DateTimeFilter<"Payout"> | Date | string
    updatedAt?: DateTimeFilter<"Payout"> | Date | string
  }

  export type AnalyticsUpsertWithWhereUniqueWithoutCreatorInput = {
    where: AnalyticsWhereUniqueInput
    update: XOR<AnalyticsUpdateWithoutCreatorInput, AnalyticsUncheckedUpdateWithoutCreatorInput>
    create: XOR<AnalyticsCreateWithoutCreatorInput, AnalyticsUncheckedCreateWithoutCreatorInput>
  }

  export type AnalyticsUpdateWithWhereUniqueWithoutCreatorInput = {
    where: AnalyticsWhereUniqueInput
    data: XOR<AnalyticsUpdateWithoutCreatorInput, AnalyticsUncheckedUpdateWithoutCreatorInput>
  }

  export type AnalyticsUpdateManyWithWhereWithoutCreatorInput = {
    where: AnalyticsScalarWhereInput
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AnalyticsScalarWhereInput = {
    AND?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
    OR?: AnalyticsScalarWhereInput[]
    NOT?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
    id?: StringFilter<"Analytics"> | string
    creatorId?: StringFilter<"Analytics"> | string
    date?: DateTimeFilter<"Analytics"> | Date | string
    revenue?: DecimalFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: DecimalFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    productRevenue?: DecimalFilter<"Analytics"> | Decimal | DecimalJsLike | number | string
    newSubscribers?: IntFilter<"Analytics"> | number
    churned?: IntFilter<"Analytics"> | number
    activeSubscribers?: IntFilter<"Analytics"> | number
    pageViews?: IntFilter<"Analytics"> | number
    uniqueVisitors?: IntFilter<"Analytics"> | number
    contentViews?: IntFilter<"Analytics"> | number
    conversionRate?: DecimalNullableFilter<"Analytics"> | Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: DecimalNullableFilter<"Analytics"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
  }

  export type InstalledAppUpsertWithWhereUniqueWithoutCreatorInput = {
    where: InstalledAppWhereUniqueInput
    update: XOR<InstalledAppUpdateWithoutCreatorInput, InstalledAppUncheckedUpdateWithoutCreatorInput>
    create: XOR<InstalledAppCreateWithoutCreatorInput, InstalledAppUncheckedCreateWithoutCreatorInput>
  }

  export type InstalledAppUpdateWithWhereUniqueWithoutCreatorInput = {
    where: InstalledAppWhereUniqueInput
    data: XOR<InstalledAppUpdateWithoutCreatorInput, InstalledAppUncheckedUpdateWithoutCreatorInput>
  }

  export type InstalledAppUpdateManyWithWhereWithoutCreatorInput = {
    where: InstalledAppScalarWhereInput
    data: XOR<InstalledAppUpdateManyMutationInput, InstalledAppUncheckedUpdateManyWithoutCreatorInput>
  }

  export type InstalledAppScalarWhereInput = {
    AND?: InstalledAppScalarWhereInput | InstalledAppScalarWhereInput[]
    OR?: InstalledAppScalarWhereInput[]
    NOT?: InstalledAppScalarWhereInput | InstalledAppScalarWhereInput[]
    id?: StringFilter<"InstalledApp"> | string
    creatorId?: StringFilter<"InstalledApp"> | string
    appId?: StringFilter<"InstalledApp"> | string
    status?: EnumAppStatusFilter<"InstalledApp"> | $Enums.AppStatus
    settings?: JsonNullableFilter<"InstalledApp">
    billingCycle?: EnumBillingIntervalNullableFilter<"InstalledApp"> | $Enums.BillingInterval | null
    nextBilling?: DateTimeNullableFilter<"InstalledApp"> | Date | string | null
    installedAt?: DateTimeFilter<"InstalledApp"> | Date | string
    uninstalledAt?: DateTimeNullableFilter<"InstalledApp"> | Date | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCreatorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCreatorInput, AuditLogUncheckedUpdateWithoutCreatorInput>
    create: XOR<AuditLogCreateWithoutCreatorInput, AuditLogUncheckedCreateWithoutCreatorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCreatorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCreatorInput, AuditLogUncheckedUpdateWithoutCreatorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCreatorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    creatorId?: StringNullableFilter<"AuditLog"> | string | null
    actorId?: StringFilter<"AuditLog"> | string
    actorType?: EnumActorTypeFilter<"AuditLog"> | $Enums.ActorType
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type CreatorSettingsUpsertWithoutCreatorInput = {
    update: XOR<CreatorSettingsUpdateWithoutCreatorInput, CreatorSettingsUncheckedUpdateWithoutCreatorInput>
    create: XOR<CreatorSettingsCreateWithoutCreatorInput, CreatorSettingsUncheckedCreateWithoutCreatorInput>
    where?: CreatorSettingsWhereInput
  }

  export type CreatorSettingsUpdateToOneWithWhereWithoutCreatorInput = {
    where?: CreatorSettingsWhereInput
    data: XOR<CreatorSettingsUpdateWithoutCreatorInput, CreatorSettingsUncheckedUpdateWithoutCreatorInput>
  }

  export type CreatorSettingsUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    showPublicProfile?: BoolFieldUpdateOperationsInput | boolean
    allowDMs?: BoolFieldUpdateOperationsInput | boolean
    minPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutFrequency?: EnumPayoutFrequencyFieldUpdateOperationsInput | $Enums.PayoutFrequency
    taxFormSubmitted?: BoolFieldUpdateOperationsInput | boolean
    w9Submitted?: BoolFieldUpdateOperationsInput | boolean
    defaultContentAccess?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    watermarkContent?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorSettingsUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    showPublicProfile?: BoolFieldUpdateOperationsInput | boolean
    allowDMs?: BoolFieldUpdateOperationsInput | boolean
    minPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutFrequency?: EnumPayoutFrequencyFieldUpdateOperationsInput | $Enums.PayoutFrequency
    taxFormSubmitted?: BoolFieldUpdateOperationsInput | boolean
    w9Submitted?: BoolFieldUpdateOperationsInput | boolean
    defaultContentAccess?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    watermarkContent?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanRelationUpsertWithWhereUniqueWithoutCreatorInput = {
    where: FanRelationWhereUniqueInput
    update: XOR<FanRelationUpdateWithoutCreatorInput, FanRelationUncheckedUpdateWithoutCreatorInput>
    create: XOR<FanRelationCreateWithoutCreatorInput, FanRelationUncheckedCreateWithoutCreatorInput>
  }

  export type FanRelationUpdateWithWhereUniqueWithoutCreatorInput = {
    where: FanRelationWhereUniqueInput
    data: XOR<FanRelationUpdateWithoutCreatorInput, FanRelationUncheckedUpdateWithoutCreatorInput>
  }

  export type FanRelationUpdateManyWithWhereWithoutCreatorInput = {
    where: FanRelationScalarWhereInput
    data: XOR<FanRelationUpdateManyMutationInput, FanRelationUncheckedUpdateManyWithoutCreatorInput>
  }

  export type FanRelationScalarWhereInput = {
    AND?: FanRelationScalarWhereInput | FanRelationScalarWhereInput[]
    OR?: FanRelationScalarWhereInput[]
    NOT?: FanRelationScalarWhereInput | FanRelationScalarWhereInput[]
    id?: StringFilter<"FanRelation"> | string
    creatorId?: StringFilter<"FanRelation"> | string
    fanId?: StringFilter<"FanRelation"> | string
    tags?: StringNullableListFilter<"FanRelation">
    notes?: StringNullableFilter<"FanRelation"> | string | null
    engagementScore?: IntFilter<"FanRelation"> | number
    lifetimeValue?: DecimalFilter<"FanRelation"> | Decimal | DecimalJsLike | number | string
    lastInteraction?: DateTimeNullableFilter<"FanRelation"> | Date | string | null
    emailOptIn?: BoolFilter<"FanRelation"> | boolean
    smsOptIn?: BoolFilter<"FanRelation"> | boolean
    createdAt?: DateTimeFilter<"FanRelation"> | Date | string
    updatedAt?: DateTimeFilter<"FanRelation"> | Date | string
  }

  export type CampaignUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutCreatorInput, CampaignUncheckedUpdateWithoutCreatorInput>
    create: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutCreatorInput, CampaignUncheckedUpdateWithoutCreatorInput>
  }

  export type CampaignUpdateManyWithWhereWithoutCreatorInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    creatorId?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    type?: EnumCampaignTypeFilter<"Campaign"> | $Enums.CampaignType
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    subject?: StringNullableFilter<"Campaign"> | string | null
    content?: StringFilter<"Campaign"> | string
    targetTags?: StringNullableListFilter<"Campaign">
    targetSegment?: JsonNullableFilter<"Campaign">
    scheduledFor?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sentCount?: IntFilter<"Campaign"> | number
    openCount?: IntFilter<"Campaign"> | number
    clickCount?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type CreatorCreateWithoutSettingsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutCreatorInput
    products?: ProductCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionCreateNestedManyWithoutCreatorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    payouts?: PayoutCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutCreatorInput
    fanRelations?: FanRelationCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutSettingsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput
    products?: ProductUncheckedCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionUncheckedCreateNestedManyWithoutCreatorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCreatorInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutSettingsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutSettingsInput, CreatorUncheckedCreateWithoutSettingsInput>
  }

  export type CreatorUpsertWithoutSettingsInput = {
    update: XOR<CreatorUpdateWithoutSettingsInput, CreatorUncheckedUpdateWithoutSettingsInput>
    create: XOR<CreatorCreateWithoutSettingsInput, CreatorUncheckedCreateWithoutSettingsInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutSettingsInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutSettingsInput, CreatorUncheckedUpdateWithoutSettingsInput>
  }

  export type CreatorUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutCreatorNestedInput
    products?: ProductUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCreatorNestedInput
    fanRelations?: FanRelationUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCreatorNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorCreateWithoutSubscriptionPlansInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionCreateNestedManyWithoutCreatorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    payouts?: PayoutCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutSubscriptionPlansInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionUncheckedCreateNestedManyWithoutCreatorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutSubscriptionPlansInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutSubscriptionPlansInput, CreatorUncheckedCreateWithoutSubscriptionPlansInput>
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fan: FanCreateNestedOneWithoutSubscriptionsInput
    creator: CreatorCreateNestedOneWithoutSubscribersInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    fanId: string
    creatorId: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type CreatorUpsertWithoutSubscriptionPlansInput = {
    update: XOR<CreatorUpdateWithoutSubscriptionPlansInput, CreatorUncheckedUpdateWithoutSubscriptionPlansInput>
    create: XOR<CreatorCreateWithoutSubscriptionPlansInput, CreatorUncheckedCreateWithoutSubscriptionPlansInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutSubscriptionPlansInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutSubscriptionPlansInput, CreatorUncheckedUpdateWithoutSubscriptionPlansInput>
  }

  export type CreatorUpdateWithoutSubscriptionPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutSubscriptionPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type CreatorCreateWithoutProductsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionCreateNestedManyWithoutCreatorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    payouts?: PayoutCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutProductsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionUncheckedCreateNestedManyWithoutCreatorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutProductsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutProductsInput, CreatorUncheckedCreateWithoutProductsInput>
  }

  export type PurchaseCreateWithoutProductInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId?: string | null
    downloadCount?: number
    lastDownloadAt?: Date | string | null
    createdAt?: Date | string
    fan: FanCreateNestedOneWithoutPurchasesInput
    transaction?: TransactionCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutProductInput = {
    id?: string
    fanId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId?: string | null
    downloadCount?: number
    lastDownloadAt?: Date | string | null
    createdAt?: Date | string
    transaction?: TransactionUncheckedCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput>
  }

  export type PurchaseCreateManyProductInputEnvelope = {
    data: PurchaseCreateManyProductInput | PurchaseCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CreatorUpsertWithoutProductsInput = {
    update: XOR<CreatorUpdateWithoutProductsInput, CreatorUncheckedUpdateWithoutProductsInput>
    create: XOR<CreatorCreateWithoutProductsInput, CreatorUncheckedCreateWithoutProductsInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutProductsInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutProductsInput, CreatorUncheckedUpdateWithoutProductsInput>
  }

  export type CreatorUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PurchaseUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutProductInput, PurchaseUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutProductInput, PurchaseUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    fanId?: StringFilter<"Purchase"> | string
    productId?: StringFilter<"Purchase"> | string
    amount?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Purchase"> | string
    status?: EnumPurchaseStatusFilter<"Purchase"> | $Enums.PurchaseStatus
    stripePaymentIntentId?: StringNullableFilter<"Purchase"> | string | null
    downloadCount?: IntFilter<"Purchase"> | number
    lastDownloadAt?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type SubscriptionCreateWithoutFanInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutSubscribersInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutFanInput = {
    id?: string
    creatorId: string
    planId: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutFanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutFanInput, SubscriptionUncheckedCreateWithoutFanInput>
  }

  export type SubscriptionCreateManyFanInputEnvelope = {
    data: SubscriptionCreateManyFanInput | SubscriptionCreateManyFanInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutFanInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId?: string | null
    downloadCount?: number
    lastDownloadAt?: Date | string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutPurchasesInput
    transaction?: TransactionCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutFanInput = {
    id?: string
    productId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId?: string | null
    downloadCount?: number
    lastDownloadAt?: Date | string | null
    createdAt?: Date | string
    transaction?: TransactionUncheckedCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutFanInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutFanInput, PurchaseUncheckedCreateWithoutFanInput>
  }

  export type PurchaseCreateManyFanInputEnvelope = {
    data: PurchaseCreateManyFanInput | PurchaseCreateManyFanInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutFanInput = {
    id?: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    creator: CreatorCreateNestedOneWithoutTransactionsInput
    purchase?: PurchaseCreateNestedOneWithoutTransactionInput
    payout?: PayoutCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutFanInput = {
    id?: string
    creatorId: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    purchaseId?: string | null
    payoutId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutFanInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutFanInput, TransactionUncheckedCreateWithoutFanInput>
  }

  export type TransactionCreateManyFanInputEnvelope = {
    data: TransactionCreateManyFanInput | TransactionCreateManyFanInput[]
    skipDuplicates?: boolean
  }

  export type FanRelationCreateWithoutFanInput = {
    id?: string
    tags?: FanRelationCreatetagsInput | string[]
    notes?: string | null
    engagementScore?: number
    lifetimeValue?: Decimal | DecimalJsLike | number | string
    lastInteraction?: Date | string | null
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutFanRelationsInput
  }

  export type FanRelationUncheckedCreateWithoutFanInput = {
    id?: string
    creatorId: string
    tags?: FanRelationCreatetagsInput | string[]
    notes?: string | null
    engagementScore?: number
    lifetimeValue?: Decimal | DecimalJsLike | number | string
    lastInteraction?: Date | string | null
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FanRelationCreateOrConnectWithoutFanInput = {
    where: FanRelationWhereUniqueInput
    create: XOR<FanRelationCreateWithoutFanInput, FanRelationUncheckedCreateWithoutFanInput>
  }

  export type FanRelationCreateManyFanInputEnvelope = {
    data: FanRelationCreateManyFanInput | FanRelationCreateManyFanInput[]
    skipDuplicates?: boolean
  }

  export type CampaignRecipientCreateWithoutFanInput = {
    id?: string
    status: $Enums.RecipientStatus
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutRecipientsInput
  }

  export type CampaignRecipientUncheckedCreateWithoutFanInput = {
    id?: string
    campaignId: string
    status: $Enums.RecipientStatus
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
  }

  export type CampaignRecipientCreateOrConnectWithoutFanInput = {
    where: CampaignRecipientWhereUniqueInput
    create: XOR<CampaignRecipientCreateWithoutFanInput, CampaignRecipientUncheckedCreateWithoutFanInput>
  }

  export type CampaignRecipientCreateManyFanInputEnvelope = {
    data: CampaignRecipientCreateManyFanInput | CampaignRecipientCreateManyFanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutFanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutFanInput, SubscriptionUncheckedUpdateWithoutFanInput>
    create: XOR<SubscriptionCreateWithoutFanInput, SubscriptionUncheckedCreateWithoutFanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutFanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutFanInput, SubscriptionUncheckedUpdateWithoutFanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutFanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutFanInput>
  }

  export type PurchaseUpsertWithWhereUniqueWithoutFanInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutFanInput, PurchaseUncheckedUpdateWithoutFanInput>
    create: XOR<PurchaseCreateWithoutFanInput, PurchaseUncheckedCreateWithoutFanInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutFanInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutFanInput, PurchaseUncheckedUpdateWithoutFanInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutFanInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutFanInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutFanInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutFanInput, TransactionUncheckedUpdateWithoutFanInput>
    create: XOR<TransactionCreateWithoutFanInput, TransactionUncheckedCreateWithoutFanInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutFanInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutFanInput, TransactionUncheckedUpdateWithoutFanInput>
  }

  export type TransactionUpdateManyWithWhereWithoutFanInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutFanInput>
  }

  export type FanRelationUpsertWithWhereUniqueWithoutFanInput = {
    where: FanRelationWhereUniqueInput
    update: XOR<FanRelationUpdateWithoutFanInput, FanRelationUncheckedUpdateWithoutFanInput>
    create: XOR<FanRelationCreateWithoutFanInput, FanRelationUncheckedCreateWithoutFanInput>
  }

  export type FanRelationUpdateWithWhereUniqueWithoutFanInput = {
    where: FanRelationWhereUniqueInput
    data: XOR<FanRelationUpdateWithoutFanInput, FanRelationUncheckedUpdateWithoutFanInput>
  }

  export type FanRelationUpdateManyWithWhereWithoutFanInput = {
    where: FanRelationScalarWhereInput
    data: XOR<FanRelationUpdateManyMutationInput, FanRelationUncheckedUpdateManyWithoutFanInput>
  }

  export type CampaignRecipientUpsertWithWhereUniqueWithoutFanInput = {
    where: CampaignRecipientWhereUniqueInput
    update: XOR<CampaignRecipientUpdateWithoutFanInput, CampaignRecipientUncheckedUpdateWithoutFanInput>
    create: XOR<CampaignRecipientCreateWithoutFanInput, CampaignRecipientUncheckedCreateWithoutFanInput>
  }

  export type CampaignRecipientUpdateWithWhereUniqueWithoutFanInput = {
    where: CampaignRecipientWhereUniqueInput
    data: XOR<CampaignRecipientUpdateWithoutFanInput, CampaignRecipientUncheckedUpdateWithoutFanInput>
  }

  export type CampaignRecipientUpdateManyWithWhereWithoutFanInput = {
    where: CampaignRecipientScalarWhereInput
    data: XOR<CampaignRecipientUpdateManyMutationInput, CampaignRecipientUncheckedUpdateManyWithoutFanInput>
  }

  export type CampaignRecipientScalarWhereInput = {
    AND?: CampaignRecipientScalarWhereInput | CampaignRecipientScalarWhereInput[]
    OR?: CampaignRecipientScalarWhereInput[]
    NOT?: CampaignRecipientScalarWhereInput | CampaignRecipientScalarWhereInput[]
    id?: StringFilter<"CampaignRecipient"> | string
    campaignId?: StringFilter<"CampaignRecipient"> | string
    fanId?: StringFilter<"CampaignRecipient"> | string
    status?: EnumRecipientStatusFilter<"CampaignRecipient"> | $Enums.RecipientStatus
    sentAt?: DateTimeNullableFilter<"CampaignRecipient"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"CampaignRecipient"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"CampaignRecipient"> | Date | string | null
  }

  export type FanCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseCreateNestedManyWithoutFanInput
    transactions?: TransactionCreateNestedManyWithoutFanInput
    fanRelations?: FanRelationCreateNestedManyWithoutFanInput
    campaignRecipients?: CampaignRecipientCreateNestedManyWithoutFanInput
  }

  export type FanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutFanInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFanInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutFanInput
    campaignRecipients?: CampaignRecipientUncheckedCreateNestedManyWithoutFanInput
  }

  export type FanCreateOrConnectWithoutSubscriptionsInput = {
    where: FanWhereUniqueInput
    create: XOR<FanCreateWithoutSubscriptionsInput, FanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type CreatorCreateWithoutSubscribersInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutCreatorInput
    products?: ProductCreateNestedManyWithoutCreatorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    payouts?: PayoutCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutSubscribersInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput
    products?: ProductUncheckedCreateNestedManyWithoutCreatorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutSubscribersInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutSubscribersInput, CreatorUncheckedCreateWithoutSubscribersInput>
  }

  export type SubscriptionPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    interval: $Enums.BillingInterval
    intervalCount?: number
    features: JsonNullValueInput | InputJsonValue
    maxDownloads?: number | null
    earlyAccess?: boolean
    exclusiveContent?: boolean
    trialPeriodDays?: number | null
    stripePriceId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutSubscriptionPlansInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    creatorId: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    interval: $Enums.BillingInterval
    intervalCount?: number
    features: JsonNullValueInput | InputJsonValue
    maxDownloads?: number | null
    earlyAccess?: boolean
    exclusiveContent?: boolean
    trialPeriodDays?: number | null
    stripePriceId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type FanUpsertWithoutSubscriptionsInput = {
    update: XOR<FanUpdateWithoutSubscriptionsInput, FanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<FanCreateWithoutSubscriptionsInput, FanUncheckedCreateWithoutSubscriptionsInput>
    where?: FanWhereInput
  }

  export type FanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: FanWhereInput
    data: XOR<FanUpdateWithoutSubscriptionsInput, FanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type FanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUpdateManyWithoutFanNestedInput
    transactions?: TransactionUpdateManyWithoutFanNestedInput
    fanRelations?: FanRelationUpdateManyWithoutFanNestedInput
    campaignRecipients?: CampaignRecipientUpdateManyWithoutFanNestedInput
  }

  export type FanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutFanNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFanNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutFanNestedInput
    campaignRecipients?: CampaignRecipientUncheckedUpdateManyWithoutFanNestedInput
  }

  export type CreatorUpsertWithoutSubscribersInput = {
    update: XOR<CreatorUpdateWithoutSubscribersInput, CreatorUncheckedUpdateWithoutSubscribersInput>
    create: XOR<CreatorCreateWithoutSubscribersInput, CreatorUncheckedCreateWithoutSubscribersInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutSubscribersInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutSubscribersInput, CreatorUncheckedUpdateWithoutSubscribersInput>
  }

  export type CreatorUpdateWithoutSubscribersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutCreatorNestedInput
    products?: ProductUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutSubscribersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SubscriptionPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    maxDownloads?: NullableIntFieldUpdateOperationsInput | number | null
    earlyAccess?: BoolFieldUpdateOperationsInput | boolean
    exclusiveContent?: BoolFieldUpdateOperationsInput | boolean
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutSubscriptionPlansNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    maxDownloads?: NullableIntFieldUpdateOperationsInput | number | null
    earlyAccess?: BoolFieldUpdateOperationsInput | boolean
    exclusiveContent?: BoolFieldUpdateOperationsInput | boolean
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanCreateWithoutPurchasesInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutFanInput
    transactions?: TransactionCreateNestedManyWithoutFanInput
    fanRelations?: FanRelationCreateNestedManyWithoutFanInput
    campaignRecipients?: CampaignRecipientCreateNestedManyWithoutFanInput
  }

  export type FanUncheckedCreateWithoutPurchasesInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutFanInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFanInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutFanInput
    campaignRecipients?: CampaignRecipientUncheckedCreateNestedManyWithoutFanInput
  }

  export type FanCreateOrConnectWithoutPurchasesInput = {
    where: FanWhereUniqueInput
    create: XOR<FanCreateWithoutPurchasesInput, FanUncheckedCreateWithoutPurchasesInput>
  }

  export type ProductCreateWithoutPurchasesInput = {
    id?: string
    type: $Enums.ProductType
    title: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    contentUrl?: string | null
    thumbnailUrl?: string | null
    previewUrl?: string | null
    accessType: $Enums.ContentAccess
    requiresSubscription?: boolean
    tags?: ProductCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    purchaseCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutPurchasesInput = {
    id?: string
    creatorId: string
    type: $Enums.ProductType
    title: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    contentUrl?: string | null
    thumbnailUrl?: string | null
    previewUrl?: string | null
    accessType: $Enums.ContentAccess
    requiresSubscription?: boolean
    tags?: ProductCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    purchaseCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutPurchasesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
  }

  export type TransactionCreateWithoutPurchaseInput = {
    id?: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    creator: CreatorCreateNestedOneWithoutTransactionsInput
    fan?: FanCreateNestedOneWithoutTransactionsInput
    payout?: PayoutCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutPurchaseInput = {
    id?: string
    creatorId: string
    fanId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    payoutId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutPurchaseInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPurchaseInput, TransactionUncheckedCreateWithoutPurchaseInput>
  }

  export type FanUpsertWithoutPurchasesInput = {
    update: XOR<FanUpdateWithoutPurchasesInput, FanUncheckedUpdateWithoutPurchasesInput>
    create: XOR<FanCreateWithoutPurchasesInput, FanUncheckedCreateWithoutPurchasesInput>
    where?: FanWhereInput
  }

  export type FanUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: FanWhereInput
    data: XOR<FanUpdateWithoutPurchasesInput, FanUncheckedUpdateWithoutPurchasesInput>
  }

  export type FanUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutFanNestedInput
    transactions?: TransactionUpdateManyWithoutFanNestedInput
    fanRelations?: FanRelationUpdateManyWithoutFanNestedInput
    campaignRecipients?: CampaignRecipientUpdateManyWithoutFanNestedInput
  }

  export type FanUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutFanNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFanNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutFanNestedInput
    campaignRecipients?: CampaignRecipientUncheckedUpdateManyWithoutFanNestedInput
  }

  export type ProductUpsertWithoutPurchasesInput = {
    update: XOR<ProductUpdateWithoutPurchasesInput, ProductUncheckedUpdateWithoutPurchasesInput>
    create: XOR<ProductCreateWithoutPurchasesInput, ProductUncheckedCreateWithoutPurchasesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchasesInput, ProductUncheckedUpdateWithoutPurchasesInput>
  }

  export type ProductUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    requiresSubscription?: BoolFieldUpdateOperationsInput | boolean
    tags?: ProductUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    purchaseCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    requiresSubscription?: BoolFieldUpdateOperationsInput | boolean
    tags?: ProductUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    purchaseCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpsertWithoutPurchaseInput = {
    update: XOR<TransactionUpdateWithoutPurchaseInput, TransactionUncheckedUpdateWithoutPurchaseInput>
    create: XOR<TransactionCreateWithoutPurchaseInput, TransactionUncheckedCreateWithoutPurchaseInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutPurchaseInput, TransactionUncheckedUpdateWithoutPurchaseInput>
  }

  export type TransactionUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutTransactionsNestedInput
    fan?: FanUpdateOneWithoutTransactionsNestedInput
    payout?: PayoutUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fanId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutCreatorInput
    products?: ProductCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionCreateNestedManyWithoutCreatorInput
    payouts?: PayoutCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput
    products?: ProductUncheckedCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionUncheckedCreateNestedManyWithoutCreatorInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutTransactionsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutTransactionsInput, CreatorUncheckedCreateWithoutTransactionsInput>
  }

  export type FanCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutFanInput
    purchases?: PurchaseCreateNestedManyWithoutFanInput
    fanRelations?: FanRelationCreateNestedManyWithoutFanInput
    campaignRecipients?: CampaignRecipientCreateNestedManyWithoutFanInput
  }

  export type FanUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutFanInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutFanInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutFanInput
    campaignRecipients?: CampaignRecipientUncheckedCreateNestedManyWithoutFanInput
  }

  export type FanCreateOrConnectWithoutTransactionsInput = {
    where: FanWhereUniqueInput
    create: XOR<FanCreateWithoutTransactionsInput, FanUncheckedCreateWithoutTransactionsInput>
  }

  export type PurchaseCreateWithoutTransactionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId?: string | null
    downloadCount?: number
    lastDownloadAt?: Date | string | null
    createdAt?: Date | string
    fan: FanCreateNestedOneWithoutPurchasesInput
    product: ProductCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutTransactionInput = {
    id?: string
    fanId: string
    productId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId?: string | null
    downloadCount?: number
    lastDownloadAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutTransactionInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutTransactionInput, PurchaseUncheckedCreateWithoutTransactionInput>
  }

  export type PayoutCreateWithoutTransactionsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PayoutStatus
    method: $Enums.PayoutMethod
    destination?: string | null
    stripePayoutId?: string | null
    processedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutPayoutsInput
  }

  export type PayoutUncheckedCreateWithoutTransactionsInput = {
    id?: string
    creatorId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PayoutStatus
    method: $Enums.PayoutMethod
    destination?: string | null
    stripePayoutId?: string | null
    processedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayoutCreateOrConnectWithoutTransactionsInput = {
    where: PayoutWhereUniqueInput
    create: XOR<PayoutCreateWithoutTransactionsInput, PayoutUncheckedCreateWithoutTransactionsInput>
  }

  export type CreatorUpsertWithoutTransactionsInput = {
    update: XOR<CreatorUpdateWithoutTransactionsInput, CreatorUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CreatorCreateWithoutTransactionsInput, CreatorUncheckedCreateWithoutTransactionsInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutTransactionsInput, CreatorUncheckedUpdateWithoutTransactionsInput>
  }

  export type CreatorUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutCreatorNestedInput
    products?: ProductUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type FanUpsertWithoutTransactionsInput = {
    update: XOR<FanUpdateWithoutTransactionsInput, FanUncheckedUpdateWithoutTransactionsInput>
    create: XOR<FanCreateWithoutTransactionsInput, FanUncheckedCreateWithoutTransactionsInput>
    where?: FanWhereInput
  }

  export type FanUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: FanWhereInput
    data: XOR<FanUpdateWithoutTransactionsInput, FanUncheckedUpdateWithoutTransactionsInput>
  }

  export type FanUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutFanNestedInput
    purchases?: PurchaseUpdateManyWithoutFanNestedInput
    fanRelations?: FanRelationUpdateManyWithoutFanNestedInput
    campaignRecipients?: CampaignRecipientUpdateManyWithoutFanNestedInput
  }

  export type FanUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutFanNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutFanNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutFanNestedInput
    campaignRecipients?: CampaignRecipientUncheckedUpdateManyWithoutFanNestedInput
  }

  export type PurchaseUpsertWithoutTransactionInput = {
    update: XOR<PurchaseUpdateWithoutTransactionInput, PurchaseUncheckedUpdateWithoutTransactionInput>
    create: XOR<PurchaseCreateWithoutTransactionInput, PurchaseUncheckedCreateWithoutTransactionInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutTransactionInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutTransactionInput, PurchaseUncheckedUpdateWithoutTransactionInput>
  }

  export type PurchaseUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fan?: FanUpdateOneRequiredWithoutPurchasesNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutUpsertWithoutTransactionsInput = {
    update: XOR<PayoutUpdateWithoutTransactionsInput, PayoutUncheckedUpdateWithoutTransactionsInput>
    create: XOR<PayoutCreateWithoutTransactionsInput, PayoutUncheckedCreateWithoutTransactionsInput>
    where?: PayoutWhereInput
  }

  export type PayoutUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: PayoutWhereInput
    data: XOR<PayoutUpdateWithoutTransactionsInput, PayoutUncheckedUpdateWithoutTransactionsInput>
  }

  export type PayoutUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    stripePayoutId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutPayoutsNestedInput
  }

  export type PayoutUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    stripePayoutId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorCreateWithoutPayoutsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutCreatorInput
    products?: ProductCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionCreateNestedManyWithoutCreatorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutPayoutsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput
    products?: ProductUncheckedCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionUncheckedCreateNestedManyWithoutCreatorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutPayoutsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutPayoutsInput, CreatorUncheckedCreateWithoutPayoutsInput>
  }

  export type TransactionCreateWithoutPayoutInput = {
    id?: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    creator: CreatorCreateNestedOneWithoutTransactionsInput
    fan?: FanCreateNestedOneWithoutTransactionsInput
    purchase?: PurchaseCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPayoutInput = {
    id?: string
    creatorId: string
    fanId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    purchaseId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutPayoutInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPayoutInput, TransactionUncheckedCreateWithoutPayoutInput>
  }

  export type TransactionCreateManyPayoutInputEnvelope = {
    data: TransactionCreateManyPayoutInput | TransactionCreateManyPayoutInput[]
    skipDuplicates?: boolean
  }

  export type CreatorUpsertWithoutPayoutsInput = {
    update: XOR<CreatorUpdateWithoutPayoutsInput, CreatorUncheckedUpdateWithoutPayoutsInput>
    create: XOR<CreatorCreateWithoutPayoutsInput, CreatorUncheckedCreateWithoutPayoutsInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutPayoutsInput, CreatorUncheckedUpdateWithoutPayoutsInput>
  }

  export type CreatorUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutCreatorNestedInput
    products?: ProductUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutPayoutInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutPayoutInput, TransactionUncheckedUpdateWithoutPayoutInput>
    create: XOR<TransactionCreateWithoutPayoutInput, TransactionUncheckedCreateWithoutPayoutInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutPayoutInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutPayoutInput, TransactionUncheckedUpdateWithoutPayoutInput>
  }

  export type TransactionUpdateManyWithWhereWithoutPayoutInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutPayoutInput>
  }

  export type CreatorCreateWithoutAnalyticsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutCreatorInput
    products?: ProductCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionCreateNestedManyWithoutCreatorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    payouts?: PayoutCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput
    products?: ProductUncheckedCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionUncheckedCreateNestedManyWithoutCreatorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutAnalyticsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutAnalyticsInput, CreatorUncheckedCreateWithoutAnalyticsInput>
  }

  export type CreatorUpsertWithoutAnalyticsInput = {
    update: XOR<CreatorUpdateWithoutAnalyticsInput, CreatorUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<CreatorCreateWithoutAnalyticsInput, CreatorUncheckedCreateWithoutAnalyticsInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutAnalyticsInput, CreatorUncheckedUpdateWithoutAnalyticsInput>
  }

  export type CreatorUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutCreatorNestedInput
    products?: ProductUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorCreateWithoutFanRelationsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutCreatorInput
    products?: ProductCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionCreateNestedManyWithoutCreatorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    payouts?: PayoutCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsCreateNestedOneWithoutCreatorInput
    campaigns?: CampaignCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutFanRelationsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput
    products?: ProductUncheckedCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionUncheckedCreateNestedManyWithoutCreatorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutFanRelationsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutFanRelationsInput, CreatorUncheckedCreateWithoutFanRelationsInput>
  }

  export type FanCreateWithoutFanRelationsInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutFanInput
    purchases?: PurchaseCreateNestedManyWithoutFanInput
    transactions?: TransactionCreateNestedManyWithoutFanInput
    campaignRecipients?: CampaignRecipientCreateNestedManyWithoutFanInput
  }

  export type FanUncheckedCreateWithoutFanRelationsInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutFanInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutFanInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFanInput
    campaignRecipients?: CampaignRecipientUncheckedCreateNestedManyWithoutFanInput
  }

  export type FanCreateOrConnectWithoutFanRelationsInput = {
    where: FanWhereUniqueInput
    create: XOR<FanCreateWithoutFanRelationsInput, FanUncheckedCreateWithoutFanRelationsInput>
  }

  export type CreatorUpsertWithoutFanRelationsInput = {
    update: XOR<CreatorUpdateWithoutFanRelationsInput, CreatorUncheckedUpdateWithoutFanRelationsInput>
    create: XOR<CreatorCreateWithoutFanRelationsInput, CreatorUncheckedCreateWithoutFanRelationsInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutFanRelationsInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutFanRelationsInput, CreatorUncheckedUpdateWithoutFanRelationsInput>
  }

  export type CreatorUpdateWithoutFanRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutCreatorNestedInput
    products?: ProductUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUpdateOneWithoutCreatorNestedInput
    campaigns?: CampaignUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutFanRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type FanUpsertWithoutFanRelationsInput = {
    update: XOR<FanUpdateWithoutFanRelationsInput, FanUncheckedUpdateWithoutFanRelationsInput>
    create: XOR<FanCreateWithoutFanRelationsInput, FanUncheckedCreateWithoutFanRelationsInput>
    where?: FanWhereInput
  }

  export type FanUpdateToOneWithWhereWithoutFanRelationsInput = {
    where?: FanWhereInput
    data: XOR<FanUpdateWithoutFanRelationsInput, FanUncheckedUpdateWithoutFanRelationsInput>
  }

  export type FanUpdateWithoutFanRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutFanNestedInput
    purchases?: PurchaseUpdateManyWithoutFanNestedInput
    transactions?: TransactionUpdateManyWithoutFanNestedInput
    campaignRecipients?: CampaignRecipientUpdateManyWithoutFanNestedInput
  }

  export type FanUncheckedUpdateWithoutFanRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutFanNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutFanNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFanNestedInput
    campaignRecipients?: CampaignRecipientUncheckedUpdateManyWithoutFanNestedInput
  }

  export type CreatorCreateWithoutCampaignsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutCreatorInput
    products?: ProductCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionCreateNestedManyWithoutCreatorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    payouts?: PayoutCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutCampaignsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput
    products?: ProductUncheckedCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionUncheckedCreateNestedManyWithoutCreatorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutCampaignsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutCampaignsInput, CreatorUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignRecipientCreateWithoutCampaignInput = {
    id?: string
    status: $Enums.RecipientStatus
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
    fan: FanCreateNestedOneWithoutCampaignRecipientsInput
  }

  export type CampaignRecipientUncheckedCreateWithoutCampaignInput = {
    id?: string
    fanId: string
    status: $Enums.RecipientStatus
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
  }

  export type CampaignRecipientCreateOrConnectWithoutCampaignInput = {
    where: CampaignRecipientWhereUniqueInput
    create: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignRecipientCreateManyCampaignInputEnvelope = {
    data: CampaignRecipientCreateManyCampaignInput | CampaignRecipientCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CreatorUpsertWithoutCampaignsInput = {
    update: XOR<CreatorUpdateWithoutCampaignsInput, CreatorUncheckedUpdateWithoutCampaignsInput>
    create: XOR<CreatorCreateWithoutCampaignsInput, CreatorUncheckedCreateWithoutCampaignsInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutCampaignsInput, CreatorUncheckedUpdateWithoutCampaignsInput>
  }

  export type CreatorUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutCreatorNestedInput
    products?: ProductUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CampaignRecipientUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignRecipientWhereUniqueInput
    update: XOR<CampaignRecipientUpdateWithoutCampaignInput, CampaignRecipientUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignRecipientUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignRecipientWhereUniqueInput
    data: XOR<CampaignRecipientUpdateWithoutCampaignInput, CampaignRecipientUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignRecipientUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignRecipientScalarWhereInput
    data: XOR<CampaignRecipientUpdateManyMutationInput, CampaignRecipientUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignCreateWithoutRecipientsInput = {
    id?: string
    name: string
    type: $Enums.CampaignType
    status: $Enums.CampaignStatus
    subject?: string | null
    content: string
    targetTags?: CampaignCreatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: CreatorCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutRecipientsInput = {
    id?: string
    creatorId: string
    name: string
    type: $Enums.CampaignType
    status: $Enums.CampaignStatus
    subject?: string | null
    content: string
    targetTags?: CampaignCreatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateOrConnectWithoutRecipientsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutRecipientsInput, CampaignUncheckedCreateWithoutRecipientsInput>
  }

  export type FanCreateWithoutCampaignRecipientsInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutFanInput
    purchases?: PurchaseCreateNestedManyWithoutFanInput
    transactions?: TransactionCreateNestedManyWithoutFanInput
    fanRelations?: FanRelationCreateNestedManyWithoutFanInput
  }

  export type FanUncheckedCreateWithoutCampaignRecipientsInput = {
    id?: string
    email: string
    username?: string | null
    displayName?: string | null
    avatar?: string | null
    stripeCustomerId?: string | null
    emailVerified?: boolean
    phoneNumber?: string | null
    phoneVerified?: boolean
    locale?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutFanInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutFanInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutFanInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutFanInput
  }

  export type FanCreateOrConnectWithoutCampaignRecipientsInput = {
    where: FanWhereUniqueInput
    create: XOR<FanCreateWithoutCampaignRecipientsInput, FanUncheckedCreateWithoutCampaignRecipientsInput>
  }

  export type CampaignUpsertWithoutRecipientsInput = {
    update: XOR<CampaignUpdateWithoutRecipientsInput, CampaignUncheckedUpdateWithoutRecipientsInput>
    create: XOR<CampaignCreateWithoutRecipientsInput, CampaignUncheckedCreateWithoutRecipientsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutRecipientsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutRecipientsInput, CampaignUncheckedUpdateWithoutRecipientsInput>
  }

  export type CampaignUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    targetTags?: CampaignUpdatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    targetTags?: CampaignUpdatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanUpsertWithoutCampaignRecipientsInput = {
    update: XOR<FanUpdateWithoutCampaignRecipientsInput, FanUncheckedUpdateWithoutCampaignRecipientsInput>
    create: XOR<FanCreateWithoutCampaignRecipientsInput, FanUncheckedCreateWithoutCampaignRecipientsInput>
    where?: FanWhereInput
  }

  export type FanUpdateToOneWithWhereWithoutCampaignRecipientsInput = {
    where?: FanWhereInput
    data: XOR<FanUpdateWithoutCampaignRecipientsInput, FanUncheckedUpdateWithoutCampaignRecipientsInput>
  }

  export type FanUpdateWithoutCampaignRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutFanNestedInput
    purchases?: PurchaseUpdateManyWithoutFanNestedInput
    transactions?: TransactionUpdateManyWithoutFanNestedInput
    fanRelations?: FanRelationUpdateManyWithoutFanNestedInput
  }

  export type FanUncheckedUpdateWithoutCampaignRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutFanNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutFanNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutFanNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutFanNestedInput
  }

  export type InstalledAppCreateWithoutAppInput = {
    id?: string
    status: $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: $Enums.BillingInterval | null
    nextBilling?: Date | string | null
    installedAt?: Date | string
    uninstalledAt?: Date | string | null
    creator: CreatorCreateNestedOneWithoutInstalledAppsInput
  }

  export type InstalledAppUncheckedCreateWithoutAppInput = {
    id?: string
    creatorId: string
    status: $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: $Enums.BillingInterval | null
    nextBilling?: Date | string | null
    installedAt?: Date | string
    uninstalledAt?: Date | string | null
  }

  export type InstalledAppCreateOrConnectWithoutAppInput = {
    where: InstalledAppWhereUniqueInput
    create: XOR<InstalledAppCreateWithoutAppInput, InstalledAppUncheckedCreateWithoutAppInput>
  }

  export type InstalledAppCreateManyAppInputEnvelope = {
    data: InstalledAppCreateManyAppInput | InstalledAppCreateManyAppInput[]
    skipDuplicates?: boolean
  }

  export type InstalledAppUpsertWithWhereUniqueWithoutAppInput = {
    where: InstalledAppWhereUniqueInput
    update: XOR<InstalledAppUpdateWithoutAppInput, InstalledAppUncheckedUpdateWithoutAppInput>
    create: XOR<InstalledAppCreateWithoutAppInput, InstalledAppUncheckedCreateWithoutAppInput>
  }

  export type InstalledAppUpdateWithWhereUniqueWithoutAppInput = {
    where: InstalledAppWhereUniqueInput
    data: XOR<InstalledAppUpdateWithoutAppInput, InstalledAppUncheckedUpdateWithoutAppInput>
  }

  export type InstalledAppUpdateManyWithWhereWithoutAppInput = {
    where: InstalledAppScalarWhereInput
    data: XOR<InstalledAppUpdateManyMutationInput, InstalledAppUncheckedUpdateManyWithoutAppInput>
  }

  export type CreatorCreateWithoutInstalledAppsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutCreatorInput
    products?: ProductCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionCreateNestedManyWithoutCreatorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    payouts?: PayoutCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutInstalledAppsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput
    products?: ProductUncheckedCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionUncheckedCreateNestedManyWithoutCreatorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutInstalledAppsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutInstalledAppsInput, CreatorUncheckedCreateWithoutInstalledAppsInput>
  }

  export type AppCreateWithoutInstallationsInput = {
    id?: string
    name: string
    slug: string
    description: string
    icon?: string | null
    developer: string
    website?: string | null
    category: $Enums.AppCategory
    pricing: $Enums.AppPricing
    price?: Decimal | DecimalJsLike | number | string | null
    webhookUrl?: string | null
    scopes?: AppCreatescopesInput | string[]
    isPublished?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppUncheckedCreateWithoutInstallationsInput = {
    id?: string
    name: string
    slug: string
    description: string
    icon?: string | null
    developer: string
    website?: string | null
    category: $Enums.AppCategory
    pricing: $Enums.AppPricing
    price?: Decimal | DecimalJsLike | number | string | null
    webhookUrl?: string | null
    scopes?: AppCreatescopesInput | string[]
    isPublished?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppCreateOrConnectWithoutInstallationsInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutInstallationsInput, AppUncheckedCreateWithoutInstallationsInput>
  }

  export type CreatorUpsertWithoutInstalledAppsInput = {
    update: XOR<CreatorUpdateWithoutInstalledAppsInput, CreatorUncheckedUpdateWithoutInstalledAppsInput>
    create: XOR<CreatorCreateWithoutInstalledAppsInput, CreatorUncheckedCreateWithoutInstalledAppsInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutInstalledAppsInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutInstalledAppsInput, CreatorUncheckedUpdateWithoutInstalledAppsInput>
  }

  export type CreatorUpdateWithoutInstalledAppsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutCreatorNestedInput
    products?: ProductUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutInstalledAppsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AppUpsertWithoutInstallationsInput = {
    update: XOR<AppUpdateWithoutInstallationsInput, AppUncheckedUpdateWithoutInstallationsInput>
    create: XOR<AppCreateWithoutInstallationsInput, AppUncheckedCreateWithoutInstallationsInput>
    where?: AppWhereInput
  }

  export type AppUpdateToOneWithWhereWithoutInstallationsInput = {
    where?: AppWhereInput
    data: XOR<AppUpdateWithoutInstallationsInput, AppUncheckedUpdateWithoutInstallationsInput>
  }

  export type AppUpdateWithoutInstallationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAppCategoryFieldUpdateOperationsInput | $Enums.AppCategory
    pricing?: EnumAppPricingFieldUpdateOperationsInput | $Enums.AppPricing
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AppUpdatescopesInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppUncheckedUpdateWithoutInstallationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAppCategoryFieldUpdateOperationsInput | $Enums.AppCategory
    pricing?: EnumAppPricingFieldUpdateOperationsInput | $Enums.AppPricing
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AppUpdatescopesInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutCreatorInput
    products?: ProductCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionCreateNestedManyWithoutCreatorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    payouts?: PayoutCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    displayName: string
    bio?: string | null
    avatar?: string | null
    stripeAccountId?: string | null
    stripeCustomerId?: string | null
    stripeConnected?: boolean
    kycStatus?: $Enums.KycStatus
    commissionTier?: $Enums.CommissionTier
    totalRevenue?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    locale?: string
    timezone?: string
    onboardingCompleted?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    phoneNumber?: string | null
    smsOptIn?: boolean
    currentPlan?: string
    accountStatus?: $Enums.AccountStatus
    planDowngradedAt?: Date | string | null
    planDowngradeReason?: string | null
    suspendedAt?: Date | string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutCreatorInput
    products?: ProductUncheckedCreateNestedManyWithoutCreatorInput
    subscribers?: SubscriptionUncheckedCreateNestedManyWithoutCreatorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutCreatorInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreatorInput
    installedApps?: InstalledAppUncheckedCreateNestedManyWithoutCreatorInput
    settings?: CreatorSettingsUncheckedCreateNestedOneWithoutCreatorInput
    fanRelations?: FanRelationUncheckedCreateNestedManyWithoutCreatorInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutAuditLogsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutAuditLogsInput, CreatorUncheckedCreateWithoutAuditLogsInput>
  }

  export type CreatorUpsertWithoutAuditLogsInput = {
    update: XOR<CreatorUpdateWithoutAuditLogsInput, CreatorUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<CreatorCreateWithoutAuditLogsInput, CreatorUncheckedCreateWithoutAuditLogsInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutAuditLogsInput, CreatorUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CreatorUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutCreatorNestedInput
    products?: ProductUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnected?: BoolFieldUpdateOperationsInput | boolean
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    commissionTier?: EnumCommissionTierFieldUpdateOperationsInput | $Enums.CommissionTier
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    currentPlan?: StringFieldUpdateOperationsInput | string
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    planDowngradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planDowngradeReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutCreatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutCreatorNestedInput
    subscribers?: SubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutCreatorNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutCreatorNestedInput
    installedApps?: InstalledAppUncheckedUpdateManyWithoutCreatorNestedInput
    settings?: CreatorSettingsUncheckedUpdateOneWithoutCreatorNestedInput
    fanRelations?: FanRelationUncheckedUpdateManyWithoutCreatorNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type LedgerEntryCreateWithoutAccountInput = {
    id?: string
    direction: $Enums.LedgerDirection
    amountCents: bigint | number
    currency: string
    createdAt?: Date | string
    transaction: LedgerTransactionCreateNestedOneWithoutEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutAccountInput = {
    id?: string
    txId: string
    direction: $Enums.LedgerDirection
    amountCents: bigint | number
    currency: string
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutAccountInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput>
  }

  export type LedgerEntryCreateManyAccountInputEnvelope = {
    data: LedgerEntryCreateManyAccountInput | LedgerEntryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutAccountInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutAccountInput, LedgerEntryUncheckedUpdateWithoutAccountInput>
    create: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutAccountInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutAccountInput, LedgerEntryUncheckedUpdateWithoutAccountInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutAccountInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutAccountInput>
  }

  export type LedgerEntryScalarWhereInput = {
    AND?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    OR?: LedgerEntryScalarWhereInput[]
    NOT?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    id?: StringFilter<"LedgerEntry"> | string
    txId?: StringFilter<"LedgerEntry"> | string
    accountId?: StringFilter<"LedgerEntry"> | string
    direction?: EnumLedgerDirectionFilter<"LedgerEntry"> | $Enums.LedgerDirection
    amountCents?: BigIntFilter<"LedgerEntry"> | bigint | number
    currency?: StringFilter<"LedgerEntry"> | string
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
  }

  export type LedgerEntryCreateWithoutTransactionInput = {
    id?: string
    direction: $Enums.LedgerDirection
    amountCents: bigint | number
    currency: string
    createdAt?: Date | string
    account: LedgerAccountCreateNestedOneWithoutEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutTransactionInput = {
    id?: string
    accountId: string
    direction: $Enums.LedgerDirection
    amountCents: bigint | number
    currency: string
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput>
  }

  export type LedgerEntryCreateManyTransactionInputEnvelope = {
    data: LedgerEntryCreateManyTransactionInput | LedgerEntryCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutTransactionInput, LedgerEntryUncheckedUpdateWithoutTransactionInput>
    create: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutTransactionInput, LedgerEntryUncheckedUpdateWithoutTransactionInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutTransactionInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutTransactionInput>
  }

  export type LedgerTransactionCreateWithoutEntriesInput = {
    id?: string
    tenantId?: string
    kind: $Enums.LedgerTransactionKind
    currency: string
    occurredAt: Date | string
    memo?: string | null
    source?: string | null
    extRef?: string | null
    stripeEventId?: string | null
    idempotencyKey?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
  }

  export type LedgerTransactionUncheckedCreateWithoutEntriesInput = {
    id?: string
    tenantId?: string
    kind: $Enums.LedgerTransactionKind
    currency: string
    occurredAt: Date | string
    memo?: string | null
    source?: string | null
    extRef?: string | null
    stripeEventId?: string | null
    idempotencyKey?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
  }

  export type LedgerTransactionCreateOrConnectWithoutEntriesInput = {
    where: LedgerTransactionWhereUniqueInput
    create: XOR<LedgerTransactionCreateWithoutEntriesInput, LedgerTransactionUncheckedCreateWithoutEntriesInput>
  }

  export type LedgerAccountCreateWithoutEntriesInput = {
    id?: string
    tenantId?: string
    type: $Enums.LedgerAccountType
    currency: string
    ownerId?: string | null
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerAccountUncheckedCreateWithoutEntriesInput = {
    id?: string
    tenantId?: string
    type: $Enums.LedgerAccountType
    currency: string
    ownerId?: string | null
    balance?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerAccountCreateOrConnectWithoutEntriesInput = {
    where: LedgerAccountWhereUniqueInput
    create: XOR<LedgerAccountCreateWithoutEntriesInput, LedgerAccountUncheckedCreateWithoutEntriesInput>
  }

  export type LedgerTransactionUpsertWithoutEntriesInput = {
    update: XOR<LedgerTransactionUpdateWithoutEntriesInput, LedgerTransactionUncheckedUpdateWithoutEntriesInput>
    create: XOR<LedgerTransactionCreateWithoutEntriesInput, LedgerTransactionUncheckedCreateWithoutEntriesInput>
    where?: LedgerTransactionWhereInput
  }

  export type LedgerTransactionUpdateToOneWithWhereWithoutEntriesInput = {
    where?: LedgerTransactionWhereInput
    data: XOR<LedgerTransactionUpdateWithoutEntriesInput, LedgerTransactionUncheckedUpdateWithoutEntriesInput>
  }

  export type LedgerTransactionUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLedgerTransactionKindFieldUpdateOperationsInput | $Enums.LedgerTransactionKind
    currency?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEventId?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerTransactionUncheckedUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLedgerTransactionKindFieldUpdateOperationsInput | $Enums.LedgerTransactionKind
    currency?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEventId?: NullableStringFieldUpdateOperationsInput | string | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerAccountUpsertWithoutEntriesInput = {
    update: XOR<LedgerAccountUpdateWithoutEntriesInput, LedgerAccountUncheckedUpdateWithoutEntriesInput>
    create: XOR<LedgerAccountCreateWithoutEntriesInput, LedgerAccountUncheckedCreateWithoutEntriesInput>
    where?: LedgerAccountWhereInput
  }

  export type LedgerAccountUpdateToOneWithWhereWithoutEntriesInput = {
    where?: LedgerAccountWhereInput
    data: XOR<LedgerAccountUpdateWithoutEntriesInput, LedgerAccountUncheckedUpdateWithoutEntriesInput>
  }

  export type LedgerAccountUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerAccountTypeFieldUpdateOperationsInput | $Enums.LedgerAccountType
    currency?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerAccountUncheckedUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerAccountTypeFieldUpdateOperationsInput | $Enums.LedgerAccountType
    currency?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalEarningsImportCreateWithoutSourceInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    rawHash: string
    rawJson: JsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type ExternalEarningsImportUncheckedCreateWithoutSourceInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    rawHash: string
    rawJson: JsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type ExternalEarningsImportCreateOrConnectWithoutSourceInput = {
    where: ExternalEarningsImportWhereUniqueInput
    create: XOR<ExternalEarningsImportCreateWithoutSourceInput, ExternalEarningsImportUncheckedCreateWithoutSourceInput>
  }

  export type ExternalEarningsImportCreateManySourceInputEnvelope = {
    data: ExternalEarningsImportCreateManySourceInput | ExternalEarningsImportCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type NormalizedEarningCreateWithoutSourceInput = {
    id?: string
    occurredAt: Date | string
    currency: string
    grossCents: bigint | number
    feesCents: bigint | number
    netCents: bigint | number
    payoutId?: string | null
    extRef?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NormalizedEarningUncheckedCreateWithoutSourceInput = {
    id?: string
    occurredAt: Date | string
    currency: string
    grossCents: bigint | number
    feesCents: bigint | number
    netCents: bigint | number
    payoutId?: string | null
    extRef?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NormalizedEarningCreateOrConnectWithoutSourceInput = {
    where: NormalizedEarningWhereUniqueInput
    create: XOR<NormalizedEarningCreateWithoutSourceInput, NormalizedEarningUncheckedCreateWithoutSourceInput>
  }

  export type NormalizedEarningCreateManySourceInputEnvelope = {
    data: NormalizedEarningCreateManySourceInput | NormalizedEarningCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type ExternalEarningsImportUpsertWithWhereUniqueWithoutSourceInput = {
    where: ExternalEarningsImportWhereUniqueInput
    update: XOR<ExternalEarningsImportUpdateWithoutSourceInput, ExternalEarningsImportUncheckedUpdateWithoutSourceInput>
    create: XOR<ExternalEarningsImportCreateWithoutSourceInput, ExternalEarningsImportUncheckedCreateWithoutSourceInput>
  }

  export type ExternalEarningsImportUpdateWithWhereUniqueWithoutSourceInput = {
    where: ExternalEarningsImportWhereUniqueInput
    data: XOR<ExternalEarningsImportUpdateWithoutSourceInput, ExternalEarningsImportUncheckedUpdateWithoutSourceInput>
  }

  export type ExternalEarningsImportUpdateManyWithWhereWithoutSourceInput = {
    where: ExternalEarningsImportScalarWhereInput
    data: XOR<ExternalEarningsImportUpdateManyMutationInput, ExternalEarningsImportUncheckedUpdateManyWithoutSourceInput>
  }

  export type ExternalEarningsImportScalarWhereInput = {
    AND?: ExternalEarningsImportScalarWhereInput | ExternalEarningsImportScalarWhereInput[]
    OR?: ExternalEarningsImportScalarWhereInput[]
    NOT?: ExternalEarningsImportScalarWhereInput | ExternalEarningsImportScalarWhereInput[]
    id?: StringFilter<"ExternalEarningsImport"> | string
    sourceId?: StringFilter<"ExternalEarningsImport"> | string
    periodStart?: DateTimeFilter<"ExternalEarningsImport"> | Date | string
    periodEnd?: DateTimeFilter<"ExternalEarningsImport"> | Date | string
    rawHash?: StringFilter<"ExternalEarningsImport"> | string
    rawJson?: JsonFilter<"ExternalEarningsImport">
    processedAt?: DateTimeNullableFilter<"ExternalEarningsImport"> | Date | string | null
    errorMessage?: StringNullableFilter<"ExternalEarningsImport"> | string | null
    createdAt?: DateTimeFilter<"ExternalEarningsImport"> | Date | string
  }

  export type NormalizedEarningUpsertWithWhereUniqueWithoutSourceInput = {
    where: NormalizedEarningWhereUniqueInput
    update: XOR<NormalizedEarningUpdateWithoutSourceInput, NormalizedEarningUncheckedUpdateWithoutSourceInput>
    create: XOR<NormalizedEarningCreateWithoutSourceInput, NormalizedEarningUncheckedCreateWithoutSourceInput>
  }

  export type NormalizedEarningUpdateWithWhereUniqueWithoutSourceInput = {
    where: NormalizedEarningWhereUniqueInput
    data: XOR<NormalizedEarningUpdateWithoutSourceInput, NormalizedEarningUncheckedUpdateWithoutSourceInput>
  }

  export type NormalizedEarningUpdateManyWithWhereWithoutSourceInput = {
    where: NormalizedEarningScalarWhereInput
    data: XOR<NormalizedEarningUpdateManyMutationInput, NormalizedEarningUncheckedUpdateManyWithoutSourceInput>
  }

  export type NormalizedEarningScalarWhereInput = {
    AND?: NormalizedEarningScalarWhereInput | NormalizedEarningScalarWhereInput[]
    OR?: NormalizedEarningScalarWhereInput[]
    NOT?: NormalizedEarningScalarWhereInput | NormalizedEarningScalarWhereInput[]
    id?: StringFilter<"NormalizedEarning"> | string
    sourceId?: StringFilter<"NormalizedEarning"> | string
    occurredAt?: DateTimeFilter<"NormalizedEarning"> | Date | string
    currency?: StringFilter<"NormalizedEarning"> | string
    grossCents?: BigIntFilter<"NormalizedEarning"> | bigint | number
    feesCents?: BigIntFilter<"NormalizedEarning"> | bigint | number
    netCents?: BigIntFilter<"NormalizedEarning"> | bigint | number
    payoutId?: StringNullableFilter<"NormalizedEarning"> | string | null
    extRef?: StringNullableFilter<"NormalizedEarning"> | string | null
    metadata?: JsonNullableFilter<"NormalizedEarning">
    createdAt?: DateTimeFilter<"NormalizedEarning"> | Date | string
  }

  export type ExternalEarningsSourceCreateWithoutImportsInput = {
    id?: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    externalHandle: string
    currency: string
    connectedAt?: Date | string
    active?: boolean
    lastSync?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    earnings?: NormalizedEarningCreateNestedManyWithoutSourceInput
  }

  export type ExternalEarningsSourceUncheckedCreateWithoutImportsInput = {
    id?: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    externalHandle: string
    currency: string
    connectedAt?: Date | string
    active?: boolean
    lastSync?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    earnings?: NormalizedEarningUncheckedCreateNestedManyWithoutSourceInput
  }

  export type ExternalEarningsSourceCreateOrConnectWithoutImportsInput = {
    where: ExternalEarningsSourceWhereUniqueInput
    create: XOR<ExternalEarningsSourceCreateWithoutImportsInput, ExternalEarningsSourceUncheckedCreateWithoutImportsInput>
  }

  export type ExternalEarningsSourceUpsertWithoutImportsInput = {
    update: XOR<ExternalEarningsSourceUpdateWithoutImportsInput, ExternalEarningsSourceUncheckedUpdateWithoutImportsInput>
    create: XOR<ExternalEarningsSourceCreateWithoutImportsInput, ExternalEarningsSourceUncheckedCreateWithoutImportsInput>
    where?: ExternalEarningsSourceWhereInput
  }

  export type ExternalEarningsSourceUpdateToOneWithWhereWithoutImportsInput = {
    where?: ExternalEarningsSourceWhereInput
    data: XOR<ExternalEarningsSourceUpdateWithoutImportsInput, ExternalEarningsSourceUncheckedUpdateWithoutImportsInput>
  }

  export type ExternalEarningsSourceUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    externalHandle?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    earnings?: NormalizedEarningUpdateManyWithoutSourceNestedInput
  }

  export type ExternalEarningsSourceUncheckedUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    externalHandle?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    earnings?: NormalizedEarningUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type ExternalEarningsSourceCreateWithoutEarningsInput = {
    id?: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    externalHandle: string
    currency: string
    connectedAt?: Date | string
    active?: boolean
    lastSync?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imports?: ExternalEarningsImportCreateNestedManyWithoutSourceInput
  }

  export type ExternalEarningsSourceUncheckedCreateWithoutEarningsInput = {
    id?: string
    creatorId: string
    platform: $Enums.ExternalPlatform
    externalHandle: string
    currency: string
    connectedAt?: Date | string
    active?: boolean
    lastSync?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imports?: ExternalEarningsImportUncheckedCreateNestedManyWithoutSourceInput
  }

  export type ExternalEarningsSourceCreateOrConnectWithoutEarningsInput = {
    where: ExternalEarningsSourceWhereUniqueInput
    create: XOR<ExternalEarningsSourceCreateWithoutEarningsInput, ExternalEarningsSourceUncheckedCreateWithoutEarningsInput>
  }

  export type ExternalEarningsSourceUpsertWithoutEarningsInput = {
    update: XOR<ExternalEarningsSourceUpdateWithoutEarningsInput, ExternalEarningsSourceUncheckedUpdateWithoutEarningsInput>
    create: XOR<ExternalEarningsSourceCreateWithoutEarningsInput, ExternalEarningsSourceUncheckedCreateWithoutEarningsInput>
    where?: ExternalEarningsSourceWhereInput
  }

  export type ExternalEarningsSourceUpdateToOneWithWhereWithoutEarningsInput = {
    where?: ExternalEarningsSourceWhereInput
    data: XOR<ExternalEarningsSourceUpdateWithoutEarningsInput, ExternalEarningsSourceUncheckedUpdateWithoutEarningsInput>
  }

  export type ExternalEarningsSourceUpdateWithoutEarningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    externalHandle?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imports?: ExternalEarningsImportUpdateManyWithoutSourceNestedInput
  }

  export type ExternalEarningsSourceUncheckedUpdateWithoutEarningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    platform?: EnumExternalPlatformFieldUpdateOperationsInput | $Enums.ExternalPlatform
    externalHandle?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    connectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imports?: ExternalEarningsImportUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type SubscriptionPlanCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    interval: $Enums.BillingInterval
    intervalCount?: number
    features: JsonNullValueInput | InputJsonValue
    maxDownloads?: number | null
    earlyAccess?: boolean
    exclusiveContent?: boolean
    trialPeriodDays?: number | null
    stripePriceId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyCreatorInput = {
    id?: string
    type: $Enums.ProductType
    title: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    contentUrl?: string | null
    thumbnailUrl?: string | null
    previewUrl?: string | null
    accessType: $Enums.ContentAccess
    requiresSubscription?: boolean
    tags?: ProductCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    purchaseCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyCreatorInput = {
    id?: string
    fanId: string
    planId: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyCreatorInput = {
    id?: string
    fanId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    purchaseId?: string | null
    payoutId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PayoutCreateManyCreatorInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PayoutStatus
    method: $Enums.PayoutMethod
    destination?: string | null
    stripePayoutId?: string | null
    processedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsCreateManyCreatorInput = {
    id?: string
    date: Date | string
    revenue?: Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: Decimal | DecimalJsLike | number | string
    productRevenue?: Decimal | DecimalJsLike | number | string
    newSubscribers?: number
    churned?: number
    activeSubscribers?: number
    pageViews?: number
    uniqueVisitors?: number
    contentViews?: number
    conversionRate?: Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type InstalledAppCreateManyCreatorInput = {
    id?: string
    appId: string
    status: $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: $Enums.BillingInterval | null
    nextBilling?: Date | string | null
    installedAt?: Date | string
    uninstalledAt?: Date | string | null
  }

  export type AuditLogCreateManyCreatorInput = {
    id?: string
    actorId: string
    actorType: $Enums.ActorType
    action: string
    resource: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FanRelationCreateManyCreatorInput = {
    id?: string
    fanId: string
    tags?: FanRelationCreatetagsInput | string[]
    notes?: string | null
    engagementScore?: number
    lifetimeValue?: Decimal | DecimalJsLike | number | string
    lastInteraction?: Date | string | null
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateManyCreatorInput = {
    id?: string
    name: string
    type: $Enums.CampaignType
    status: $Enums.CampaignStatus
    subject?: string | null
    content: string
    targetTags?: CampaignCreatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    maxDownloads?: NullableIntFieldUpdateOperationsInput | number | null
    earlyAccess?: BoolFieldUpdateOperationsInput | boolean
    exclusiveContent?: BoolFieldUpdateOperationsInput | boolean
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    maxDownloads?: NullableIntFieldUpdateOperationsInput | number | null
    earlyAccess?: BoolFieldUpdateOperationsInput | boolean
    exclusiveContent?: BoolFieldUpdateOperationsInput | boolean
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    maxDownloads?: NullableIntFieldUpdateOperationsInput | number | null
    earlyAccess?: BoolFieldUpdateOperationsInput | boolean
    exclusiveContent?: BoolFieldUpdateOperationsInput | boolean
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    requiresSubscription?: BoolFieldUpdateOperationsInput | boolean
    tags?: ProductUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    purchaseCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    requiresSubscription?: BoolFieldUpdateOperationsInput | boolean
    tags?: ProductUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    purchaseCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessType?: EnumContentAccessFieldUpdateOperationsInput | $Enums.ContentAccess
    requiresSubscription?: BoolFieldUpdateOperationsInput | boolean
    tags?: ProductUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    purchaseCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fan?: FanUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fan?: FanUpdateOneWithoutTransactionsNestedInput
    purchase?: PurchaseUpdateOneWithoutTransactionNestedInput
    payout?: PayoutUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    stripePayoutId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutPayoutNestedInput
  }

  export type PayoutUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    stripePayoutId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutPayoutNestedInput
  }

  export type PayoutUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    stripePayoutId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newSubscribers?: IntFieldUpdateOperationsInput | number
    churned?: IntFieldUpdateOperationsInput | number
    activeSubscribers?: IntFieldUpdateOperationsInput | number
    pageViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    contentViews?: IntFieldUpdateOperationsInput | number
    conversionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newSubscribers?: IntFieldUpdateOperationsInput | number
    churned?: IntFieldUpdateOperationsInput | number
    activeSubscribers?: IntFieldUpdateOperationsInput | number
    pageViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    contentViews?: IntFieldUpdateOperationsInput | number
    conversionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptionRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newSubscribers?: IntFieldUpdateOperationsInput | number
    churned?: IntFieldUpdateOperationsInput | number
    activeSubscribers?: IntFieldUpdateOperationsInput | number
    pageViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    contentViews?: IntFieldUpdateOperationsInput | number
    conversionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avgOrderValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalledAppUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: NullableEnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval | null
    nextBilling?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uninstalledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app?: AppUpdateOneRequiredWithoutInstallationsNestedInput
  }

  export type InstalledAppUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: NullableEnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval | null
    nextBilling?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uninstalledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstalledAppUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: NullableEnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval | null
    nextBilling?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uninstalledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanRelationUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: FanRelationUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOptIn?: BoolFieldUpdateOperationsInput | boolean
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fan?: FanUpdateOneRequiredWithoutFanRelationsNestedInput
  }

  export type FanRelationUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    tags?: FanRelationUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOptIn?: BoolFieldUpdateOperationsInput | boolean
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanRelationUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    tags?: FanRelationUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOptIn?: BoolFieldUpdateOperationsInput | boolean
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    targetTags?: CampaignUpdatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: CampaignRecipientUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    targetTags?: CampaignUpdatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: CampaignRecipientUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    targetTags?: CampaignUpdatetargetTagsInput | string[]
    targetSegment?: NullableJsonNullValueInput | InputJsonValue
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    fanId: string
    creatorId: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fan?: FanUpdateOneRequiredWithoutSubscriptionsNestedInput
    creator?: CreatorUpdateOneRequiredWithoutSubscribersNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManyProductInput = {
    id?: string
    fanId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId?: string | null
    downloadCount?: number
    lastDownloadAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PurchaseUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fan?: FanUpdateOneRequiredWithoutPurchasesNestedInput
    transaction?: TransactionUpdateOneWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUncheckedUpdateOneWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyFanInput = {
    id?: string
    creatorId: string
    planId: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    stripeSubscriptionId?: string | null
    totalSpent?: Decimal | DecimalJsLike | number | string
    renewalCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyFanInput = {
    id?: string
    productId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status: $Enums.PurchaseStatus
    stripePaymentIntentId?: string | null
    downloadCount?: number
    lastDownloadAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TransactionCreateManyFanInput = {
    id?: string
    creatorId: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    purchaseId?: string | null
    payoutId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FanRelationCreateManyFanInput = {
    id?: string
    creatorId: string
    tags?: FanRelationCreatetagsInput | string[]
    notes?: string | null
    engagementScore?: number
    lifetimeValue?: Decimal | DecimalJsLike | number | string
    lastInteraction?: Date | string | null
    emailOptIn?: boolean
    smsOptIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignRecipientCreateManyFanInput = {
    id?: string
    campaignId: string
    status: $Enums.RecipientStatus
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
  }

  export type SubscriptionUpdateWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutSubscribersNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    renewalCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchasesNestedInput
    transaction?: TransactionUpdateOneWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUncheckedUpdateOneWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutTransactionsNestedInput
    purchase?: PurchaseUpdateOneWithoutTransactionNestedInput
    payout?: PayoutUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanRelationUpdateWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: FanRelationUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOptIn?: BoolFieldUpdateOperationsInput | boolean
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutFanRelationsNestedInput
  }

  export type FanRelationUncheckedUpdateWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    tags?: FanRelationUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOptIn?: BoolFieldUpdateOperationsInput | boolean
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanRelationUncheckedUpdateManyWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    tags?: FanRelationUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOptIn?: BoolFieldUpdateOperationsInput | boolean
    smsOptIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRecipientUpdateWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutRecipientsNestedInput
  }

  export type CampaignRecipientUncheckedUpdateWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignRecipientUncheckedUpdateManyWithoutFanInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyPayoutInput = {
    id?: string
    creatorId: string
    fanId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    platformFee: Decimal | DecimalJsLike | number | string
    platformFeeRate: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    subscriptionId?: string | null
    purchaseId?: string | null
    stripeTransferId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TransactionUpdateWithoutPayoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: CreatorUpdateOneRequiredWithoutTransactionsNestedInput
    fan?: FanUpdateOneWithoutTransactionsNestedInput
    purchase?: PurchaseUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPayoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fanId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutPayoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fanId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platformFeeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeTransferId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRecipientCreateManyCampaignInput = {
    id?: string
    fanId: string
    status: $Enums.RecipientStatus
    sentAt?: Date | string | null
    openedAt?: Date | string | null
    clickedAt?: Date | string | null
  }

  export type CampaignRecipientUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fan?: FanUpdateOneRequiredWithoutCampaignRecipientsNestedInput
  }

  export type CampaignRecipientUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignRecipientUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    fanId?: StringFieldUpdateOperationsInput | string
    status?: EnumRecipientStatusFieldUpdateOperationsInput | $Enums.RecipientStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstalledAppCreateManyAppInput = {
    id?: string
    creatorId: string
    status: $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: $Enums.BillingInterval | null
    nextBilling?: Date | string | null
    installedAt?: Date | string
    uninstalledAt?: Date | string | null
  }

  export type InstalledAppUpdateWithoutAppInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: NullableEnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval | null
    nextBilling?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uninstalledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: CreatorUpdateOneRequiredWithoutInstalledAppsNestedInput
  }

  export type InstalledAppUncheckedUpdateWithoutAppInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: NullableEnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval | null
    nextBilling?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uninstalledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstalledAppUncheckedUpdateManyWithoutAppInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    billingCycle?: NullableEnumBillingIntervalFieldUpdateOperationsInput | $Enums.BillingInterval | null
    nextBilling?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uninstalledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LedgerEntryCreateManyAccountInput = {
    id?: string
    txId: string
    direction: $Enums.LedgerDirection
    amountCents: bigint | number
    currency: string
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: LedgerTransactionUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    txId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    txId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyTransactionInput = {
    id?: string
    accountId: string
    direction: $Enums.LedgerDirection
    amountCents: bigint | number
    currency: string
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: LedgerAccountUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalEarningsImportCreateManySourceInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    rawHash: string
    rawJson: JsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type NormalizedEarningCreateManySourceInput = {
    id?: string
    occurredAt: Date | string
    currency: string
    grossCents: bigint | number
    feesCents: bigint | number
    netCents: bigint | number
    payoutId?: string | null
    extRef?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ExternalEarningsImportUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    rawHash?: StringFieldUpdateOperationsInput | string
    rawJson?: JsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalEarningsImportUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    rawHash?: StringFieldUpdateOperationsInput | string
    rawJson?: JsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalEarningsImportUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    rawHash?: StringFieldUpdateOperationsInput | string
    rawJson?: JsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NormalizedEarningUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    grossCents?: BigIntFieldUpdateOperationsInput | bigint | number
    feesCents?: BigIntFieldUpdateOperationsInput | bigint | number
    netCents?: BigIntFieldUpdateOperationsInput | bigint | number
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NormalizedEarningUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    grossCents?: BigIntFieldUpdateOperationsInput | bigint | number
    feesCents?: BigIntFieldUpdateOperationsInput | bigint | number
    netCents?: BigIntFieldUpdateOperationsInput | bigint | number
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NormalizedEarningUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    grossCents?: BigIntFieldUpdateOperationsInput | bigint | number
    feesCents?: BigIntFieldUpdateOperationsInput | bigint | number
    netCents?: BigIntFieldUpdateOperationsInput | bigint | number
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    extRef?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CreatorCountOutputTypeDefaultArgs instead
     */
    export type CreatorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreatorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FanCountOutputTypeDefaultArgs instead
     */
    export type FanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayoutCountOutputTypeDefaultArgs instead
     */
    export type PayoutCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayoutCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppCountOutputTypeDefaultArgs instead
     */
    export type AppCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LedgerAccountCountOutputTypeDefaultArgs instead
     */
    export type LedgerAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LedgerAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LedgerTransactionCountOutputTypeDefaultArgs instead
     */
    export type LedgerTransactionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LedgerTransactionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExternalEarningsSourceCountOutputTypeDefaultArgs instead
     */
    export type ExternalEarningsSourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExternalEarningsSourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreatorDefaultArgs instead
     */
    export type CreatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreatorSettingsDefaultArgs instead
     */
    export type CreatorSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreatorSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanDefaultArgs instead
     */
    export type SubscriptionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FanDefaultArgs instead
     */
    export type FanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseDefaultArgs instead
     */
    export type PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayoutDefaultArgs instead
     */
    export type PayoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayoutDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnalyticsDefaultArgs instead
     */
    export type AnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FanRelationDefaultArgs instead
     */
    export type FanRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FanRelationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignRecipientDefaultArgs instead
     */
    export type CampaignRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignRecipientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppDefaultArgs instead
     */
    export type AppArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstalledAppDefaultArgs instead
     */
    export type InstalledAppArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstalledAppDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LedgerAccountDefaultArgs instead
     */
    export type LedgerAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LedgerAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LedgerTransactionDefaultArgs instead
     */
    export type LedgerTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LedgerTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LedgerEntryDefaultArgs instead
     */
    export type LedgerEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LedgerEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommissionCapMonthlyDefaultArgs instead
     */
    export type CommissionCapMonthlyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommissionCapMonthlyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExternalEarningsSourceDefaultArgs instead
     */
    export type ExternalEarningsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExternalEarningsSourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExternalEarningsImportDefaultArgs instead
     */
    export type ExternalEarningsImportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExternalEarningsImportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NormalizedEarningDefaultArgs instead
     */
    export type NormalizedEarningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NormalizedEarningDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommissionStatementDefaultArgs instead
     */
    export type CommissionStatementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommissionStatementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DunningStateDefaultArgs instead
     */
    export type DunningStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DunningStateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentAttemptDefaultArgs instead
     */
    export type PaymentAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentAttemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutomationDefaultArgs instead
     */
    export type AutomationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BackupLogDefaultArgs instead
     */
    export type BackupLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BackupLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BackupValidationDefaultArgs instead
     */
    export type BackupValidationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BackupValidationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BackupIndexDefaultArgs instead
     */
    export type BackupIndexArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BackupIndexDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AIUsageLogDefaultArgs instead
     */
    export type AIUsageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AIUsageLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CostReservationDefaultArgs instead
     */
    export type CostReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CostReservationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromptOptimizationDefaultArgs instead
     */
    export type PromptOptimizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromptOptimizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CostAlertDefaultArgs instead
     */
    export type CostAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CostAlertDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}