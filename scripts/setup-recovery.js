#!/usr/bin/env node

/**
 * Recovery System Setup Script
 * Automated setup and configuration of recovery mechanisms
 */

const fs = require('fs').promises;
const path = require('path');

const RECOVERY_CONFIG = {
  circuitBreakers: {
    database: {
      failureThreshold: 5,
      timeout: 30000,
      resetTimeout: 60000,
      monitoringWindow: 300000
    },
    cache: {
      failureThreshold: 3,
      timeout: 15000,
      resetTimeout: 30000,
      monitoringWindow: 180000
    },
    externalAPI: {
      failureThreshold: 3,
      timeout: 10000,
      resetTimeout: 30000,
      monitoringWindow: 120000
    }
  },
  retryPolicies: {
    database: {
      maxAttempts: 3,
      baseDelay: 100,
      maxDelay: 2000,
      backoffMultiplier: 2,
      jitter: true
    },
    cache: {
      maxAttempts: 2,
      baseDelay: 50,
      maxDelay: 500,
      backoffMultiplier: 2,
      jitter: true
    },
    externalAPI: {
      maxAttempts: 3,
      baseDelay: 200,
      maxDelay: 5000,
      backoffMultiplier: 2,
      jitter: true
    }
  },
  healthChecks: {
    interval: 30000,
    timeout: 5000,
    deepCheckEnabled: true,
    checks: {
      database: { timeout: 5000, critical: true },
      cache: { timeout: 3000, critical: false },
      memory: { timeout: 1000, critical: false },
      disk: { timeout: 2000, critical: false }
    }
  },
  gracefulDegradation: {
    evaluationInterval: 60000,
    rules: {
      highMemoryUsage: {
        level: 2,
        priority: 100,
        memoryThreshold: 85
      },
      databaseIssues: {
        level: 3,
        priority: 200
      },
      cacheServiceDown: {
        level: 1,
        priority: 50
      },
      externalAPIFailures: {
        level: 2,
        priority: 75,
        failureRateThreshold: 50
      }
    }
  },
  autoHealing: {
    enabled: true,
    actions: {
      databaseReconnect: {
        cooldown: 30000,
        maxAttempts: 3,
        priority: 100
      },
      cacheRestart: {
        cooldown: 15000,
        maxAttempts: 2,
        priority: 80
      },
      memoryCleanup: {
        cooldown: 60000,
        maxAttempts: 5,
        priority: 60
      },
      circuitBreakerReset: {
        cooldown: 120000,
        maxAttempts: 1,
        priority: 40
      },
      serviceHealthRestore: {
        cooldown: 45000,
        maxAttempts: 2,
        priority: 90
      }
    }
  },
  monitoring: {
    metricsRetention: 86400000, // 24 hours
    historySize: 100,
    alertThresholds: {
      circuitBreakerOpen: 1,
      healthCheckFailures: 3,
      healingFailures: 5,
      degradationLevel: 2
    }
  }
};

async function setupRecoverySystem() {
  console.log('üîß Setting up Recovery System...\n');

  try {
    // 1. Create recovery configuration file
    console.log('üìù Creating recovery configuration...');
    await fs.writeFile(
      'recovery.config.json',
      JSON.stringify(RECOVERY_CONFIG, null, 2)
    );
    console.log('‚úÖ Recovery configuration created\n');

    // 2. Verify recovery modules exist
    console.log('üîç Verifying recovery modules...');
    const modules = [
      'lib/recovery/circuitBreaker.ts',
      'lib/recovery/retryManager.ts',
      'lib/recovery/healthChecker.ts',
      'lib/recovery/gracefulDegradation.ts',
      'lib/recovery/autoHealing.ts'
    ];

    for (const module of modules) {
      try {
        await fs.access(module);
        console.log(`‚úÖ ${module}`);
      } catch (error) {
        console.log(`‚ùå ${module} - Missing!`);
        throw new Error(`Required module ${module} not found`);
      }
    }
    console.log('');

    // 3. Create recovery initialization script
    console.log('üöÄ Creating recovery initialization script...');
    const initScript = `/**
 * Recovery System Initialization
 * Auto-generated by setup-recovery.js
 */

import { setupDefaultHealthChecks } from '@/lib/recovery/healthChecker';
import { setupDefaultDegradationRules } from '@/lib/recovery/gracefulDegradation';
import { setupDefaultHealingActions } from '@/lib/recovery/autoHealing';

let recoveryInitialized = false;

export async function initializeRecoverySystem() {
  if (recoveryInitialized) {
    console.log('Recovery system already initialized');
    return;
  }

  try {
    console.log('üîß Initializing recovery system...');

    // Setup health checks
    setupDefaultHealthChecks();
    console.log('‚úÖ Health checks configured');

    // Setup degradation rules
    setupDefaultDegradationRules();
    console.log('‚úÖ Graceful degradation rules configured');

    // Setup auto-healing actions
    setupDefaultHealingActions();
    console.log('‚úÖ Auto-healing actions configured');

    recoveryInitialized = true;
    console.log('üöÄ Recovery system initialized successfully');

    // Start periodic evaluations
    startPeriodicEvaluations();
  } catch (error) {
    console.error('‚ùå Recovery system initialization failed:', error);
    throw error;
  }
}

function startPeriodicEvaluations() {
  // Health check evaluation every 30 seconds
  setInterval(async () => {
    try {
      const { healthChecker } = await import('@/lib/recovery/healthChecker');
      await healthChecker.runAllChecks();
    } catch (error) {
      console.error('Health check evaluation failed:', error);
    }
  }, 30000);

  // Degradation rule evaluation every minute
  setInterval(async () => {
    try {
      const { degradationManager } = await import('@/lib/recovery/gracefulDegradation');
      await degradationManager.evaluateRules();
    } catch (error) {
      console.error('Degradation rule evaluation failed:', error);
    }
  }, 60000);
}

// Auto-initialize in production
if (process.env.NODE_ENV === 'production') {
  initializeRecoverySystem().catch(console.error);
}
`;

    await fs.writeFile('lib/recovery/init.ts', initScript);
    console.log('‚úÖ Recovery initialization script created\n');

    // 4. Create recovery middleware
    console.log('üîå Creating recovery middleware...');
    const middlewareScript = `/**
 * Recovery Middleware
 * Integrates recovery mechanisms with Next.js requests
 */

import { NextRequest, NextResponse } from 'next/server';
import { executeWithCircuitBreaker } from '@/lib/recovery/circuitBreaker';
import { retryManager } from '@/lib/recovery/retryManager';
import { degradationManager } from '@/lib/recovery/gracefulDegradation';

export async function recoveryMiddleware(
  request: NextRequest,
  handler: () => Promise<NextResponse>
): Promise<NextResponse> {
  const startTime = Date.now();
  
  try {
    // Check if feature is enabled (graceful degradation)
    const isAPIRequest = request.nextUrl.pathname.startsWith('/api/');
    
    if (isAPIRequest) {
      // Use circuit breaker for API requests
      return await executeWithCircuitBreaker(
        'api-requests',
        async () => {
          return await retryManager.executeWithRetry(
            handler,
            { maxAttempts: 2, baseDelay: 100 },
            'api-handler'
          );
        }
      );
    } else {
      // Regular request handling with degradation check
      const degradationStatus = await degradationManager.evaluateRules();
      
      if (degradationStatus.level >= 3) {
        // Severe degradation - serve simplified response
        return new NextResponse(
          'Service temporarily degraded. Please try again later.',
          { status: 503 }
        );
      }
      
      return await handler();
    }
  } catch (error) {
    const duration = Date.now() - startTime;
    
    // Log error for monitoring
    console.error('Request failed:', {
      path: request.nextUrl.pathname,
      method: request.method,
      duration,
      error: error.message
    });
    
    // Check if we should trigger auto-healing
    if (duration > 5000 || error.message.includes('timeout')) {
      const { autoHealingManager } = await import('@/lib/recovery/autoHealing');
      autoHealingManager.executeAllApplicableActions().catch(console.error);
    }
    
    throw error;
  }
}
`;

    await fs.writeFile('lib/recovery/middleware.ts', middlewareScript);
    console.log('‚úÖ Recovery middleware created\n');

    // 5. Create package.json scripts
    console.log('üì¶ Adding NPM scripts...');
    try {
      const packageJsonPath = 'package.json';
      const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
      
      packageJson.scripts = packageJson.scripts || {};
      packageJson.scripts['recovery:setup'] = 'node scripts/setup-recovery.js';
      packageJson.scripts['recovery:test'] = 'node scripts/test-recovery.js';
      packageJson.scripts['recovery:status'] = 'curl http://localhost:3000/api/recovery/status';
      packageJson.scripts['recovery:dashboard'] = 'open http://localhost:3000/recovery/dashboard';
      
      await fs.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
      console.log('‚úÖ NPM scripts added\n');
    } catch (error) {
      console.log('‚ö†Ô∏è  Could not update package.json scripts\n');
    }

    // 6. Create test script
    console.log('üß™ Creating recovery test script...');
    const testScript = `#!/usr/bin/env node

/**
 * Recovery System Test Script
 */

const http = require('http');

async function testRecoverySystem() {
  console.log('üß™ Testing Recovery System...\\n');
  
  try {
    // Test recovery status endpoint
    console.log('üìä Testing recovery status endpoint...');
    const response = await fetch('http://localhost:3000/api/recovery/status');
    
    if (response.ok) {
      const data = await response.json();
      console.log('‚úÖ Recovery status endpoint working');
      console.log(\`   Status: \${data.status}\`);
      console.log(\`   Circuit Breakers: \${data.recovery.circuitBreakers.summary.total}\`);
      console.log(\`   Health Checks: \${data.recovery.healthChecks.summary.total}\`);
    } else {
      console.log('‚ùå Recovery status endpoint failed');
    }
    
    // Test circuit breaker reset
    console.log('\\nüîÑ Testing circuit breaker reset...');
    const resetResponse = await fetch('http://localhost:3000/api/recovery/status', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'reset_circuit_breaker' })
    });
    
    if (resetResponse.ok) {
      console.log('‚úÖ Circuit breaker reset working');
    } else {
      console.log('‚ùå Circuit breaker reset failed');
    }
    
    // Test auto-healing trigger
    console.log('\\nüîß Testing auto-healing trigger...');
    const healingResponse = await fetch('http://localhost:3000/api/recovery/status', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'trigger_healing' })
    });
    
    if (healingResponse.ok) {
      console.log('‚úÖ Auto-healing trigger working');
    } else {
      console.log('‚ùå Auto-healing trigger failed');
    }
    
    console.log('\\nüéâ Recovery system test completed!');
    
  } catch (error) {
    console.error('‚ùå Recovery system test failed:', error.message);
    console.log('\\nüí° Make sure the development server is running: npm run dev');
  }
}

testRecoverySystem();
`;

    await fs.writeFile('scripts/test-recovery.js', testScript);
    await fs.chmod('scripts/test-recovery.js', 0o755);
    console.log('‚úÖ Recovery test script created\n');

    // 7. Create documentation
    console.log('üìö Creating recovery documentation...');
    const documentation = `# Recovery System Documentation

## Overview
The recovery system provides comprehensive resilience mechanisms to ensure system reliability and automatic healing from failures.

## Components

### 1. Circuit Breakers
- **Purpose**: Prevent cascade failures by monitoring service health
- **States**: CLOSED (normal) ‚Üí OPEN (failing) ‚Üí HALF_OPEN (testing)
- **Configuration**: \`recovery.config.json\`

### 2. Retry Manager
- **Purpose**: Handle transient failures with intelligent retry logic
- **Features**: Exponential backoff, jitter, configurable conditions
- **Policies**: Database, cache, external API specific

### 3. Health Checker
- **Purpose**: Continuous service health monitoring
- **Checks**: Database, cache, memory, disk
- **Types**: Readiness probes, liveness probes, deep health checks

### 4. Graceful Degradation
- **Purpose**: Maintain core functionality during service failures
- **Levels**: None (0) ‚Üí Minimal (1) ‚Üí Moderate (2) ‚Üí Severe (3) ‚Üí Emergency (4)
- **Actions**: Disable features, use cache, simplify UI, reduce quality

### 5. Auto-Healing
- **Purpose**: Automatic recovery from common failure scenarios
- **Actions**: Database reconnect, cache restart, memory cleanup
- **Policies**: Cooldown periods, max attempts, priority-based execution

## Usage

### Initialization
\`\`\`typescript
import { initializeRecoverySystem } from '@/lib/recovery/init';
await initializeRecoverySystem();
\`\`\`

### Circuit Breaker
\`\`\`typescript
import { executeWithCircuitBreaker } from '@/lib/recovery/circuitBreaker';

const result = await executeWithCircuitBreaker('database', async () => {
  return await db.query('SELECT * FROM users');
});
\`\`\`

### Retry Logic
\`\`\`typescript
import { retryDatabaseOperation } from '@/lib/recovery/retryManager';

const result = await retryDatabaseOperation(async () => {
  return await db.query('SELECT * FROM users');
});
\`\`\`

### Health Checks
\`\`\`typescript
import { checkSystemHealth } from '@/lib/recovery/healthChecker';

const health = await checkSystemHealth();
console.log(\`System status: \${health.status}\`);
\`\`\`

### Graceful Degradation
\`\`\`typescript
import { isFeatureEnabled } from '@/lib/recovery/gracefulDegradation';

if (isFeatureEnabled('analytics_real_time')) {
  // Show real-time analytics
} else {
  // Show cached analytics
}
\`\`\`

### Auto-Healing
\`\`\`typescript
import { triggerAutoHealing } from '@/lib/recovery/autoHealing';

// Trigger specific healing action
await triggerAutoHealing('database_reconnect');

// Trigger all applicable actions
await triggerAutoHealing();
\`\`\`

## API Endpoints

### Recovery Status
- **GET** \`/api/recovery/status\` - Get recovery system status
- **POST** \`/api/recovery/status\` - Trigger recovery actions

### Parameters
- \`?history=true\` - Include healing history
- \`?metrics=true\` - Include detailed metrics

### Actions
- \`trigger_healing\` - Execute healing actions
- \`reset_circuit_breaker\` - Reset circuit breakers
- \`reset_retry_metrics\` - Reset retry metrics
- \`force_degradation_check\` - Force degradation evaluation

## Dashboard

Access the recovery dashboard at: \`/recovery/dashboard\`

Features:
- Real-time system status
- Circuit breaker monitoring
- Health check results
- Auto-healing history
- Manual action triggers

## Configuration

Edit \`recovery.config.json\` to customize:
- Circuit breaker thresholds
- Retry policies
- Health check intervals
- Degradation rules
- Auto-healing actions

## Monitoring

The recovery system integrates with the monitoring system to provide:
- Recovery metrics collection
- Alert generation
- Performance tracking
- Historical analysis

## Best Practices

1. **Circuit Breakers**: Set appropriate failure thresholds for each service
2. **Retry Logic**: Use exponential backoff with jitter
3. **Health Checks**: Monitor critical dependencies
4. **Degradation**: Define clear degradation levels and actions
5. **Auto-Healing**: Implement cooldown periods to prevent thrashing

## Troubleshooting

### Common Issues
1. **Circuit breaker stuck open**: Check service health and reset manually
2. **Excessive retries**: Adjust retry policies or fix underlying issues
3. **Health checks failing**: Verify service connectivity and timeouts
4. **Degradation not working**: Check rule conditions and priorities

### Debug Commands
\`\`\`bash
# Check recovery status
npm run recovery:status

# Test recovery system
npm run recovery:test

# Open recovery dashboard
npm run recovery:dashboard
\`\`\`
`;

    await fs.writeFile('docs/RECOVERY_SYSTEM.md', documentation);
    console.log('‚úÖ Recovery documentation created\n');

    // Success message
    console.log('üéâ Recovery System Setup Complete!\n');
    console.log('üìã Summary:');
    console.log('   ‚úÖ Configuration file created (recovery.config.json)');
    console.log('   ‚úÖ Initialization script created (lib/recovery/init.ts)');
    console.log('   ‚úÖ Middleware created (lib/recovery/middleware.ts)');
    console.log('   ‚úÖ Test script created (scripts/test-recovery.js)');
    console.log('   ‚úÖ Documentation created (docs/RECOVERY_SYSTEM.md)');
    console.log('   ‚úÖ NPM scripts added to package.json\n');
    
    console.log('üöÄ Next Steps:');
    console.log('   1. Start your development server: npm run dev');
    console.log('   2. Test the recovery system: npm run recovery:test');
    console.log('   3. View the dashboard: npm run recovery:dashboard');
    console.log('   4. Check the documentation: docs/RECOVERY_SYSTEM.md\n');
    
    console.log('üîß The recovery system will auto-initialize in production.');
    console.log('   For development, call initializeRecoverySystem() in your app.\n');

  } catch (error) {
    console.error('‚ùå Recovery system setup failed:', error);
    process.exit(1);
  }
}

// Run setup
setupRecoverySystem();