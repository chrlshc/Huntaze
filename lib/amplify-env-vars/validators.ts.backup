import { ValidationResult, EnvironmentVariable } from './types';
import { VALIDATION_RULES } from './constants';

// Helper function to create ValidationResult objects
function createValidationResult(
  isValid: boolean,
  variable: string,
  message: string,
  severity: 'critical' | 'error' | 'warning' = 'error'
): ValidationResult {
  if (isValid) {
    return {
      isValid: true,
      errors: [],
      warnings: [],
      suggestions: []
    };
  } else if (severity === 'warning') {
    return {
      isValid: false,
      errors: [],
      warnings: [{ variable, message }],
      suggestions: []
    };
  } else {
    return {
      isValid: false,
      errors: [{ variable, message, severity }],
      warnings: [],
      suggestions: []
    };
  }
}

/**
 * Core validation engine for environment variables
 */
export class VariableValidator {
  /**
   * Validate a single environment variable
   */
  static validateVariable(variable: EnvironmentVariable): ValidationResult {
    const { key, value } = variable;
    
    // Get validation rules for this variable
    const rules = VALIDATION_RULES[key];
    if (!rules) {
      return createValidationResult(true, key, 'No specific validation rules defined');
    }

    // Run all applicable validators
    const results: ValidationResult[] = [];

    if (rules.required && (!value || value.trim() === '')) {
      results.push(createValidationResult(false, key, 'Required variable is missing or empty', 'error'));
    }

    if (value && rules.format) {
      const formatResult = this.validateFormat(key, value, rules.format);
      results.push(formatResult);
    }

    if (value && rules.minLength && value.length < rules.minLength) {
      results.push(createValidationResult(false, key, `Value too short. Minimum length: ${rules.minLength}`, 'error'));
    }

    if (value && rules.maxLength && value.length > rules.maxLength) {
      results.push(createValidationResult(false, key, `Value too long. Maximum length: ${rules.maxLength}`, 'error'));
    }

    // Return the most severe result
    const errors = results.filter(r => !r.isValid);
    if (errors.length > 0) {
      return errors[0];
    }

    return createValidationResult(true, key, 'Variable validation passed');
  }

  /**
   * Validate format based on type
   */
  private static validateFormat(key: string, value: string, format: string): ValidationResult {
    switch (format) {
      case 'database_url':
        return this.validateDatabaseUrl(key, value);
      case 'jwt_secret':
        return this.validateJwtSecret(key, value);
      case 'azure_openai':
        return this.validateAzureOpenAI(key, value);
      case 'url':
        return this.validateUrl(key, value);
      case 'email':
        return this.validateEmail(key, value);
      case 'uuid':
        return this.validateUuid(key, value);
      case 'base64':
        return this.validateBase64(key, value);
      default:
        return createValidationResult(true, key, `Unknown format type: ${format}`, 'warning');
    }
  }

  /**
   * Validate PostgreSQL database URL format
   */
  static validateDatabaseUrl(key: string, value: string): ValidationResult {
    const postgresPattern = /^postgresql:\/\/([^:]+):([^@]+)@([^:]+):(\d+)\/(.+)$/;
    
    if (!postgresPattern.test(value)) {
      return createValidationResult(
        isValid: false,
        variable: key,
        message: 'Invalid PostgreSQL connection string format. Expected: postgresql://user:password@host:port/database',
        severity: 'error'
      };
    }

    const match = value.match(postgresPattern);
    if (match) {
      const [, username, password, host, port, database] = match;
      
      // Validate components
      if (!username || username.length < 1) {
        return createValidationResult(
          isValid: false,
          variable: key,
          message: 'Database username cannot be empty',
          severity: 'error'
        };
      }

      if (!password || password.length < 1) {
        return createValidationResult(
          isValid: false,
          variable: key,
          message: 'Database password cannot be empty',
          severity: 'error'
        };
      }

      const portNum = parseInt(port);
      if (isNaN(portNum) || portNum < 1 || portNum > 65535) {
        return createValidationResult(
          isValid: false,
          variable: key,
          message: 'Invalid port number. Must be between 1 and 65535',
          severity: 'error'
        };
      }

      if (!database || database.length < 1) {
        return createValidationResult(
          isValid: false,
          variable: key,
          message: 'Database name cannot be empty',
          severity: 'error'
        };
      }
    }

    return createValidationResult(
      isValid: true,
      variable: key,
      message: 'Valid PostgreSQL connection string',
      severity: 'success'
    };
  }

  /**
   * Validate JWT secret format and strength
   */
  static validateJwtSecret(key: string, value: string): ValidationResult {
    // Check minimum length (recommended 32+ characters)
    if (value.length < 32) {
      return createValidationResult(
        isValid: false,
        variable: key,
        message: 'JWT secret too short. Minimum recommended length: 32 characters',
        severity: 'error'
      };
    }

    // Check for base64 encoding (optional but recommended)
    const base64Pattern = /^[A-Za-z0-9+/]*={0,2}$/;
    const isBase64 = base64Pattern.test(value) && value.length % 4 === 0;

    // Check entropy (basic check for randomness)
    const uniqueChars = new Set(value).size;
    const entropyRatio = uniqueChars / value.length;

    if (entropyRatio < 0.3) {
      return createValidationResult(
        isValid: false,
        variable: key,
        message: 'JWT secret appears to have low entropy. Use a randomly generated secret',
        severity: 'warning'
      };
    }

    // Check for common weak patterns
    const weakPatterns = [
      /^(.)\1+$/, // All same character
      /^(012|123|abc|password|secret)/i, // Common weak starts
      /^[a-z]+$/i, // Only letters
      /^\d+$/ // Only numbers
    ];

    for (const pattern of weakPatterns) {
      if (pattern.test(value)) {
        return createValidationResult(
          isValid: false,
          variable: key,
          message: 'JWT secret uses weak pattern. Use a cryptographically secure random string',
          severity: 'error'
        };
      }
    }

    return createValidationResult(
      isValid: true,
      variable: key,
      message: isBase64 ? 'Valid JWT secret (Base64 encoded)' : 'Valid JWT secret',
      severity: 'success'
    };
  }

  /**
   * Validate Azure OpenAI configuration
   */
  static validateAzureOpenAI(key: string, value: string): ValidationResult {
    if (key.includes('ENDPOINT')) {
      // Validate Azure OpenAI endpoint URL
      const azurePattern = /^https:\/\/[a-zA-Z0-9-]+\.openai\.azure\.com\/?$/;
      
      if (!azurePattern.test(value)) {
        return createValidationResult(
          isValid: false,
          variable: key,
          message: 'Invalid Azure OpenAI endpoint format. Expected: https://your-resource.openai.azure.com',
          severity: 'error'
        };
      }
    } else if (key.includes('API_KEY')) {
      // Validate Azure OpenAI API key format
      if (value.length !== 32) {
        return createValidationResult(
          isValid: false,
          variable: key,
          message: 'Azure OpenAI API key should be 32 characters long',
          severity: 'warning'
        };
      }

      const keyPattern = /^[a-f0-9]{32}$/;
      if (!keyPattern.test(value)) {
        return createValidationResult(
          isValid: false,
          variable: key,
          message: 'Azure OpenAI API key should contain only hexadecimal characters',
          severity: 'warning'
        };
      }
    } else if (key.includes('DEPLOYMENT')) {
      // Validate deployment name
      const deploymentPattern = /^[a-zA-Z0-9-_]+$/;
      
      if (!deploymentPattern.test(value)) {
        return createValidationResult(
          isValid: false,
          variable: key,
          message: 'Azure OpenAI deployment name can only contain letters, numbers, hyphens, and underscores',
          severity: 'error'
        };
      }
    }

    return createValidationResult(
      isValid: true,
      variable: key,
      message: 'Valid Azure OpenAI configuration',
      severity: 'success'
    };
  }

  /**
   * Validate URL format
   */
  static validateUrl(key: string, value: string): ValidationResult {
    try {
      const url = new URL(value);
      
      // Check for HTTPS in production-like environments
      if (url.protocol !== 'https:' && !url.hostname.includes('localhost') && !url.hostname.includes('127.0.0.1')) {
        return createValidationResult(
          isValid: false,
          variable: key,
          message: 'URL should use HTTPS protocol for security',
          severity: 'warning'
        };
      }

      return createValidationResult(
        isValid: true,
        variable: key,
        message: 'Valid URL format',
        severity: 'success'
      };
    } catch (error) {
      return createValidationResult(
        isValid: false,
        variable: key,
        message: 'Invalid URL format',
        severity: 'error'
      };
    }
  }

  /**
   * Validate email format
   */
  static validateEmail(key: string, value: string): ValidationResult {
    const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    
    if (!emailPattern.test(value)) {
      return createValidationResult(
        isValid: false,
        variable: key,
        message: 'Invalid email format',
        severity: 'error'
      };
    }

    return createValidationResult(
      isValid: true,
      variable: key,
      message: 'Valid email format',
      severity: 'success'
    };
  }

  /**
   * Validate UUID format
   */
  static validateUuid(key: string, value: string): ValidationResult {
    const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    
    if (!uuidPattern.test(value)) {
      return createValidationResult(
        isValid: false,
        variable: key,
        message: 'Invalid UUID format',
        severity: 'error'
      };
    }

    return createValidationResult(
      isValid: true,
      variable: key,
      message: 'Valid UUID format',
      severity: 'success'
    };
  }

  /**
   * Validate Base64 format
   */
  static validateBase64(key: string, value: string): ValidationResult {
    const base64Pattern = /^[A-Za-z0-9+/]*={0,2}$/;
    
    if (!base64Pattern.test(value) || value.length % 4 !== 0) {
      return createValidationResult(
        isValid: false,
        variable: key,
        message: 'Invalid Base64 format',
        severity: 'error'
      };
    }

    try {
      // Try to decode to verify it's valid Base64
      atob(value);
      return createValidationResult(
        isValid: true,
        variable: key,
        message: 'Valid Base64 format',
        severity: 'success'
      };
    } catch (error) {
      return createValidationResult(
        isValid: false,
        variable: key,
        message: 'Invalid Base64 encoding',
        severity: 'error'
      };
    }
  }

  /**
   * Validate multiple variables
   */
  static validateVariables(variables: EnvironmentVariable[]): ValidationResult[] {
    return variables.map(variable => this.validateVariable(variable));
  }

  /**
   * Get validation summary
   */
  static getValidationSummary(results: ValidationResult[]): {
    total: number;
    passed: number;
    failed: number;
    warnings: number;
    errors: number;
  } {
    const total = results.length;
    const passed = results.filter(r => r.isValid).length;
    const failed = results.filter(r => !r.isValid).length;
    const warnings = results.filter(r => r.severity === 'warning').length;
    const errors = results.filter(r => r.severity === 'error').length;

    return { total, passed, failed, warnings, errors };
  }
}