interface ScalingMetrics {
    cpuUsage?: number;
    memoryUsage?: number;
    requestRate?: number;
    responseTime?: number;
    errorRate: number;
    serviceName: string;
    instanceCount: number;
    avgCpuUtilization: number;
    avgMemoryUtilization: number;
    avgResponseTime: number;
    totalRequests: number;
    timestamp: Date;
    lastScaleUpTime?: number;
    lastScaleDownTime?: number;
    scaleUpCount?: number;
    scaleDownCount?: number;
}
interface ServiceInstance {
    id: string;
    status: 'active' | 'inactive' | 'starting' | 'stopping' | 'healthy' | 'unhealthy' | 'draining';
    health?: 'healthy' | 'unhealthy';
    load?: number;
    serviceName?: string;
    host?: string;
    port?: number;
    createdAt?: Date;
    lastHealthCheck?: Date;
    activeConnections?: number;
    cpuUtilization?: number;
    memoryUtilization?: number;
    responseTime?: number;
    consecutiveFailures?: number;
    healthCheckTimer?: NodeJS.Timeout;
    requestCount?: number;
    errorCount?: number;
}
interface AutoScalingConfig {
    minInstances: number;
    maxInstances: number;
    targetCPU?: number;
    targetCpuUtilization?: number;
    targetMemory?: number;
    targetMemoryUtilization?: number;
    scaleUpThreshold: number;
    scaleDownThreshold: number;
    cooldownPeriod?: number;
    scaleUpCooldown?: number;
    scaleDownCooldown?: number;
    metricsWindow?: number;
    enabled?: boolean;
}
export declare class HorizontalScaler {
    private serviceInstances;
    private scalingMetrics;
    private autoScalingConfigs;
    private loadBalancers;
    constructor();
    initialize(): Promise<void>;
    private initializeScalingConfigs;
    private initializeLoadBalancers;
    registerServiceInstance(serviceName: string, instance: ServiceInstance): Promise<void>;
    deregisterServiceInstance(serviceName: string, instanceId: string): Promise<void>;
    getServiceInstance(serviceName: string, context?: any): Promise<ServiceInstance | null>;
    private getHealthyInstances;
    private selectInstance;
    private roundRobinSelection;
    private weightedRoundRobinSelection;
    private leastConnectionsSelection;
    private consistentHashingSelection;
    private simpleHash;
    checkAutoScaling(): Promise<void>;
    private evaluateScaling;
    private shouldScaleUp;
    private shouldScaleDown;
    private scaleUp;
    private scaleDown;
    private createServiceInstance;
    private terminateServiceInstance;
    private drainInstance;
    private initializeInstanceHealthCheck;
    private performHealthCheck;
    private collectServiceMetrics;
    private calculateErrorRate;
    private updateScalingMetrics;
    private getServicePort;
    private setupServiceDiscovery;
    private initializeHealthChecks;
    private startAutoScalingMonitoring;
    getServiceInstances(serviceName: string): ServiceInstance[];
    getScalingMetrics(serviceName: string): ScalingMetrics | undefined;
    getAllScalingMetrics(): Map<string, ScalingMetrics>;
    updateAutoScalingConfig(serviceName: string, config: Partial<AutoScalingConfig>): Promise<void>;
    generateScalingReport(): Promise<string>;
}
export {};
